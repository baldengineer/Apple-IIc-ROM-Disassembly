<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" href="SGStyle.css"/>

    <meta name="description" content="SourceGen-generated disassembly of Apple IIc bank2 of 03-342-0445 - A.bin"/>
    <title>Apple IIc bank2 of 03-342-0445 - A.bin Disassembly</title>
</head>

<body>

<p style="font-size:smaller;"><a href="./">(back to project page)</a></p>
<h1>Apple IIc bank2 of 03-342-0445 - A.bin Disassembly</h1>

<div id="code-lines">
    <!-- The CodeLines marker is not optional, and may only appear once -->
<pre>********************************************************************************
* Apple IIc ROM3  - Bank 2                                                     *
* Re-created by James Lewis (@baldengineer)                                    *
* *****************************************************************            *
* ** Work In-Progress! ** Work In-Progress! ** Work In-Progress! **            *
* *****************************************************************            *
*                                                                              *
* For more information visit:                                                  *
* https://github.com/baldengineer/Apple-IIc-ROM-Disassembly                    *
*                                                                              *
* (Original attributions are in comments below, as shown in original ROM       *
* Listings.)                                                                   *
*                                                                              *
* Recreated work licensed as Attribution-NonCommercial-ShareAlike 4.0          *
* International.                                                               *
*                                                                              *
* Generated with 6502bench SourceGen v1.8.4                                    *
*                                                                              *
* *****                                                                        *
* pdf page 508 has the equates                                                 *
********************************************************************************
<span id="SymMMUIDX">MMUIDX</span>          .eq     $01    {const}
<span id="Syminent">inent</span>           .eq     $05    {const}
<span id="SymIOUIDX">IOUIDX</span>          .eq     $09    {const}
<span id="SymGLUIDX">GLUIDX</span>          .eq     $11    {const}
<span id="Symesc">esc</span>             .eq     $1b    {const}    ;ascii esc
<span id="Symlfeed">lfeed</span>           .eq     $8a    {const}    ;Linefeed
<span id="Symxon">xon</span>             .eq     $91    {const}    ;XON character
<span id="Symxoff">xoff</span>            .eq     $93    {const}    ;XOFF character
<span id="Symdot">dot</span>             .eq     $ae    {const}    ;ascii period
<span id="Symcmdcur">cmdcur</span>          .eq     191    {const}    ;'?' ;63_128 ;Cursor while in command mode
<span id="Symtermcur">termcur</span>         .eq     223    {const}    ;'_' ;95+128 ;Cursor while in terminal mode
<span id="Symsermode">sermode</span>         .eq     $03b8  {const}    ;D7=1 if in command D6=1 if terminal
<span id="Symdevno2">devno2</span>          .eq     $c142  {const}    ;$C203-sltdmy
<span id="Symsetv">setv</span>            .eq     $c82a  {const}
<span id="SymPowerReset">PowerReset</span>      .eq     $00
<span id="Symtestnum">testnum</span>         .eq     $00
<span id="Symucspace">ucspace</span>         .eq     $00
<span id="Symbadcmd">badcmd</span>          .eq     $01               ;bad command
<span id="SymBadCmd">BadCmd</span>          .eq     $01
<span id="Symnoanswer">noanswer</span>        .eq     $01
<span id="Symibdrvn">ibdrvn</span>          .eq     $02               ;drive 1 or 2
<span id="Symmovmode">movmode</span>         .eq     $02               ;D1 mask
<span id="SymWriteCmd">WriteCmd</span>        .eq     $02
<span id="Symbadpcnt">badpcnt</span>         .eq     $04               ;bad parameter count
<span id="SymBadPCnt">BadPCnt</span>         .eq     $04
<span id="Symbutmode">butmode</span>         .eq     $04               ;D2 mask
<span id="SymControlCmd">ControlCmd</span>      .eq     $04
<span id="Symibtrk">ibtrk</span>           .eq     $04               ;track number
<span id="SymInitCmd">InitCmd</span>         .eq     $05
<span id="SymRC2">RC2</span>             .eq     $05               ;Data Packs get tried only 5 times
<span id="SymBusErr">BusErr</span>          .eq     $06
<span id="Symiwmmode">iwmmode</span>         .eq     $07               ;No timer, asynch, latch
<span id="Symibbufp">ibbufp</span>          .eq     $08               ;buffer pointer
<span id="Symcmdlength">cmdlength</span>       .eq     $09               ;Command packet length
<span id="Symbsyto2">bsyto2</span>          .eq     $0a               ;(.12 ms) T/O on /BSY after send
<span id="Symibcmd">ibcmd</span>           .eq     $0c               ;command
<span id="Symvblmode">vblmode</span>         .eq     $0c
<span id="SymcharCR">charCR</span>          .eq     $0d
<span id="Symcsumerr">csumerr</span>         .eq     $10
<span id="SymBadUnit">BadUnit</span>         .eq     $11
<span id="SymZPSize">ZPSize</span>          .eq     $1c
<span id="Symstatmto">statmto</span>         .eq     $1e               ;30 bytes stat mark timeout
<span id="Symmovarm">movarm</span>          .eq     $20
<span id="Symnopackend">nopackend</span>       .eq     $20
<span id="Symbadctl">badctl</span>          .eq     $21               ;bad control / status code
<span id="SymBadCtl">BadCtl</span>          .eq     $21
<span id="Symch">ch</span>              .eq     $24
<span id="Symcv">cv</span>              .eq     $25
<span id="SymIOError">IOError</span>         .eq     $27
<span id="Symbasl">basl</span>            .eq     $28
<span id="SymNoDrive">NoDrive</span>         .eq     $28
<span id="SymWriteProt">WriteProt</span>       .eq     $2b
<span id="Symdoscat">doscat</span>          .eq     $2c               ;$DAD4-DAA7-7
<span id="Symbadblk">badblk</span>          .eq     $2d               ;bad block or address
<span id="SymOffline">Offline</span>         .eq     $2f
<span id="Symkswl">kswl</span>            .eq     $38
<span id="Symkswh">kswh</span>            .eq     $39
<span id="SymA1L">A1L</span>             .eq     $3c
<span id="SymA1H">A1H</span>             .eq     $3d
<span id="SymA2L">A2L</span>             .eq     $3e
<span id="SymA2H">A2H</span>             .eq     $3f
<span id="Symbushog">bushog</span>          .eq     $40
<span id="Symchecksum">checksum</span>        .eq     $40
<span id="Symzeropage">zeropage</span>        .eq     $40
<span id="Symtopbits">topbits</span>         .eq     $41
<span id="SymA4L">A4L</span>             .eq     $42
<span id="SymCMDCode">CMDCode</span>         .eq     $42
<span id="Symmptr">mptr</span>            .eq     $42               ;indirect pointer to messages
<span id="SymA4H">A4H</span>             .eq     $43
<span id="SymCMDPcount">CMDPcount</span>       .eq     $43
<span id="SymCMDUnit">CMDUnit</span>         .eq     $43
<span id="Symbuffer">buffer</span>          .eq     $44               ;pointer to 512 byte data buffer
<span id="SymCMDBuffer">CMDBuffer</span>       .eq     $44
<span id="SymCMDBufferl">CMDBufferl</span>      .eq     $44
<span id="SymCMDBufferh">CMDBufferh</span>      .eq     $45
<span id="Symcompdata">compdata</span>        .eq     $45
<span id="Sympbuff">pbuff</span>           .eq     $45               ;two byte buffer pointer
<span id="Symblock">block</span>           .eq     $46               ;block dumber
<span id="SymCMDBlockl">CMDBlockl</span>       .eq     $46
<span id="SymCMDSCode">CMDSCode</span>        .eq     $46
<span id="Symlimit">limit</span>           .eq     $46
<span id="SymCMDBlockh">CMDBlockh</span>       .eq     $47
<span id="Sympblock">pblock</span>          .eq     $47               ;block number
<span id="Sympcount">pcount</span>          .eq     $47               ;byte count
<span id="Sympstat">pstat</span>           .eq     $47               ;status / control code
<span id="Symvalue">value</span>           .eq     $47
<span id="SymCMDBlocks">CMDBlocks</span>       .eq     $48
<span id="Symiobpl">iobpl</span>           .eq     $48               ;pointer to IOB
<span id="Symloopcount">loopcount</span>       .eq     $49
<span id="Sympaddr">paddr</span>           .eq     $49               ;address for read
<span id="Symgrp7ctr">grp7ctr</span>         .eq     $4b
<span id="Symrcvbuf">rcvbuf</span>          .eq     $4b
<span id="Symoddbytes">oddbytes</span>        .eq     $4c
<span id="Symbytecount">bytecount</span>       .eq     $4d
<span id="Symbytecountl">bytecountl</span>      .eq     $4d
<span id="Symnext">next</span>            .eq     $4d
<span id="Symstatbyte">statbyte</span>        .eq     $4d
<span id="SymAuxType">AuxType</span>         .eq     $4e
<span id="Symbytecounth">bytecounth</span>      .eq     $4e
<span id="Symnext3">next3</span>           .eq     $4f
<span id="SymDeviceID">DeviceID</span>        .eq     $50
<span id="SymHostID">HostID</span>          .eq     $51
<span id="Symnext6">next6</span>           .eq     $52
<span id="Symnext7">next7</span>           .eq     $53
<span id="Symauxptr">auxptr</span>          .eq     $56
<span id="Symbuffer2">buffer2</span>         .eq     $56
<span id="SymSlot">Slot</span>            .eq     $58
<span id="Symtbodd">tbodd</span>           .eq     $59
<span id="SymUnit">Unit</span>            .eq     $5a
<span id="SymWpacketType">WpacketType</span>     .eq     $5b
<span id="Sympascat">pascat</span>          .eq     $78               ;$DB20-cattbl-1
<span id="Symcmdmark">cmdmark</span>         .eq     $80               ;Command packet identifier
<span id="SymCommReset">CommReset</span>       .eq     $80
<span id="Symdatamark">datamark</span>        .eq     $82               ;Data packet identifier
<span id="Symnameflag">nameflag</span>        .eq     $aa               ;value unused in any catalog
<span id="Sympacketbeg">packetbeg</span>       .eq     $c3               ;Mark at beginning of packet
<span id="Sympacketend">packetend</span>       .eq     $c8               ;End of packet mark
<span id="Symsizeflg">sizeflg</span>         .eq     $fc               ;block size flag
<span id="Symzers">zers</span>            .eq     $fd               ;catalog skip flag
<span id="Symskpfe">skpfe</span>           .eq     $fe               ;skip FE bytes in catalog
<span id="Symrevnum">revnum</span>          .eq     $0101             ;revision 1.0.1
<span id="Syminbuf">inbuf</span>           .eq     $0200             ;Input buffer
<span id="Symnumbanks">numbanks</span>        .eq     $03b8             ;$478-$C0   ;sl.scrn1 ;number of 64K banks on card
<span id="Symsl_scrn2">sl_scrn2</span>        .eq     $0438             ;$4F8-$C0
<span id="SymProFLAG">ProFLAG</span>         .eq     $0473             ;scholes
<span id="Symminl">minl</span>            .eq     $0478
<span id="Symmoutemp">moutemp</span>         .eq     $0478             ; Temporary storage
<span id="Symsizetemp">sizetemp</span>        .eq     $0478             ;holds # blocks
<span id="Symminxl">minxl</span>           .eq     $047d
<span id="Symmouxl">mouxl</span>           .eq     $047f             ;X position low byte
<span id="Sympower2">power2</span>          .eq     $04b8
<span id="SymRetry">Retry</span>           .eq     $04f3             ;scholes+$80
<span id="SymSCRNHOLE1">SCRNHOLE1</span>       .eq     $04f8  {addr/8}   ;text page 1 screen holes
<span id="Symerror">error</span>           .eq     $04f8             ;error flag
<span id="Symmaxl">maxl</span>            .eq     $04f8
<span id="Symaciabuf">aciabuf</span>         .eq     $04fc             ;Owner of serial buffer
<span id="Symmouyl">mouyl</span>           .eq     $04ff             ;Y position low byte
<span id="Symsl_scrn4">sl_scrn4</span>        .eq     $0538             ;$5F8-$C0
<span id="SymRetry2">Retry2</span>          .eq     $0573             ;SHTemp1
<span id="SymSHTemp1">SHTemp1</span>         .eq     $0573             ;scholes+$100
<span id="SymSCRNHOLE2">SCRNHOLE2</span>       .eq     $0578  {addr/8}   ;text page 1 screen holes
<span id="Symminh">minh</span>            .eq     $0578
<span id="Symxval">xval</span>            .eq     $0578             ;value to be returned in X
<span id="Symtwser">twser</span>           .eq     $057c             ;Storage pointer for serial buffer
<span id="Symminxh">minxh</span>           .eq     $057d
<span id="Symmouxh">mouxh</span>           .eq     $057f             ;X position high byte
<span id="SymSCREEN">SCREEN</span>          .eq     $05b8
<span id="SymSHTempX">SHTempX</span>         .eq     $05f3             ;scholes+$180
<span id="SymSCRNHOLE3">SCRNHOLE3</span>       .eq     $05f8  {addr/8}   ;text page 1 screen holes
<span id="Symmaxh">maxh</span>            .eq     $05f8
<span id="Symyval">yval</span>            .eq     $05f8             ;value to be returned in Y
<span id="Symtwkey">twkey</span>           .eq     $05fc             ;Storage pointer for type ahead buffer
<span id="Symcharbuf">charbuf</span>         .eq     $05fe             ;5FE, 67E are one byte character buffers
<span id="Symmouyh">mouyh</span>           .eq     $05ff             ;Y position high byte
<span id="Symeschar">eschar</span>          .eq     $0638             ;Current escape character 6F9 &amp; 6FA
<span id="Symsl_scrn6">sl_scrn6</span>        .eq     $0638             ;$6F8-$C0
<span id="SymSHTempY">SHTempY</span>         .eq     $0673             ;scholes+$200
<span id="SymSCRNHOLE4">SCRNHOLE4</span>       .eq     $0678  {addr/8}   ;text page 1 screen holes
<span id="Symsl_lcstate">sl_lcstate</span>      .eq     $0678             ;language card state
<span id="Symvfactv">vfactv</span>          .eq     $067b
<span id="Symtrser">trser</span>           .eq     $067c             ;Retrieve pointer for serial buffer
<span id="Symmaxxl">maxxl</span>           .eq     $067d
<span id="Symmouarm">mouarm</span>          .eq     $067f             ;Arm interrupts from movement or button
<span id="Sympowerup">powerup</span>         .eq     $06b8             ;$778-$C0 	;sl.scrn7 ;powerup byte 	
<span id="SymSCRNHOLE5">SCRNHOLE5</span>       .eq     $06f8  {addr/8}   ;text page 1 screen holes
<span id="Symtemp">temp</span>            .eq     $06f8             ;Temp storage
<span id="Symtrkey">trkey</span>           .eq     $06ff             ;Retrieve buffer for type ahead buffer
<span id="Symsl_scrn8">sl_scrn8</span>        .eq     $0738             ;$7F8-$C0
<span id="SymSCRNHOLE6">SCRNHOLE6</span>       .eq     $0778  {addr/8}   ;text page 1 screen holes
<span id="Symsl_devno">sl_devno</span>        .eq     $0778             ;slot * 16 ($n0) + $88
<span id="Symmaxxh">maxxh</span>           .eq     $077d
<span id="Symmoustat">moustat</span>         .eq     $077f             ;Mouse status
<span id="Symsl_mslot">sl_mslot</span>        .eq     $07f8             ;$C0 + slot ($Cn)
<span id="Symcursor">cursor</span>          .eq     $07fb
<span id="Symmoumode">moumode</span>         .eq     $07ff             ;Mouse mode
<span id="Symbootbuf">bootbuf</span>         .eq     $0800             ;into $800
<span id="Symthbuf">thbuf</span>           .eq     $0800             ;Buffer in alt ram space
<span id="SymRC1">RC1</span>             .eq     $0bb8             ;Send a command pack 3000 times (3 sec)
<span id="Symdiagstart">diagstart</span>       .eq     $1fff             ;diagtest-1 ;start location of diagnostics
<span id="Symdiagdest">diagdest</span>        .eq     $2000             ;location of diagnostics in ram
<span id="Symdosinit">dosinit</span>         .eq     $9d1e             ;DOS init vector use addr-1
<span id="Symrwts">rwts</span>            .eq     $bd00             ;RWTS entry point
<span id="Symproflag">proflag</span>         .eq     $bf00             ;0 = Pascal, $4C = ProDOS, other = DOS
<span id="Symaddrl">addrl</span>           .eq     $bff8             ;address pointer
<span id="Symsdata">sdata</span>           .eq     $bff8             ;+$N0+$90 is output port
<span id="Symaddrm">addrm</span>           .eq     $bff9             ;auto incs after every data access
<span id="Symsstat">sstat</span>           .eq     $bff9             ;ACIA status register
<span id="Symaddrh">addrh</span>           .eq     $bffa
<span id="Symscmod">scmod</span>           .eq     $bffa
<span id="Symscomd">scomd</span>           .eq     $bffa             ;ACIA command register
<span id="Symdata">data</span>            .eq     $bffb             ;data pointed to
<span id="SymCLR80COL">CLR80COL</span>        .eq     $c000             ;W use $C002-C005 for aux mem (80STOREOFF)
<span id="Symioadr">ioadr</span>           .eq     $c000
<span id="SymKBD">KBD</span>             .eq     $c000             ;R last key pressed + 128
<span id="SymSET80COL">SET80COL</span>        .eq     $c001             ;W use PAGE2 for aux mem (80STOREON)
<span id="SymRDMAINRAM">RDMAINRAM</span>       .eq     $c002             ;W if 80STORE off: read main mem $0200-BFFF
<span id="SymRDCARDRAM">RDCARDRAM</span>       .eq     $c003             ;W if 80STORE off: read aux mem $0200-BFFF
<span id="SymWRMAINRAM">WRMAINRAM</span>       .eq     $c004             ;W if 80STORE off: write main mem $0200-BFFF
<span id="SymWRCARDRAM">WRCARDRAM</span>       .eq     $c005             ;W if 80STORE off: write aux mem $0200-BFFF
<span id="SymSETSTDZP">SETSTDZP</span>        .eq     $c008             ;W use main stack and zero page
<span id="SymSETALTZP">SETALTZP</span>        .eq     $c009             ;W use aux stack and zero page
<span id="SymKBDSTRB">KBDSTRB</span>         .eq     $c010             ;RW keyboard strobe
<span id="SymRDLCBNK2">RDLCBNK2</span>        .eq     $c011             ;R bit 7: reading from LC bank 2 ($Dx)?
<span id="SymRDLCRAM">RDLCRAM</span>         .eq     $c012             ;R bit 7: reading from LC RAM?
<span id="SymRDRAMRD">RDRAMRD</span>         .eq     $c013             ;R bit 7: reading from aux/alt 48K?
<span id="SymRDRAMWRT">RDRAMWRT</span>        .eq     $c014             ;R bit 7: writing to aux/alt 48K?
<span id="Symmouxint">mouxint</span>         .eq     $c015             ;D7 = x interrupt
<span id="Symmouyint">mouyint</span>         .eq     $c017             ;D7 = y interrupt
<span id="SymRD80COL">RD80COL</span>         .eq     $c018             ;R bit 7: 80STORE is on?
<span id="Symrdvblbar">rdvblbar</span>        .eq     $c019
<span id="SymRDVBLBAR">RDVBLBAR</span>        .eq     $c019             ;R bit 7: not VBL (VBL signal is low)?
<span id="SymROMBANK">ROMBANK</span>         .eq     $c028             ;RW ROM bank select (IIc Plus)
<span id="SymSPKR">SPKR</span>            .eq     $c030             ;RW toggle speaker
<span id="Symmouclr">mouclr</span>          .eq     $c048             ;Clear mouse interrupt
<span id="SymTXTCLR">TXTCLR</span>          .eq     $c050             ;RW display graphics
<span id="SymTXTSET">TXTSET</span>          .eq     $c051             ;RW display text
<span id="SymTXTPAGE1">TXTPAGE1</span>        .eq     $c054             ;RW display page 1
<span id="Symiou">iou</span>             .eq     $c058             ;IOU interrupt switches
<span id="SymSETAN3">SETAN3</span>          .eq     $c05e             ;RW annunciator 3 off
<span id="SymBUTN0">BUTN0</span>           .eq     $c061             ;R switch input 0 / open-apple
<span id="SymBUTN1">BUTN1</span>           .eq     $c062             ;R switch input 1 / closed-apple
<span id="Symioudsbl">ioudsbl</span>         .eq     $c078             ;Disable iou access
<span id="Symiouenbl">iouenbl</span>         .eq     $c079             ;Enable iou access
<span id="SymROMIN">ROMIN</span>           .eq     $c081             ;RWx2 read ROM, write RAM bank 2
<span id="SymLCBANK2">LCBANK2</span>         .eq     $c083             ;RWx2 read/write RAM bank 2
<span id="SymLCBANK1">LCBANK1</span>         .eq     $c08b             ;RWx2 read/write RAM bank 1
<span id="Symcomslot">comslot</span>         .eq     $c200
<span id="Symswreset2">swreset2</span>        .eq     $c788             ;NMI and RESET
<span id="Symswirq2">swirq2</span>          .eq     $c78e             ;INT
<span id="Symcmdcr">cmdcr</span>           .eq     $d12f             ;same as cmdn
<span id="Symcmdn">cmdn</span>            .eq     $d12f             ;same as cmdcr
<span id="Symcmdk">cmdk</span>            .eq     $d139             ;same as cmdi and cmdl
<span id="Symcmdl">cmdl</span>            .eq     $d139             ;same as cmdi and cmdk
<span id="Symdiagcode">diagcode</span>        .eq     $dc00             ;location of diagnostic code
<span id="Symclreop">clreop</span>          .eq     $fc42
<span id="Symhome">home</span>            .eq     $fc58
<span id="Symclreol">clreol</span>          .eq     $fc9c
<span id="Symcrout">crout</span>           .eq     $fd8e
<span id="Symprbyte">prbyte</span>          .eq     $fdda
<span id="Symcout">cout</span>            .eq     $fded

                .addrs  $c000
<span id="SymLC000">LC000</span>           .ds     25
<span id="Symvblint">vblint</span>          .ds     65
<span id="Symiou_p_2">iou_p_2</span>         .ds     9
<span id="Symmoubut">moubut</span>          .ds     29
<span id="Symreqclr">reqclr</span>          .ds     1
<span id="Symreqset">reqset</span>          .ds     1
<span id="Symca1clr">ca1clr</span>          .ds     1
<span id="Symcalset">calset</span>          .ds     1
<span id="Symca2clr">ca2clr</span>          .ds     1
<span id="Symca2set">ca2set</span>          .ds     1
<span id="Symlstrbclr">lstrbclr</span>        .ds     1
<span id="Symlstrbset">lstrbset</span>        .ds     1
<span id="Symmonclr">monclr</span>          .ds     1
<span id="Symmonset">monset</span>          .ds     1
<span id="Symenable1">enable1</span>         .ds     1
<span id="Symenable2">enable2</span>         .ds     1
<span id="Syml6clr">l6clr</span>           .ds     1
<span id="Syml6set">l6set</span>           .ds     1
<span id="Syml7clr">l7clr</span>           .ds     1
<span id="Syml7set">l7set</span>           .ds     113
********************************************************************************
*                                                                              *
* Mouse interrupt handler                                                      *
*                                                                              *
* MOUSERINT - Montior's interrupt handler                                      *
*                                                                              *
* Returns C = 0 if interrupt handled                                           *
* If not mouse interrupt, goes to aciaint                                      *
* New in this rom:                                                             *
* If D7 of moumode = 1, mouse X and Y interrupts are not processed             *
* and are passed on to the user.                                               *
*                                                                              *
*                                                                              *
********************************************************************************
mouse_ser_ints
                .addrs  *+$0000
<span id="Symmouseint">mouseint</span>        lda     #$0e              ;Entry point if X &amp; Y set up
                trb     <a href="#Symmoustat">moustat</a>           ;Clear status bits
; 
                sec                       ;Assume interrupt not handled
; Check for vertical blanking interrupt
                lda     <a href="#Symvblint">vblint</a>            ;VBL interrupt?
                bpl     <a href="#Symchkmou">chkmou</a>
                sta     <a href="#Symiouenbl">iouenbl</a>           ;Enable iou access &amp; clear VBL interrupt
                lda     #<a href="#Symvblmode">vblmode</a>          ;Should we leave vbl active?
                bit     <a href="#Symmoumode">moumode</a>
                bne     <a href="#Symcvnovbl">cvnovbl</a>
                sta     <a href="#Symiou_p_2">iou_p_2</a>           ;Disable VBL
<span id="Symcvnovbl">cvnovbl</span>         ora     #<a href="#Symmovmode">movmode</a>
                sta     <a href="#Symioudsbl">ioudsbl</a>
                bit     <a href="#Symmouarm">mouarm</a>            ;VBL bit in arm isn't used
                bne     <a href="#Symcvmoved">cvmoved</a>
                lda     #<a href="#Symvblmode">vblmode</a>          ;Didn't move
<span id="Symcvmoved">cvmoved</span>         bit     <a href="#Symmoubut">moubut</a>            ;Button pressed?
                bpl     <a href="#Symcvbut">cvbut</a>
                eor     #<a href="#Symbutmode">butmode</a>          ;Clear the button bit
<span id="Symcvbut">cvbut</span>           and     <a href="#Symmoumode">moumode</a>           ;Which bits were set in the mode
                tsb     <a href="#Symmoustat">moustat</a>
                trb     <a href="#Symmouarm">mouarm</a>
                adc     #$fe              ;C=1 if int passes to user
; Check &amp; update mouse movement
<span id="Symchkmou">chkmou</span>          lda     <a href="#Symmoumode">moumode</a>           ;If D7 = 1, user better handle it
                bmi     <a href="#Symxmdone">xmdone</a>
                lda     <a href="#Symmouxint">mouxint</a>           ;Mouser interrupt?
                ora     <a href="#Symmouyint">mouyint</a>
                bpl     <a href="#Symxmdone">xmdone</a>            ;If not return with C from vbl
                txa                       ;Get X1 in A
                ldx     #0
                bit     <a href="#Symmouxint">mouxint</a>           ;X movement?
                bmi     <a href="#Symcmxmov">cmxmov</a>
<span id="Symcmloop">cmloop</span>          tya                       ;Get Y1 into A
                eor     #$80              ;Complement direction
                ldx     #$80
                bit     <a href="#Symmouyint">mouyint</a>
                bpl     <a href="#Symcmnoy">cmnoy</a>
<span id="Symcmxmov">cmxmov</span>          asl     A
                lda     <a href="#Symmouxl">mouxl</a>,x           ;A = current low byte
                bcs     <a href="#Symcmrght">cmrght</a>            ;which way?
                cmp     <a href="#Symminxl">minxl</a>,x           ;Move left
                bne     <a href="#Symcmlok">cmlok</a>
                lda     <a href="#Symmouxh">mouxh</a>,x
                cmp     <a href="#Symminxh">minxh</a>,x
                beq     <a href="#Symcmnoint">cmnoint</a>
<span id="Symcmlok">cmlok</span>           lda     <a href="#Symmouxl">mouxl</a>,x
                bne     <a href="#Symcmnt0">cmnt0</a>             ;Borrow from high byte?
                dec     <a href="#Symmouxh">mouxh</a>,x
<span id="Symcmnt0">cmnt0</span>           dec     <a href="#Symmouxl">mouxl</a>,x
                bra     <a href="#Symcmnoint">cmnoint</a>

<span id="Symcmrght">cmrght</span>          cmp     <a href="#Symmaxxl">maxxl</a>,x           ;At high bound?
                bne     <a href="#Symcmrok">cmrok</a>
                lda     <a href="#Symmouxh">mouxh</a>,x
                cmp     <a href="#Symmaxxh">maxxh</a>,x
                beq     <a href="#Symcmnoint">cmnoint</a>
<span id="Symcmrok">cmrok</span>           inc     <a href="#Symmouxl">mouxl</a>,x           ;Move right
                bne     <a href="#Symcmnoint">cmnoint</a>
                inc     <a href="#Symmouxh">mouxh</a>,x
<span id="Symcmnoint">cmnoint</span>         cpx     #0
                beq     <a href="#Symcmloop">cmloop</a>
<span id="Symcmnoy">cmnoy</span>           sta     <a href="#Symmouclr">mouclr</a>
                lda     #<a href="#Symmovmode">movmode</a>          ;Should we enable VBL?
                and     <a href="#Symmoumode">moumode</a>
                beq     <a href="#Symcmnovbl">cmnovbl</a>           ;Branch if not
                sta     <a href="#Symiouenbl">iouenbl</a>
;                       ;iou+3
                sta     <a href="#Symiou_p_2">iou_p_2</a>+1         ;Enable VBL int
                sta     <a href="#Symioudsbl">ioudsbl</a>
<span id="Symcmnovbl">cmnovbl</span>         ora     #<a href="#Symmovarm">movarm</a>           ;Mark that we moved
                tsb     <a href="#Symmouarm">mouarm</a>
                lda     #$0e
                and     <a href="#Symmoustat">moustat</a>
                adc     #$fe              ;C=1 iff any bits were 1
<span id="Symxmdone">xmdone</span>          bcs     <a href="#Symaciaint">aciaint</a>           ;If not handled, try acia
                jmp     <a href="#Symswrts2">swrts2</a>            ;Back we go

;   This routine will determine if the source of
; is either of the built in ACIAs.  If neither port
; generated the interrupt, or the interrupt was due
; to a transmit buffer empty, protocol converter, or
; 'unbuffered' receiver full, the carry is set indi-
; cating an externally serviced interrupt.
;   If the interrupt source was keyboard, 'buffer'
; serial input, or the DCD, the interrupt is serviced
; and the carry is cleared indicating interrupt was
; serviced.  (DCD handshake replaces CTS.)
;   Location "ACIABUF" specifies which (if either) re-
; receiver data is buffered.  For port 1 it must contain
; $C1, for port 2 a $C2.  Any other values are cause
; interrupts to pass to external (RAM based) routines.
;   Location "TYEHED" specifies whether Keyboard in-
; put should be buffered, ignored, or processed by 
; RAM based rountines.  If bit 7=1 and bit 6=0, key-
; board data is placed in the type-ahead buffer.  If
; bit 6 is set the interrupt is cleared, but must
; be recognized and serviced by a RAM routine.  If
; both bits = 0, the interrupt is serviced, but the
; keyboard data is ignored.
;   While used type-ahead, Open-Apple CTRL-X will
; flush the buffer.  No other code is recognized.
;   If the source was an ACIA that has the transmit
; interrupt enabled, the original value of the ACIAs
; status registers is preserved. Automatic serial input
; buffering is not serviced from a port so configured.
; Interrupts originating from the protocol converter or
; keyboard (RAM serviced) do not inhibit serial buffering
; and are passed true.  The RAM service routine can rec-
; ognize the interrupt source by a 1 state in bit 6 of
; the ACIAs status register.  The RAM service routine must
; cause the clearing of DSR (bit 6) AND make a second ac-
; cess to the status register before returning.
; 
; 
<span id="Symnotacia">notacia</span>         sec                       ;Not acia int
<span id="Symacdone">acdone</span>          rts

<span id="Symaciaint">aciaint</span>         jsr     <a href="#Symaciaint2">aciaint2</a>          ;Extra jsr since rest needs RTS
                jmp     <a href="#Symswrts2">swrts2</a>

<span id="Symaciaint2">aciaint2</span>        ldx     #&gt;<a href="#Symcomslot">comslot</a>         ;Test port 2 first
                jsr     <a href="#Symaciatst">aciatst</a>           ;Check for interrupt
                bcc     <a href="#Symacdone">acdone</a>            ;Return if interrupt done
                dex                       ;Try port 1
<span id="Symaciatst">aciatst</span>         ldy     <a href="#Symdevno2">devno2</a>,x          ;Get index for acia
                lda     #4                ;If xmit ints enabled pass to user
                eor     <a href="#Symscomd">scomd</a>,y           ;Check if D&lt;3&gt;, D&lt;2&gt; = 01
                and     #$0c              ; 
                beq     <a href="#Symnotacia">notacia</a>           ;User better take it!
                lda     <a href="#Symsstat">sstat</a>,y           ;Get status
                sta     <a href="#Symsl_scrn2">sl_scrn2</a>,x        ;Save it away
                bpl     <a href="#Symnotacia">notacia</a>           ;No interrupt
<span id="Symaitst2">aitst2</span>          cpx     #&gt;<a href="#Symcomslot">comslot</a>         ;C=1 if com port. Called from serout3
                bcs     <a href="#Symaiport2">aiport2</a>           ;Invert DSR if port1
                eor     #$40
<span id="Symaiport2">aiport2</span>         bit     <a href="#Symsl_scrn4">sl_scrn4</a>,x        ;Is DSR enabled?
                bvs     <a href="#Symaipass">aipass</a>            ;Yes, user wants it
                bpl     <a href="#Symaieatit">aieatit</a>           ;No, eat it
                bcc     <a href="#Symaieatit">aieatit</a>           ;Yes, but I don't want it for port 1
                bit     #$40              ;Is DSR 1?
                beq     <a href="#Symaipass">aipass</a>            ;If not, skip it
; It's a keyboard interrupt
                lda     <a href="#SymKBD">KBD</a>               ;Get the key
                ldy     #$80
                jsr     <a href="#Symputbuf">putbuf</a>            ;Put it in the buffer
                cmp     #$98              ;Is it a ^x?
                bne     <a href="#Symainoflsh">ainoflsh</a>
                lda     <a href="#SymBUTN1">BUTN1</a>             ;And the closed apple?
                bpl     <a href="#Symainoflsh">ainoflsh</a>
                stx     <a href="#Symtwkey">twkey</a>             ;Flush the type ahead buffer
                stx     <a href="#Symtrkey">trkey</a>
<span id="Symainoflsh">ainoflsh</span>        lda     <a href="#SymKBDSTRB">KBDSTRB</a>           ;Clear the keyboard
; * $A0 $B0 table needed by serial firmware
                ldy     #$b0              ;Restore y
                lda     <a href="#Symsstat">sstat</a>,y           ;Read status to clear int
<span id="Symaieatit">aieatit</span>         and     #$bf              ;Clear the DSR bit
<span id="Symaipass">aipass</span>          asl     A                 ;Shift DSR into C
                asl     A
                and     #$20              ;Is the receiver full?
                beq     <a href="#Symaciadone">aciadone</a>          ;If not, we're done
                lda     <a href="#Symscmod">scmod</a>,y           ;Are received interrupts, enabled?
                eor     #1                ;Check for D&lt;1&gt;,D&lt;0&gt; = 01
                and     #3
                bne     <a href="#Symaciadone">aciadone</a>          ;If not, were done
                txa                       ; Is this acia buffered?
                eor     <a href="#Symaciabuf">aciabuf</a>
                bne     <a href="#Symnotacia">notacia</a>           ;The user better handle it!
                php                       ; Save DSR status
                jsr     <a href="#Symgetdata">getdata</a>           ;Get char &amp; check xon, etc
                bcc     <a href="#Symaieat">aieat</a>             ;Don't put in buffer if eaten
                ldy     #0
                .dd1    $d0               ;BNE opcode to skip PHP
<span id="Symputbuf">putbuf</span>          php
                phx
                pha
                lda     <a href="#Symtwser">twser</a>,y           ;Get buffer pointer
                tax                       ; Save it for later
                inc     A                 ;Bump it to next free byte
                bit     #$7f              ;Overflow?
                bne     <a href="#Sympbok">pbok</a>
<span id="SymLC234">LC234</span>           tya                       ; Wrap pointer
<span id="Sympbok">pbok</span>            cmp     <a href="#Symtrser">trser</a>,y           ;Buffer full?
                beq     <a href="#Sympbfull">pbfull</a>
                sta     <a href="#Symtwser">twser</a>,y           ;Save the new pointer
<span id="Sympbfull">pbfull</span>          pla                       ; Get the data
                bit     <a href="#SymRDRAMWRT">RDRAMWRT</a>
                sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ;It goes to aux ram
                sta     <a href="#Symthbuf">thbuf</a>,x
                bmi     <a href="#Symaiaux">aiaux</a>             ;Branch if we want aux
                sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>
<span id="Symaiaux">aiaux</span>           plx
<span id="Symaieat">aieat</span>           plp                       ;Get DSR status back
<span id="Symaciadone">aciadone</span>        rts

********************************************************************************
*                                                                              *
* SEROUT3 - Outputs a character to a acia                                      *
* Inputs: A = char, X = Cn                                                     *
*                                                                              *
********************************************************************************
<span id="Symserout3">serout3</span>         jsr     <a href="#Symserout4">serout4</a>
                jmp     <a href="#Symswrts2">swrts2</a>

;                                       ;Entry point with rts
<span id="Symserout4">serout4</span>         pha                       ; Save the char
                bit     <a href="#Symsorts">sorts</a>             ;Control char?
                beq     <a href="#Symsordy">sordy</a>             ;Don't inc column if so
                inc     <a href="#Symsl_scrn8">sl_scrn8</a>,x
<span id="Symsordy">sordy</span>           jsr     <a href="#Symgetstat2">getstat2</a>          ;Get acia status
                and     #$30              ;Y set by getstat
                cmp     #$10
                bne     <a href="#Symsordy">sordy</a>
                lda     <a href="#Sympowerup">powerup</a>,x         ;Is XON/XOFF enabled?
                bit     #$20
                beq     <a href="#Symsook">sook</a>              ;Branch if not
                cpx     <a href="#Symaciabuf">aciabuf</a>           ;Is port interrupt driven?
                beq     <a href="#Symsotst">sotst</a>
                jsr     <a href="#Symxrdnobuf">xrdnobuf</a>          ;Get a char from the acia
                bcc     <a href="#Symsotst">sotst</a>             ;Branch if no char
                ldy     <a href="#SymLC234">LC234</a>,x           ;Get pointer to charbuf
                sta     <a href="#Symcharbuf">charbuf</a>,y         ;Save the character
                lda     <a href="#Sympowerup">powerup</a>,x         ;Set bit for char in buffer
                ora     #$04
                sta     <a href="#Sympowerup">powerup</a>,x
<span id="Symsotst">sotst</span>           lda     <a href="#Sympowerup">powerup</a>,x         ;Check if in xoff
                and     #$02
                bne     <a href="#Symsordy">sordy</a>             ;Loop if not ready
<span id="Symsook">sook</span>            ldy     <a href="#Symdevno2">devno2</a>,x
                pla
                pha                       ; Get char to XMIT
                sta     <a href="#Symsdata">sdata</a>,y           ;Out it goes
                bit     <a href="#Sympowerup">powerup</a>,x         ;V=1 if LF after CR
                eor     #$0d              ;check for CR.
                asl     A                 ;preserve bit 7
                bne     <a href="#Symsodone">sodone</a>            ;branch if not CR.
                bvc     <a href="#Symclrcol">clrcol</a>            ;branch if no LF after CR
                lda     #$14              ;Get LF*2
                ror     A                 ;no shift in high bit
                jsr     <a href="#Symserout4">serout4</a>           ;Output the LF but don't echo it
<span id="Symclrcol">clrcol</span>          stz     <a href="#Symch">ch</a>                ;0 position &amp; column
                stz     <a href="#Symsl_scrn8">sl_scrn8</a>,x
<span id="Symsodone">sodone</span>          pla                       ;Get the char back
<span id="Symsorts">sorts</span>           rts

********************************************************************************
*                                                                              *
* GETSTAT - Gets the status from a acia                                        *
* GETSTAT2 - Call from this side                                               *
* If interrupt, aciatst is called                                              *
* note: external interrupts are lost                                           *
* inputs: X = Cn                                                               *
* outputs: A = status, X = Cn, Y = devno                                       *
*                                                                              *
********************************************************************************
<span id="Symgetstat">getstat</span>         jsr     <a href="#Symgetstat2">getstat2</a>
                jmp     <a href="#Symswrts2">swrts2</a>            ;Return to other side

<span id="Symgetstat2">getstat2</span>        php                       ; Save interrupt status
                sei
<span id="Symgsttst">gsttst</span>          ldy     <a href="#Symdevno2">devno2</a>,x          ;Get index into hardware
                lda     <a href="#Symsstat">sstat</a>,y           ;Get the status
                bpl     <a href="#Symgstnoint">gstnoint</a>          ;D7 = 1 if interrupt
                jsr     <a href="#Symaitst2">aitst2</a>            ;Go service the interrupt
                bra     <a href="#Symgsttst">gsttst</a>            ;Interrupt may have changed status

<span id="Symgstnoint">gstnoint</span>        plp                       ; Restore interrupt status
                rts

********************************************************************************
* This is the serial input routine. Carry                                      *
* flag set indicates that returned data is                                     *
* valid.                                                                       *
*                                                                              *
********************************************************************************
<span id="Symxrdser">xrdser</span>          jsr     <a href="#Symxrdser2">xrdser2</a>
                jmp     <a href="#Symswrts2">swrts2</a>

<span id="Symxrdser2">xrdser2</span>         cpx     <a href="#Symaciabuf">aciabuf</a>           ;is serial input buffered?
                bne     <a href="#Symxnosbuf">xnosbuf</a>           ;(in english "NO SERIAL BUFFER")
                ldy     #0                ;Y=0 for serial buffer
                jsr     <a href="#Symgetbuf2">getbuf2</a>           ;Any data in buffer?
                bcs     <a href="#Symxrddone">xrddone</a>
; 
<span id="Symxnosbuf">xnosbuf</span>         lda     <a href="#Sympowerup">powerup</a>,x         ;Is there a char in the onr byte buffer?
                bit     #$04
                beq     <a href="#Symxrdnobuf">xrdnobuf</a>          ;Branch if not
                and     #$fb              ;Clear the bit
                sta     <a href="#Sympowerup">powerup</a>,x
                ldy     <a href="#SymLC234">LC234</a>,x
                lda     <a href="#Symcharbuf">charbuf</a>,y
                sec
                rts

<span id="Symxrdnobuf">xrdnobuf</span>        jsr     <a href="#Symgetstat2">getstat2</a>          ;Get ACIA status
                and     #$08
                clc                       ;indicate no data
                beq     <a href="#Symxrddone">xrddone</a>           ;Branch if no data!
                jsr     <a href="#Symgetdata">getdata</a>           ;Get data and check xon, etc.
<span id="Symxrddone">xrddone</span>         rts

                .bulk   $00,$80

********************************************************************************
*                                                                              *
* GETBUF - Gets a byte from the input buffer                                   *
* Inputs: Y=0 for Serial buffer 80 for Keyboard buffer                         *
* C = 0 if no data C = 1 if data valid A = Data                                *
*                                                                              *
********************************************************************************
<span id="Symgetbuf">getbuf</span>          jsr     <a href="#Symgetbuf2">getbuf2</a>
                jmp     <a href="#Symswrts2">swrts2</a>

<span id="Symgetbuf2">getbuf2</span>         lda     <a href="#Symtrser">trser</a>,y           ;Test for data in buffer
                cmp     <a href="#Symtwser">twser</a>,y           ;If = then no data
                clc
                beq     <a href="#Symgbdone">gbdone</a>            ;Branch if empty
                pha                       ;Save current value
                inc     A                 ;Update the pointer
                bit     #$7f              ;Overflow
                bne     <a href="#Symgbnoovr">gbnoovr</a>
                tya
<span id="Symgbnoovr">gbnoovr</span>         sta     <a href="#Symtrser">trser</a>,y           ;Store the updated pointer
                ply                       ;Get the old value of the pointer
                lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;Are we in main ram
                asl     A                 ;C=1 for Aux ram
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;Force Aux ram
                lda     <a href="#Symthbuf">thbuf</a>,y           ;Get byte from buffer
                bcs     <a href="#Symgbdone">gbdone</a>            ;Branch if we were in aux bank
                sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;Set back to main
                sec                       ;Mark data there
<span id="Symgbdone">gbdone</span>          rts

********************************************************************************
*                                                                              *
* GETDATA - Gets data from serial port                                         *
* and checks for LF, XON, XOFF                                                 *
* inputs: Y = index to acia                                                    *
* outputs: A = data, Y dest, C = 1 if data ok = 0 if eaten                     *
*                                                                              *
********************************************************************************
<span id="Symgetdata">getdata</span>         lda     <a href="#Symsdata">sdata</a>,y
                pha                       ;Save the data
                ora     #$80              ;Set D7 for compares
                tay
                lda     <a href="#Sympowerup">powerup</a>,x         ;Get options byte
                bit     #$08              ;Eat linefeeds?
                bne     <a href="#Symgdnolf">gdnolf</a>
                cpy     #<a href="#Symlfeed">lfeed</a>            ;Is it a LF?
                beq     <a href="#Symgdeat">gdeat</a>             ;Eat it if it is
<span id="Symgdnolf">gdnolf</span>          bit     #$20              ;Xon/XOFF enabled?
                beq     <a href="#Symgdok">gdok</a>
                cpy     #<a href="#Symxon">xon</a>              ;Is it an XON?
                bne     <a href="#Symgdnxon">gdnxon</a>
                and     #$fd              ;Clear xoff bit
                bra     <a href="#Symgdeat">gdeat</a>             ;And eat it

<span id="Symgdnxon">gdnxon</span>          cpy     #<a href="#Symxoff">xoff</a>
                bne     <a href="#Symgdok">gdok</a>
                ora     #$02              ;Set xoff bit
<span id="Symgdeat">gdeat</span>           clc
                .dd1    $b0               ;BCS opcode
<span id="Symgdok">gdok</span>            sec
                sta     <a href="#Sympowerup">powerup</a>,x
                pla
                rts
                .adrend ↑ $c100

********************************************************************************
* Name    : MOVEAUX                                                            *
* Function: Perform crossbank memory move                                      *
* Input   : A1 = Source Address                                                *
*         : A2 = Source End                                                    *
*         : A4 = Destination Start                                             *
*         : Carry SET = Main --&gt; Card                                          *
*                 CLR = Card --&gt; Main                                          *
*                                                                              *
* Output  : None                                                               *
* Volatile: Nothing                                                            *
* Calls   : Nothing                                                            *
********************************************************************************
aux_ram_support
                .addrs  *+$0000
<span id="Symmoveaux">moveaux</span>         pha                       ;SAVE AC
                lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;SAVE STATE OF
                pha                       ; MEMORY FLAGS
                lda     <a href="#SymRDRAMWRT">RDRAMWRT</a>
                pha
; 
; Set Flags for Crossbank Move:
; 
                bcc     <a href="#Symmovec2m">movec2m</a>           ;=&gt;CARD--&gt;MAIN
                sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;SET FOR MAIN
                sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ; TO CARD
                bcs     <a href="#Symmoveloop">moveloop</a>          ;=&gt; (ALWAYS TAKEN)

<span id="Symmovec2m">movec2m</span>         sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>         ;SET FOR CARD
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ; TO MAIN
; MOVESTRT
<span id="Symmoveloop">moveloop</span>        lda     (<a href="#SymA1L">A1L</a>)             ;get a byte
                sta     (<a href="#SymA4L">A4L</a>)             ;move it
                inc     <a href="#SymA4L">A4L</a>
                bne     <a href="#Symnexta1">nexta1</a>
                inc     <a href="#SymA4H">A4H</a>
<span id="Symnexta1">nexta1</span>          lda     <a href="#SymA1L">A1L</a>
                cmp     <a href="#SymA2L">A2L</a>
                lda     <a href="#SymA1H">A1H</a>
                sbc     <a href="#SymA2H">A2H</a>
                inc     <a href="#SymA1L">A1L</a>
                bne     <a href="#Symco1">co1</a>
                inc     <a href="#SymA1H">A1H</a>
<span id="Symco1">co1</span>             bcc     <a href="#Symmoveloop">moveloop</a>          ;=&gt;more to move
; 
                sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>         ;CLEAR FLAG2
                pla                       ;GET ORIGINAL STATE
                bpl     <a href="#Symco3">co3</a>               ;=&gt;IT WAS OFF
                sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>
<span id="Symco3">co3</span>             sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;CLEAR FLAG1
                pla                       ;GET ORIGINAL STATE
                bpl     <a href="#Symmoveret">moveret</a>           ;=&gt;IT WAS OFF
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>
<span id="Symmoveret">moveret</span>         pla                       ;Restore AC
                jmp     <a href="#Symswrts2">swrts2</a>

********************************************************************************
* NAME    : XFER                                                               *
* FUNCTION: TRANSFER CONTROL CROSSBANK                                         *
* INPUT   : $03ED=TRANSFER ADDR                                                *
*         : CARRY SET=XFER TO CARD                                             *
*                 CLR=XFER TO MAIN                                             *
*         : VFLAG CLR=USE STD ZP/STK                                           *
*         :       SET=USE ALT ZP/STK                                           *
* OUTPUT  : NONE                                                               *
* VOLATILE: $03ED/03EE IN DEST BANK                                            *
* CALLS   : NOTHING                                                            *
* NOTE    : ENTERED VIA JMP, NOT JSR                                           *
********************************************************************************
<span id="SymXFER">XFER</span>            pha                       ;SAVE AC ON CURRENT STACK
; 
; COPY DESTINATION ADDRESS TO THE
;  OTHER BANK SO THAT WE HAVE IT
;  IN CASE WE DO A SWAP:
; 
                lda     $03ed             ;GET XFERADDR LO
                pha                       ;SAVE ON CURRENT STACK
                lda     $03ee             ;GET XFERADDR HI
                pha                       ;SAVE IT TOO
; 
; SWITCH TO APPROPRIATE BANK:
; 
                bcc     <a href="#SymXFERC2M">XFERC2M</a>           ;=&gt;CARD--&gt;MAIN
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;SET FOR RUNNING
                sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ; IN CARD RAM
                bcs     <a href="#SymXFERZP">XFERZP</a>            ;=&gt; always taken

<span id="SymXFERC2M">XFERC2M</span>         sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;SET FOR RUNNING
                sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>         ; IN MAIN RAM
; 
;                                       ;SWITCH TO ALT ZP/STK
<span id="SymXFERZP">XFERZP</span>          pla                       ;STUFF XFERADDR
                sta     $03ee             ; HI AND
                pla
                sta     $03ed             ;   LO
                pla                       ;RESTORE AC
                bvs     <a href="#SymXFERAZP">XFERAZP</a>           ;=&gt;switch in alternate zp
                sta     <a href="#SymSETSTDZP">SETSTDZP</a>          ;else force standard zp
                bvc     <a href="#SymJMPDEST">JMPDEST</a>           ;=&gt;always perform transfer

<span id="SymXFERAZP">XFERAZP</span>         sta     <a href="#SymSETALTZP">SETALTZP</a>          ;switch in alternate zp
<span id="SymJMPDEST">JMPDEST</span>         jmp     <a href="#SymSWXFGO2">SWXFGO2</a>           ;Back we go
                .adrend ↑ $c34e

********************************************************************************
* banger                                                                       *
*                                                                              *
* Here is the rest of the diagnostic stuff                                     *
* the first part has been moved into the $D000 space                           *
* to make desperately needed room                                              *
*                                                                              *
********************************************************************************
banger_diags
                .addrs  *+$0000
<span id="SymTSTMEM">TSTMEM</span>          stx     $01
                stx     $02
                stx     $03
                ldx     #4                ;do RAM $100-$FFFF five times
                stx     $04
<span id="SymMEM1">MEM1</span>            sta     $05               ;keep acc in a safe place
                ldx     #4
                stz     $01
                inc     1                 ;point to page 1 first
<span id="Symmem2">mem2</span>            tay                       ;save ACC in Y for now
                sta     <a href="#SymLCBANK2">LCBANK2</a>           ;anticipate not $C000 range...
                sta     <a href="#SymLCBANK2">LCBANK2</a>
                lda     $01               ;get page address
                and     #$f0              ;test for $C0-$CF range
                cmp     #$c0
                bne     <a href="#Symmem3">mem3</a>              ;branch if not...
                lda     <a href="#SymLCBANK1">LCBANK1</a>
                lda     <a href="#SymLCBANK1">LCBANK1</a>           ;select primary $D000 space
                lda     $01
                adc     #$0f              ;Plus carry =+$10
                bne     <a href="#Symmem4">mem4</a>              ;branch always taken
<span id="Symmem3">mem3</span>            lda     $01
<span id="Symmem4">mem4</span>            sta     $03
                tya                       ;restore pattern to ACC
                ldy     #$00              ;fill this page with the pattern
<span id="Symmem5">mem5</span>            clc
                adc     <a href="#Symntbl">ntbl</a>,x
                sta     ($02),y
                dex                       ;keep x in the range 0-4
                bpl     <a href="#Symmem6">mem6</a>
                ldx     #4
<span id="Symmem6">mem6</span>            iny                       ;all 256 filled yet?
                bne     <a href="#Symmem5">mem5</a>              ;branch if not
                inc     1                 ;bump page #
                bne     <a href="#Symmem2">mem2</a>              ;loop through $0100 to $FF00
; 
                inc     $01               ;point to page 1 again
                ldx     #4
                lda     $05
<span id="Symmem7">mem7</span>            tay                       ;save ACC in Y for now
                lda     <a href="#SymLCBANK2">LCBANK2</a>           ;anticipate not $C000 range...
                lda     <a href="#SymLCBANK2">LCBANK2</a>
                lda     $01               ;get page address
                and     #$f0              ;test for $C0-$CF range
                cmp     #$c0
                bne     <a href="#Symmem8">mem8</a>              ;branch if not...
                lda     <a href="#SymLCBANK1">LCBANK1</a>           ;select primary $D000 space
                lda     $01
                adc     #$0f              ;Plus carry =+$10
                bne     <a href="#Symmem9">mem9</a>              ;branch always taken
<span id="Symmem8">mem8</span>            lda     $01
<span id="Symmem9">mem9</span>            sta     $03
                tya                       ;restore pattern to ACC
                ldy     #$00              ;fill this page with the pattern
<span id="SymmemA">memA</span>            clc
                adc     <a href="#Symntbl">ntbl</a>,x
                eor     ($02),y
                bne     <a href="#SymMEMERROR">MEMERROR</a>          ;if any bits are different, give up!!!
                lda     ($02),y           ;restore correct pattern
                dex                       ;keep x in range 0-4
                bpl     <a href="#SymmemB">memB</a>
                ldx     #4
<span id="SymmemB">memB</span>            iny                       ;all 256 filled yet?
                bne     <a href="#SymmemA">memA</a>              ;branch if not
                inc     1                 ;bump page #
                bne     <a href="#Symmem7">mem7</a>              ;loop through $0100 to $FF00
                ror     A                 ;change ACC for next pass
                bit     <a href="#SymRDVBLBAR">RDVBLBAR</a>          ; use RDVBL for a little randomness...
                bpl     <a href="#SymmemC">memC</a>
                eor     #$a5
<span id="SymmemC">memC</span>            dec     $04               ;have 5 passes been done yet?
                bmi     <a href="#SymmemD">memD</a>              ;skip if yes
                jmp     <a href="#SymMEM1">MEM1</a>              ;start next pass

<span id="SymmemD">memD</span>            tax                       ;save acc
                bit     <a href="#SymRDRAMRD">RDRAMRD</a>           ;main or aux ram ?
                bmi     <a href="#SymMEMF">MEMF</a>              ;skip if aux ram
                txa
                sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ;enable aux mem write
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;enable aux mem read
                sta     <a href="#SymSETALTZP">SETALTZP</a>          ;swap in alt zero page
                sta     <a href="#SymROMIN">ROMIN</a>             ;Force rom enable
                jmp     <a href="#SymTSTZPG">TSTZPG</a>            ; and test it!

<span id="SymMEMF">MEMF</span>            sta     <a href="#SymSETSTDZP">SETSTDZP</a>          ;swap in main zero page
                jmp     <a href="#SymSWCHTST">SWCHTST</a>

<span id="SymMEMERROR">MEMERROR</span>        sec                       ;indicate main ram failure
<span id="SymBADBITS">BADBITS</span>         tax                       ;save bit battern in x for now
                lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;main or aux mem?
                clv                       ;with V-FLG
                bpl     <a href="#Symbbits1">bbits1</a>            ;branch if primary bank
                bit     <a href="#Symsetv">setv</a>
<span id="Symbbits1">bbits1</span>          lda     #$a0              ;try to clear video screen
                ldy     #$06
<span id="Symclrsts">clrsts</span>          sta     <a href="#Symioadr">ioadr</a>-2,y
                sta     <a href="#Symioadr">ioadr</a>+6,y
                dey
                dey
                bne     <a href="#Symclrsts">clrsts</a>
                sta     <a href="#SymTXTSET">TXTSET</a>
                sta     <a href="#SymTXTPAGE1">TXTPAGE1</a>
<span id="Symclrs">clrs</span>            sta     $0400,y
                sta     $0500,y
                sta     $0600,y
                sta     $0700,y
                iny
                bne     <a href="#Symclrs">clrs</a>
                txa                       ;test for switch test failure
                beq     <a href="#SymBADSWTCH">BADSWTCH</a>          ;branch if it was a switch
                ldy     #3
                bcs     <a href="#Symbadmain">badmain</a>           ;branch if ZP ok
                ldy     #5
<span id="Symbadmain">badmain</span>         lda     #$aa              ;mark aux report with an asterisks
                bvc     <a href="#Symbadprim">badprim</a>
                sta     <a href="#SymSCREEN">SCREEN</a>-8
<span id="Symbadprim">badprim</span>         lda     <a href="#Symrmess">rmess</a>,y
                sta     <a href="#SymSCREEN">SCREEN</a>-7,y
                dey
                bpl     <a href="#Symbadprim">badprim</a>           ;message is either "RAM" or "RAM ZP"
                ldy     #$10              ;print bits
<span id="Symbbits2">bbits2</span>          txa
                lsr     A
                tax
                lda     #$58              ;bits are printed as ascii 0 or 1
                rol     A
                sta     <a href="#SymSCREEN">SCREEN</a>-2,y
                dey
                dey
                bne     <a href="#Symbbits2">bbits2</a>
<span id="Symhangx">hangx</span>           beq     <a href="#Symhangx">hangx</a>             ;hang forever and ever

<span id="SymBADSWTCH">BADSWTCH</span>        ldx     #2
                ply
                php
<span id="Symbswtch1">bswtch1</span>         lda     <a href="#Symsmess">smess</a>,x           ;anticipate MMU error
                plp
                php
                bcc     <a href="#Symbswtch2">bswtch2</a>           ;branch if not IOU error
                lda     <a href="#Symsmess">smess</a>+3,x         ;anticipate IOU error
<span id="Symbswtch2">bswtch2</span>         cpy     #6                ;compare with where we left off
                bcc     <a href="#Symbswtch3">bswtch3</a>           ;skip if MMU
                cpy     #8
                bcc     <a href="#Symbswtch2a">bswtch2a</a>          ;skip if GLU (ioudis or dhires failure)
                cpy     #$11
                bcc     <a href="#Symbswtch3">bswtch3</a>           ;skip if IOU
<span id="Symbswtch2a">bswtch2a</span>        lda     <a href="#Symsmess">smess</a>+6,x         ;GLU error (ioudis failure)
<span id="Symbswtch3">bswtch3</span>         sta     <a href="#SymSCREEN">SCREEN</a>,x
                dex
                bpl     <a href="#Symbswtch1">bswtch1</a>           ;print "MMU","IOU" or "GLU"
<span id="Symhangy">hangy</span>           bmi     <a href="#Symhangy">hangy</a>             ;branch forever

<span id="SymSWCHTST">SWCHTST</span>         ldy     #<a href="#SymMMUIDX">MMUIDX</a>           ;MMUIDX
<span id="Symswtst1">swtst1</span>          lda     #$7f
<span id="Symswtst2">swtst2</span>          ror     A                 ;set IOU/MMU switches to match A
                ldx     <a href="#SymSWTBL0">SWTBL0</a>,y
                beq     <a href="#Symswtst4">swtst4</a>            ;branch if done setting switches
                bcc     <a href="#Symswtst3">swtst3</a>            ;branch if setting switch to 0-state
                ldx     <a href="#SymSWTBL1">SWTBL1</a>,y          ;else get index to set switch to 1
<span id="Symswtst3">swtst3</span>          sta     <a href="#Symioadr">ioadr</a>-1,x         ;set switch
                iny
                bne     <a href="#Symswtst2">swtst2</a>            ;branch always taken...
; 
<span id="Symclick">click</span>           ldx     <a href="#SymSPKR">SPKR</a>
                rol     A
<span id="Symswtst4">swtst4</span>          dey
                ldx     <a href="#SymRSWTBL">RSWTBL</a>,y          ;now verify the settings just made
                beq     <a href="#Symswtst6">swtst6</a>            ;branch if done this pass
                bmi     <a href="#Symclick">click</a>             ;branch if this switch no to be verified.
                rol     A
                bcc     <a href="#Symswtst5">swtst5</a>
                asl     <a href="#Symioadr">ioadr</a>,x
                bcc     <a href="#Symswerr">swerr</a>
                bcs     <a href="#Symswtst4">swtst4</a>            ;branch always

<span id="Symswtst5">swtst5</span>          asl     <a href="#Symioadr">ioadr</a>,x
                bcs     <a href="#Symswerr">swerr</a>
                bcc     <a href="#Symswtst4">swtst4</a>            ;branch always

<span id="Symswtst6">swtst6</span>          rol     A                 ;restore original value
                iny                       ; and IOU/MMU index
<span id="SymLC523">LC523</span>           sec
                sbc     #1                ;try next pattern
                bcs     <a href="#Symswtst2">swtst2</a>
                dey                       ;was MMU just tested?
                beq     <a href="#Symswtst7">swtst7</a>            ;yes, go to IOU
                cpy     #<a href="#SymIOUIDX">IOUIDX</a>-1         ;was IOU just tested?
                bne     <a href="#SymBIGLOOP">BIGLOOP</a>           ;no, go loop again
                ldy     #<a href="#SymGLUIDX">GLUIDX</a>           ;yes, go test IOUDIS switch
                bne     <a href="#Symswtst1">swtst1</a>            ;branch always

<span id="Symswtst7">swtst7</span>          ldy     #<a href="#SymIOUIDX">IOUIDX</a>
                bne     <a href="#Symswtst1">swtst1</a>            ;branch always

<span id="Symswerr">swerr</span>           phy                       ;save y to distinguish from MMU or GLU
;                                       ;failure
                ldx     #0                ;indicate switch error
                cpy     #<a href="#SymIOUIDX">IOUIDX</a>+1         ;set carry if IOU was cause
                jmp     <a href="#Symbbits1">bbits1</a>

<span id="SymBIGLOOP">BIGLOOP</span>         lsr     $80
                bne     <a href="#SymSWCHTST">SWCHTST</a>
<span id="Symblp2">blp2</span>            lda     #$a0
                ldy     #0
<span id="Symblp3">blp3</span>            sta     $0400,y           ;clear screen for susccess message
                sta     $0500,y
                sta     $0600,y
                sta     $0700,y
                iny
                bne     <a href="#Symblp3">blp3</a>
<span id="Symblp4">blp4</span>            lda     <a href="#SymBUTN0">BUTN0</a>             ;test for both Open and Closed Apple
                and     <a href="#SymBUTN1">BUTN1</a>             ; pressed
                asl     A                 ;put result in carry
                inc     $ff
                lda     $ff
                bcc     <a href="#Symdquit">dquit</a>
                jmp     <a href="#Symdiags">diags</a>

<span id="Symdquit">dquit</span>           lda     <a href="#SymTXTSET">TXTSET</a>            ;put success message on the screen
                ldy     #8
<span id="Symsuc2">suc2</span>            lda     <a href="#Symsuccess">success</a>,y
                sta     <a href="#SymSCREEN">SCREEN</a>,y
                dey
                bpl     <a href="#Symsuc2">suc2</a>
                bmi     <a href="#Symblp4">blp4</a>              ;loop forever

                .fill   10,$00

********************************************************************************
* PREAD - Reads bytes from card into the Apple                                 *
* D7 of the address = 1 if aux ram                                             *
********************************************************************************
<span id="Symsl_pread">sl_pread</span>        phx
                ldx     <a href="#Symsl_lcstate">sl_lcstate</a>
                inc     $c000,x
                plx
                lda     <a href="#Sympaddr">paddr</a>
                sta     <a href="#Symaddrl">addrl</a>,x
                lda     <a href="#Sympaddr">paddr</a>+1
                sta     <a href="#Symaddrm">addrm</a>,x
                lda     <a href="#Sympaddr">paddr</a>+2
                and     #$7f
                cmp     <a href="#Symnumbanks">numbanks</a>,y
                bcs     <a href="#Symprbad">prbad</a>
                sta     <a href="#Symaddrh">addrh</a>,x
                bit     <a href="#SymRDRAMWRT">RDRAMWRT</a>
                php
                sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>
                bit     <a href="#Sympaddr">paddr</a>+2
                bpl     <a href="#Symprmain">prmain</a>
                sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>
<span id="Symprmain">prmain</span>          ldy     #0
                lda     <a href="#Sympcount">pcount</a>+1
                sta     <a href="#Symyval">yval</a>
                beq     <a href="#Symprlast">prlast</a>
<span id="Symprloop">prloop</span>          lda     <a href="#Symdata">data</a>,x
                sta     (<a href="#Symcompdata">compdata</a>),y
                iny
                lda     <a href="#Symdata">data</a>,x
                sta     (<a href="#Symcompdata">compdata</a>),y
                iny
                bne     <a href="#Symprloop">prloop</a>
                inc     <a href="#Sympbuff">pbuff</a>+1
                dec     <a href="#Sympcount">pcount</a>+1
                bne     <a href="#Symprloop">prloop</a>
<span id="Symprlast">prlast</span>          lda     <a href="#Sympcount">pcount</a>
                beq     <a href="#Symprdone">prdone</a>
                sta     <a href="#Symxval">xval</a>
                lsr     A
                bcs     <a href="#Symprodd">prodd</a>
<span id="Symprloop2">prloop2</span>         lda     <a href="#Symdata">data</a>,x
                sta     (<a href="#Symcompdata">compdata</a>),y
                iny
<span id="Symprodd">prodd</span>           lda     <a href="#Symdata">data</a>,x
                sta     (<a href="#Symcompdata">compdata</a>),y
                iny
                cpy     <a href="#Sympcount">pcount</a>
                bne     <a href="#Symprloop2">prloop2</a>
<span id="Symprdone">prdone</span>          sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>
                plp
                bpl     <a href="#Symprmain2">prmain2</a>
                sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>
<span id="Symprmain2">prmain2</span>         bra     <a href="#Symprbadz">prbadz</a>

<span id="Symprbad">prbad</span>           lda     #<a href="#Symbadblk">badblk</a>           ;Invalid address
                sta     <a href="#Symerror">error</a>
<span id="Symprbadz">prbadz</span>          sta     <a href="#SymROMIN">ROMIN</a>             ;put the rom back in
                rts

********************************************************************************
* PWRITE - Writes bytes from Apple to card                                     *
* D7 of the address = 1 if aux ram                                             *
********************************************************************************
<span id="Symsl_pwrite">sl_pwrite</span>       phx                       ;save x
                ldx     <a href="#Symsl_lcstate">sl_lcstate</a>        ;get language card state
                inc     $c000,x           ;restore it, the rom is ayway
                plx                       ;restore x
; 
                lda     <a href="#Sympaddr">paddr</a>             ;Move the address
                sta     <a href="#Symaddrl">addrl</a>,x
                lda     <a href="#Sympaddr">paddr</a>+1
                sta     <a href="#Symaddrm">addrm</a>,x
                lda     <a href="#Sympaddr">paddr</a>+2
                and     #$7f              ;Mask off high bit
                cmp     <a href="#Symnumbanks">numbanks</a>,y        ;Valid address
                bcs     <a href="#Symprbad">prbad</a>
                sta     <a href="#Symaddrh">addrh</a>,x
                bit     <a href="#SymRDRAMRD">RDRAMRD</a>           ;Save current back
                php
                sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;Assume main
                bit     <a href="#Sympaddr">paddr</a>+2           ;If D7 = 1 then aux
                bpl     <a href="#Sympwmain">pwmain</a>
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;Its the card ram
<span id="Sympwmain">pwmain</span>          ldy     #0
                lda     <a href="#Sympcount">pcount</a>+1          ;More than a page to move?
                sta     <a href="#Symyval">yval</a>
                beq     <a href="#Sympwlast">pwlast</a>
<span id="Sympwloop">pwloop</span>          lda     (<a href="#Symcompdata">compdata</a>),y      ;Get a byte
                sta     <a href="#Symdata">data</a>,x
                iny
                lda     (<a href="#Symcompdata">compdata</a>),y
                sta     <a href="#Symdata">data</a>,x
                iny
                bne     <a href="#Sympwloop">pwloop</a>
                inc     <a href="#Sympbuff">pbuff</a>+1           ;Bump buffer pointer to next page
                dec     <a href="#Sympcount">pcount</a>+1          ;Dec page count
                bne     <a href="#Sympwloop">pwloop</a>
<span id="Sympwlast">pwlast</span>          lda     <a href="#Sympcount">pcount</a>            ;Any bytes left to do?
                sta     <a href="#Symxval">xval</a>
                beq     <a href="#Sympwdone">pwdone</a>
                lsr     A                 ;C = 1 if odd # of bytes
                bcs     <a href="#Sympwodd">pwodd</a>
<span id="Sympwloop2">pwloop2</span>         lda     (<a href="#Symcompdata">compdata</a>),y
                sta     <a href="#Symdata">data</a>,x
                iny
<span id="Sympwodd">pwodd</span>           lda     (<a href="#Symcompdata">compdata</a>),y
                sta     <a href="#Symdata">data</a>,x
                iny
                cpy     <a href="#Sympcount">pcount</a>
                bne     <a href="#Sympwloop2">pwloop2</a>
<span id="Sympwdone">pwdone</span>          sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;Fix main / aux ram
                plp
                bpl     <a href="#Sympwmain2">pwmain2</a>
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>
<span id="Sympwmain2">pwmain2</span>         sta     <a href="#SymROMIN">ROMIN</a>             ;put the rom back in
                rts

; ****************************************
; * Various data tables
; ****************************************
; 
; Status info table
<span id="Symstattbl">stattbl</span>         .dd1    $f8               ;Status byte
                .bulk   $00,$00,$00       ;Size
                .dd1    7                 ;Name length
                .str    “RAMCARD”
                .str    “         ”
                .dd2    0                 ;Type subtype
                .dd2    <a href="#Symrevnum">revnum</a>            ;Version
; 
<span id="Symparmtbl">parmtbl</span>         .bulk   $03,$03,$03       ;Table of parameters
                .bulk   $03,$03,$03
                .bulk   $01,$01,$03
                .bulk   $03,$01,$01
                .bulk   $01,$01,$01
                .bulk   $01,$04,$04
                .bulk   $04,$04,$ff
                .bulk   $ff,$ff,$ff
                .bulk   $ff,$ff
; 
;                        ;Table of command addresses
<span id="Symcmdtbl">cmdtbl</span>          .dd1    &lt;<a href="#Sympstat0">pstat0</a>-1         ;Status unit 0
                .dd1    &lt;<a href="#Symsl_pstatus">sl_pstatus</a>-1     ;Status
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Read block unit 0
                .dd1    &lt;<a href="#Symprdblk">prdblk</a>-1         ;Read block
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Write block unit 0
                .dd1    &lt;<a href="#Sympwrblk">pwrblk</a>-1         ;Write block
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Format unit 0
                .dd1    &lt;<a href="#Symiorts">iorts</a>-1          ;Format
                .dd1    &lt;<a href="#Sympcntl">pcntl</a>-1          ;Control Unit 0
                .dd1    &lt;<a href="#Sympcntl">pcntl</a>-1          ;Control
                .dd1    &lt;<a href="#Symiorts">iorts</a>-1          ;Init unit 0
                .dd1    &lt;<a href="#Symiorts">iorts</a>-1          ;Init
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Open unit 0
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Open
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Close until 0
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Close
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Read until 0
                .dd1    &lt;<a href="#Sympread2_z">pread2_z</a>-1       ;Read
                .dd1    &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Write unit 0
                .dd1    &lt;<a href="#Sympwrite2">pwrite2</a>-1        ;Write
                .dd1    &lt;<a href="#Symxstatus">xstatus</a>-1        ;ProDOS status call
                .dd1    &lt;<a href="#Symxread">xread</a>-1          ;ProDOS read call
                .dd1    &lt;<a href="#Symxwrite">xwrite</a>-1         ;ProDOS write call
                .dd1    &lt;<a href="#Symiorts">iorts</a>-1          ;ProDOS format call
                .dd1    &lt;<a href="#Symdosconv2">dosconv2</a>-1       ;Dos Command
                .dd1    &lt;<a href="#Symxdiag">xdiag</a>-1          ;Diagnostics !

<span id="SymswsL_bt">swsL_bt</span>         phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language state
                phy                       ;save it
                sty     <a href="#Symsl_lcstate">sl_lcstate</a>        ;save it here too
                jsr     <a href="#Symbool_sl">bool_sl</a>           ;do the boot
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

<span id="Symsw_setmou">sw_setmou</span>       phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                jsr     <a href="#Symx_setmou">x_setmou</a>          ;set the mouse mode to a
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

<span id="Symsw_mtstint">sw_mtstint</span>      phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                jsr     <a href="#Symx_mtstint">x_mtstint</a>         ;check mouse status bits
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

<span id="Symsw_mread">sw_mread</span>        phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                jsr     <a href="#Symx_mread">x_mread</a>           ;updates the mouse screen holes
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

<span id="Symsw_mclear">sw_mclear</span>       phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                jsr     <a href="#Symx_mclear">x_mclear</a>          ;sets the mouse to 0,0
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

<span id="Symsw_mclamp">sw_mclamp</span>       phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                jsr     <a href="#Symx_mclamp">x_mclamp</a>          ;store new mouse bounds
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

<span id="Symsw_mhome">sw_mhome</span>        phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                jsr     <a href="#Symx_mhome">x_mhome</a>           ;clear mouse position and status
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

<span id="Symsw_initmouse">sw_initmouse</span>    phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                jsr     <a href="#Symi_nitmouse">i_nitmouse</a>        ;reset the mouse
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

                .fill   13,$00

********************************************************************************
* the following code had better start at $C71C or else                         *
********************************************************************************
                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symsw_setmou">sw_setmou</a>         ;do the real thing

                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symsw_mtstint">sw_mtstint</a>        ;do the real thing

                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symsw_mread">sw_mread</a>          ;do the real thing

                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symsw_mclear">sw_mclear</a>         ;do the real thing

                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symsw_mclamp">sw_mclamp</a>         ;do the real thing

                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symsw_mhome">sw_mhome</a>          ;do the real thing

                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symsw_initmouse">sw_initmouse</a>      ;do the real thing

<span id="Symm__oveirq">m__oveirq</span>       sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#Symm_oveirq">m_oveirq</a>

                sta     <a href="#SymROMBANK">ROMBANK</a>
                jmp     <a href="#SymswsL_bt">swsL_bt</a>

                sta     <a href="#SymROMBANK">ROMBANK</a>
                phx                       ;save x
                jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
                phy                       ;save it
                sty     <a href="#Symsl_lcstate">sl_lcstate</a>        ;save it here too
                jsr     <a href="#Symexecute">execute</a>           ;do something with slinky
                jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

                .fill   29,$00
********************************************************************************
*                                                                              *
* Switching Routines                                                           *
*                                                                              *
* jl notes: This section is left undecoded because it jumps to places in Main  *
* Bank, which is not in this list. See separate decode project for the jump    *
* tables of the Main and Aux ROM.                                              *
*                                                                              *
********************************************************************************
bank_swp_table
                .addrs  *+$0000
                .bulk   $8d,$28,$c0,$40
<span id="Symswrts2">swrts2</span>          .bulk   $8d,$28,$c0,$60,$8d,$28,$c0,$4c,$62,$fa,$8d,$28,$c0,$2c,$87,$c7
                .bulk   $4c,$04,$c8
<span id="Symswsthk2">swsthk2</span>         .bulk   $8d,$28,$c0,$4c,$80,$c8
<span id="Symswzzqt2">swzzqt2</span>         .bulk   $8d,$28,$c0,$4c,$00,$d4,$8d,$28,$c0,$4c,$f1,$c7,$8d,$28,$c0,$4c
                .bulk   $06,$c8,$8d,$28,$c0,$4c,$4e,$c3,$8d,$28,$c0,$4c,$97,$c3,$8d,$28
                .bulk   $c0,$4c,$00,$c1,$8d,$28,$c0,$4c,$8e,$d4,$8d,$28,$c0,$4c,$80,$c5
                .bulk   $8d,$28,$c0,$4c,$4f,$c2,$8d,$28,$c0,$4c,$ac,$c2,$8d,$28,$c0,$4c
                .bulk   $c3,$c2,$8d,$28,$c0,$4c,$f7,$c2,$8d,$28,$c0,$4c,$c5,$d4
<span id="SymSWXFGO2">SWXFGO2</span>         .bulk   $8d,$28,$c0,$6c,$ed,$03,$da,$20,$16,$c8,$5a,$20,$a0,$d1,$80,$13
                .adrend ↑ $c780

                .fill   8,$00
                .dd1    $4c
                .dd1    $8e
                .dd1    $c7
                .dd1    $da
                .dd1    $20
                .dd1    $16
                .dd1    $c8
                .dd1    $5a
                .dd1    $20
                .dd1    $00
                .dd1    $d0

<span id="Symfixlc">fixlc</span>           plx
                inc     <a href="#SymLC000">LC000</a>,x
                plx
                jmp     <a href="#Symswrts2">swrts2</a>

********************************************************************************
* GETLC - Gets language card state in Y                                        *
********************************************************************************
<span id="Symgetlc">getlc</span>           ldy     #$81
                bit     <a href="#SymRDLCRAM">RDLCRAM</a>           ;Language card enabled?
                bpl     <a href="#Symglcdone">glcdone</a>
                ldy     #$8b
                bit     <a href="#SymRDLCBNK2">RDLCBNK2</a>          ;Bank 2?
                bpl     <a href="#Symglcbnk1">glcbnk1</a>
                ldy     #$83              ;Bank 1!
<span id="Symglcbnk1">glcbnk1</span>         sta     <a href="#SymROMIN">ROMIN</a>
<span id="Symglcdone">glcdone</span>         rts

<span id="Symntbl">ntbl</span>            .bulk   $53,$43,$2b,$29,$07 ;83,67,43,41,7
<span id="SymSWTBL0">SWTBL0</span>          .bulk   $00,$89,$03,$05,$09,$01,$7f,$5f
                .bulk   $00,$83,$51,$53,$55,$57,$0f,$0d,$00,$80
<span id="SymSWTBL1">SWTBL1</span>          .bulk   $00,$81,$04,$06,$0a,$02,$7f,$60
                .bulk   $00,$84,$52,$54,$56,$58,$10,$0e,$00,$7f
<span id="SymRSWTBL">RSWTBL</span>          .bulk   $00,$11,$13,$14,$16,$18,$ff,$7f
                .bulk   $00,$12,$1a,$1b,$1c,$1d,$1e,$1f,$00,$7e,$00
<span id="Symrmess">rmess</span>           .str    ↑“RAM ZP”
<span id="Symsmess">smess</span>           .str    ↑“MMUIOUGLU”
; 
; 
<span id="Symsuccess">success</span>         .str    ↑“System OK”
                .dd2    $0000
********************************************************************************
* The //c bank switch jumps here for pcnv (protocol converter)                 *
********************************************************************************
<span id="Sympcnv">pcnv</span>            .dd1    $4c
                .dd1    $4c
                .dd1    $cd

****************************************************************
*                                                              *
* SendOnePack                   Send a CBUS Packet             *
*                                                              *
*   This routine sends a packet of data across the             *
* bus.  The protocol is as follows:                            *
*              ___________________________                     *
*  REQ _______|2                         5|___________         *
*         _______________________________                      *
* /BSY___|1              3              4|____________         *
*                                                              *
*    1)  Device signals ready for data                         *
*    2)  Host signals data iminent                             *
*    3)  Packet is transmitted (sync, command mark,            *
*         ids, contents, checksum [msb=1])                     *
*    4)  Device signals packet received                        *
*    5)  Host finishes send data cycle                         *
*                                                              *
*    The bytes are sent in slow mode (32 cycles/byte)          *
*  and the timing is critical.  Branches which should          *
*  not cross page boundaries are marked.                       *
*                                                              *
*                                                              *
*   Input:  buffer (2 bytes) &lt;- ptr to data to send            *
*           bytecount (2)    &lt;- length (bytes) of data         *
*           packettype (1)   &lt;- command or data packet         *
*           CMDUnit (1)      &lt;- # of device to receive         *
*                                                              *
*  Output: carry set- handshake error                          *
*                clr- bytes sent                               *
*                                                              *
****************************************************************
<span id="SymSendOnePack">SendOnePack</span>     jsr     <a href="#SymWritePrep">WritePrep</a>         ;Does a bunch of stuff
; 
; Enable PC chain.
; 
                jsr     <a href="#Symenablechain">enablechain</a>       ;This set X reg
                ldy     #<a href="#Symiwmmode">iwmmode</a>          ;This is the mode value
                jsr     <a href="#SymSetIWMode">SetIWMode</a>         ;Don't mess unless we gotta
; 
; Turn on the IWM
; 
                lda     <a href="#Symenable2">enable2</a>,x         ;Don't disturb //c internal drive
                lda     <a href="#Symmonset">monset</a>,x
; 
; Loop until the chain becomes unbusy
; 
                ldy     #$32              ;Each loop is 11 microseconds
<span id="Symubsy1">ubsy1</span>           lda     <a href="#Syml7clr">l7clr</a>,x           ;Test if /BSY is hi or low
                bmi     <a href="#Symchainunbsy">chainunbsy</a>        ;If hi, busy is not busy
                dey
                bne     <a href="#Symubsy1">ubsy1</a>             ;Keep trying
                sec
                jmp     <a href="#Symsd10">sd10</a>

; 
; Tell the bus that data is coming and send the sync bytes
;   Sync is groups of eight 2's separated by a 6 (micS cell)
;   (111111110011111111001111111100 ...)
; 
<span id="Symchainunbsy">chainunbsy</span>      lda     <a href="#Symreqset">reqset</a>,x          ;Raise REQ
; 
                ldy     #$05              ;Sync plus packet begin
; 
                lda     #$ff              ;Send out the 1st byte sync
                sta     <a href="#Syml7set">l7set</a>,x
; 
<span id="Symssb">ssb</span>             lda     <a href="#Sympreamble">preamble</a>,y
; 
; 
<span id="Symssd">ssd</span>             asl     <a href="#Syml6clr">l6clr</a>,x           ;Wait 'til buffer empty
                bcc     <a href="#Symssd">ssd</a>
; 
                sta     <a href="#Syml6set">l6set</a>,x
                dey
                bpl     <a href="#Symssb">ssb</a>               ;Back for more bytes
; 
; Send over the desination ID
; 
                lda     <a href="#SymUnit">Unit</a>
                ora     #$80              ;Make the device ID
                jsr     <a href="#Symsendbyte">sendbyte</a>
; 
; Send the source ID (that's us... we're an $80)
; 
                jsr     <a href="#Symsend80">send80</a>
; 
; Send over the packet type (command or data)
; 
                lda     <a href="#SymWpacketType">WpacketType</a>
                jsr     <a href="#Symsendbyte">sendbyte</a>
; 
; Send the Auxilliary Type byte (an $80 from this rev PC)
; 
                jsr     <a href="#Symsend80">send80</a>
; 
; Send the status byte (null for us), and length bytes
; 
                jsr     <a href="#Symsend80">send80</a>
                lda     <a href="#Symoddbytes">oddbytes</a>
                ora     #$80
                jsr     <a href="#Symsendbyte">sendbyte</a>
                lda     <a href="#Symgrp7ctr">grp7ctr</a>
                ora     #$80
                jsr     <a href="#Symsendbyte">sendbyte</a>
; 
; Now send the "oddbytes" part of the packet contents
; 
                lda     <a href="#Symoddbytes">oddbytes</a>          ;Get # of "odd" bytes
                beq     <a href="#Symsob2">sob2</a>              ;Skip if no odd bytes
; 
                ldy     #$ff
                lda     <a href="#Symtbodd">tbodd</a>             ;Get the odd bytes msb's (A[7]=1)
; 
<span id="Symsob1">sob1</span>            asl     <a href="#Syml6clr">l6clr</a>,x           ;Do a write handshake
                bcc     <a href="#Symsob1">sob1</a>
                sta     <a href="#Syml6set">l6set</a>,x
                iny
                lda     ($54),y           ;Get the data byte
                ora     #$80              ;Flip on the hi bit
                cpy     <a href="#Symoddbytes">oddbytes</a>          ;Are we done?
                bcc     <a href="#Symsob1">sob1</a>
; 
; Now send over the groups of seven contents
; Currently assume there must be at least one group of 'em
; 
<span id="Symsob2">sob2</span>            lda     <a href="#Symgrp7ctr">grp7ctr</a>           ;Check if there are groups to send
                bne     <a href="#Symsob3">sob3</a>              ;=&gt; At least one group
                jmp     <a href="#Symdatdone">datdone</a>           ;Skip to send checksum

<span id="Symsob3">sob3</span>            nop                       ;Waste 2 cycles
                ldy     #$00
<span id="Symstart">start</span>           lda     <a href="#Symtopbits">topbits</a>
                sta     <a href="#Syml6set">l6set</a>,x
; 
; Send first byte
; 
                lda     <a href="#Symbytecount">bytecount</a>
                ora     #$80
                sty     &lt;<a href="#Symtemp">temp</a>-159         ;Swap Y for short handshake
<span id="Symachel">achel</span>           ldy     <a href="#Syml6clr">l6clr</a>,x           ;Wait 'til buffer ready
                bpl     <a href="#Symachel">achel</a>
                sta     <a href="#Syml6set">l6set</a>,x           ;Send the byte
                ldy     &lt;<a href="#Symtemp">temp</a>-159         ;Get back Y
; 
; Prep the next "1st" byte for next time
; 
                lda     (<a href="#Symauxptr">auxptr</a>),y
                sta     <a href="#Symbytecount">bytecount</a>
                asl     A
                rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
                iny                       ;Next Byte
; 
; It's possible that we're at a page boundary now. If so, bump the
;  hi order part of the pointer.
; 
                bne     <a href="#Symskip1">skip1</a>
                inc     <a href="#Symbuffer2">buffer2</a>+1
                jmp     <a href="#Symskip2">skip2</a>

<span id="Symskip1">skip1</span>           pha                       ;Equalize the cases
                pla
; 
; Push us ahead by an additional 8 cycles for margin reasons
;  Plus I gotta get the topbits MSB set somehow...
; 
<span id="Symskip2">skip2</span>           lda     #%00000010        ;Flip what will be MSB
                ora     <a href="#Symtopbits">topbits</a>
                sta     <a href="#Symtopbits">topbits</a>
; 
; Send the second byte
; 
                lda     <a href="#SymAuxType">AuxType</a>
                ora     #$80
                sta     <a href="#Syml6set">l6set</a>,x           ;Send the byte
                lda     (<a href="#Symauxptr">auxptr</a>),y
                sta     <a href="#SymAuxType">AuxType</a>
                asl     A
                rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
                iny                       ;Next byte
; 
; Send the third byte
; 
                lda     <a href="#Symnext3">next3</a>
                ora     #$80
                sta     <a href="#Syml6set">l6set</a>,x           ;Send the byte
                lda     (<a href="#Symauxptr">auxptr</a>),y
                sta     <a href="#Symnext3">next3</a>
                asl     A
                rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
                iny                       ;Next byte
; 
; Send the fourth byte
; 
                lda     <a href="#SymDeviceID">DeviceID</a>
                ora     #$80
                sta     <a href="#Syml6set">l6set</a>,x           ;Send the byte
                lda     (<a href="#Symauxptr">auxptr</a>),y
                sta     <a href="#SymDeviceID">DeviceID</a>
                asl     A
                rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
                iny                       ;next byte
; 
; After the first 256 bytes, we will cross pages here.  If we did
;  cross, bump the buffer pointer. If not, equalize the cases with
;  seven cycles of time wasting.
; 
                bne     <a href="#Symskip3">skip3</a>
                inc     <a href="#Symbuffer2">buffer2</a>+1
                jmp     <a href="#Symskip4">skip4</a>

<span id="Symskip3">skip3</span>           pha
                pla
; 
; Send the fifth byte
; 
<span id="Symskip4">skip4</span>           lda     <a href="#SymHostID">HostID</a>
                ora     #$80
                sta     <a href="#Syml6set">l6set</a>,x           ;Send the byte
                lda     (<a href="#Symauxptr">auxptr</a>),y
                sta     <a href="#SymHostID">HostID</a>
                asl     A
                rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
                iny                       ;Next byte
; 
; Send the sixth byte
; 
                lda     <a href="#Symnext6">next6</a>
                ora     #$80
                sta     <a href="#Syml6set">l6set</a>,x           ;Send the byte
                lda     (<a href="#Symauxptr">auxptr</a>),y
                sta     <a href="#Symnext6">next6</a>
                asl     A
                rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
                iny                       ;Next byte
; 
; Send the last byte of the group
; 
                lda     <a href="#Symnext7">next7</a>
                ora     #$80
                sta     <a href="#Syml6set">l6set</a>,x           ;Send the byte
                lda     (<a href="#Symauxptr">auxptr</a>),y
                sta     <a href="#Symnext7">next7</a>
                asl     A
                rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
                iny                       ;Next byte
; 
; Now see if we have sent enough groups of seven
; 
                dec     <a href="#Symgrp7ctr">grp7ctr</a>
                beq     <a href="#Symdatdone">datdone</a>
; 
; Otherwise, back to do more.  Note it's too far for a branch.
; 
                jmp     <a href="#Symstart">start</a>

; 
; Whew! Now send the dman checksum as two FM bytes
; 
<span id="Symdatdone">datdone</span>         lda     <a href="#Symchecksum">checksum</a>          ;c7 c6 c5 c4 c3 c2 c1 c0
                ora     #$aa              ; 1 c6  1 c4  1 c2  1 c0
<span id="Symscm1">scm1</span>            ldy     <a href="#Syml6clr">l6clr</a>,x
                bpl     <a href="#Symscm1">scm1</a>              ;Handshake this byte
                sta     <a href="#Syml6set">l6set</a>,x           ;These are even bits
                lda     <a href="#Symbushog">bushog</a>            ;c7 c6 c5 c4 c3 c2 c1 c0
                lsr     A                 ; 0 c7 c6 c5 c4 c3 c2 c1
                ora     #$aa              ; 1 c7  1 c5  1 c3  1 c1
                jsr     <a href="#Symsendbyte">sendbyte</a>
; 
; Send the end of packet mark
; 
                lda     #<a href="#Sympacketend">packetend</a>
                jsr     <a href="#Symsendbyte">sendbyte</a>
; 
; Wait until write underflow
; 
<span id="Symsd7">sd7</span>             lda     <a href="#Syml6clr">l6clr</a>,x
                and     #$40
                bne     <a href="#Symsd7">sd7</a>               ;Still writing data
; 
                sta     <a href="#Syml6set">l6set</a>,x           ;Back to sense mode (dummy write)
; 
; Now wait until the drive acknowledges reciept of the
;  string or until timeout
; 
; 
                ldy     #<a href="#Symbsyto2">bsyto2</a>           ;Load timeout to see bsy low
<span id="Sympatch1">patch1</span>          dey                       ;A little closer to an error
                bne     <a href="#Symsd9">sd9</a>               ;There's still time
; 
; Too much time has elapsed.  Drive didn't get string.
; 
                lda     #<a href="#Symnoanswer">noanswer</a>         ;Report error in comm error byte
<span id="Symdberror">dberror</span>         jsr     <a href="#SymSetXN0">SetXN0</a>            ;For dberror entry
                sec                       ;Signal a problem
                bcs     <a href="#Symsd10">sd10</a>

; 
; See if drive has acknowledged the bytes yet
; 
<span id="Symsd9">sd9</span>             lda     <a href="#Syml7clr">l7clr</a>,x           ;Wait 'til /BSY lo
                bmi     <a href="#Sympatch1">patch1</a>
; 
; Finish the sequence
; 
                clc                       ;This is a normal exit
<span id="Symsd10">sd10</span>            lda     <a href="#Symreqclr">reqclr</a>,x          ;Set REQ lo
                lda     <a href="#Syml6clr">l6clr</a>,x           ;Back into read me
; 
; Pull back the bytecount in all cases
; 
                rts

; 
; 
; This table, when went in reverse order, provides a
;   sync pattern used to synchronize the drive IWM with
;   the data stream.  The firstr byte (last sent) is the 
;   packet begin mark.
; 
<span id="Sympreamble">preamble</span>        .dd1    $c3
<span id="Symsynctab">synctab</span>         .dd1    $ff
                .dd1    $fc
                .dd1    $f3
                .dd1    $cf
                .dd1    $3f

; 
; 
; 
; These routines are for wasting specific amounts of time
;  This code segment should not cross page boundaries.
; 
<span id="Symwaste32">waste32</span>         jsr     <a href="#Symwaste14">waste14</a>
<span id="Symwaste18">waste18</span>         nop
<span id="Symwaste16">waste16</span>         nop
<span id="Symwaste14">waste14</span>         nop
<span id="Symwaste12">waste12</span>         rts

<span id="Symmarkerr">markerr</span>         jmp     <a href="#Symdberror">dberror</a>

********************************************************************************
*                                                                              *
* ReceivePack          Get a packet from bus resident                          *
*                                                                              *
*              ___________________________                                     *
*  REQ _______|2                         5|___________                         *
*         _______________________________                                      *
* /BSY___|1              3              4|____________                         *
*                                                                              *
*    1)  Drive signals ready to send packet                                    *
*    2)  Host signals ready to receive data                                    *
*    3)  Packet is transmitted (sync, mark, IDs, data,                         *
*         checksum [msb=1])                                                    *
*    4)  Drive signals packet dispatched                                       *
*    5)  Host acknowledges reciept of packet                                   *
*                                                                              *
*     The bytes are sent in slow mode (32 cycles/byte)                         *
*   and the timing is critical.  Branches which should                         *
*   not cross page boundaries are marked.                                      *
*                                                                              *
*   Input:  buffer &lt;- address where packet guts left                           *
*                                                                              *
*  Output: carry set- handshake error                                          *
*                clr- bytes sent                                               *
*          A &lt;- error0 if carry set                                            *
*                                                                              *
********************************************************************************
<span id="SymReceivePack">ReceivePack</span>     lda     #$00              ;Init the checksum
                sta     <a href="#Symbushog">bushog</a>
; 
; Copy over buffer -&gt; buffer2
; 
                lda     $54
                sta     <a href="#Symauxptr">auxptr</a>
                lda     <a href="#Symbuffer">buffer</a>+17
                sta     <a href="#Symbuffer2">buffer2</a>+1
; 
; Set up the indirect pointer for jump to 2nd part of code
; 
                jsr     <a href="#Symenablechain">enablechain</a>       ;SetX register to $N0
; 
                lda     <a href="#Syml6set">l6set</a>,x           ;Prep for sense mode
; 
; Now wait for BSY to go hi, signalling 'ready w/ status'
; 
<span id="Symrdh1">rdh1</span>            lda     <a href="#Syml7clr">l7clr</a>,x           ;Read sense
                bpl     <a href="#Symrdh1">rdh1</a>              ;Wait til a high
; 
; Signal Liron we're ready to receive
; 
                lda     <a href="#Symreqset">reqset</a>,x          ;Raise /REQ
; 
; Wait for a byte from Liorn or timeout
; 
                ldy     #<a href="#Symstatmto">statmto</a>          ;Max bytes 'til stat mark
<span id="Symrdh2">rdh2</span>            lda     <a href="#Syml6clr">l6clr</a>,x
                bpl     <a href="#Symrdh2">rdh2</a>              ;*** No Page Cros ***
                dey
                bmi     <a href="#Symmarkerr">markerr</a>           ;Didn't find a packet in time
; 
; Is it the beginning of the packeT?
; 
                cmp     #<a href="#Sympacketbeg">packetbeg</a>        ;Find the packet begin mark
                bne     <a href="#Symrdh2">rdh2</a>              ;Back again - no timeout for now
; 
; Okay load up the table with this stuff
; 
<span id="Symrdh5">rdh5</span>            ldy     #6                ;Seven bytes of overhead
<span id="Symrdh3">rdh3</span>            lda     <a href="#Syml6clr">l6clr</a>,x           ;If byte ready, grab it
                bpl     <a href="#Symrdh3">rdh3</a>              ;*** No Page Cross ***
                and     #%01111111        ;Strip start bit
                sta     <a href="#Symrcvbuf">rcvbuf</a>,y
                eor     #$80              ;Pop MSB back on for checksum
                eor     <a href="#Symbushog">bushog</a>
                sta     <a href="#Symbushog">bushog</a>
                dey
                bpl     <a href="#Symrdh3">rdh3</a>
; 
; Set groups of seven buffer pointer buffer2
; 
                lda     <a href="#Symoddbytes">oddbytes</a>
                beq     <a href="#Symstart2">start2</a>            ;Skip alteration if no oddbytes
                clc
                adc     $54
                sta     <a href="#Symbuffer2">buffer2</a>
                lda     <a href="#Symbuffer">buffer</a>+17
                adc     #0
                sta     <a href="#Symbuffer2">buffer2</a>+1
; 
                ldy     #0
; 
; Now receive the odd bytes
; 
<span id="Symstart0">start0</span>          lda     <a href="#Syml6clr">l6clr</a>,x           ;Read in the odd bytes topbits
                bpl     <a href="#Symstart0">start0</a>
                asl     A                 ;Pop off the start bit
                sta     <a href="#Symtopbits">topbits</a>
; 
<span id="Symstart1">start1</span>          lda     <a href="#Syml6clr">l6clr</a>,x           ;Get an odd byte
                bpl     <a href="#Symstart1">start1</a>
                asl     <a href="#Symtopbits">topbits</a>           ;Get an MSB
                bcs     <a href="#Symgob1">gob1</a>              ;If MSB set, leave start bit
                eor     #$80              ;MSB Clear- flip start bit
<span id="Symgob1">gob1</span>            sta     ($54),y           ;Squirrel it away
                iny                       ;Next spot
                cpy     <a href="#Symoddbytes">oddbytes</a>          ;Are we done?
                bcc     <a href="#Symstart1">start1</a>            ;If more, branch
<span id="Symstart2">start2</span>          jmp     <a href="#SymSlotDepRd">SlotDepRd</a>

<span id="Symsend80">send80</span>          lda     #$80
<span id="Symsendbyte">sendbyte</span>        ldy     <a href="#Syml6clr">l6clr</a>,x
                bpl     <a href="#Symsendbyte">sendbyte</a>
                sta     <a href="#Syml6set">l6set</a>,x
                eor     <a href="#Symbushog">bushog</a>
                sta     <a href="#Symbushog">bushog</a>
                rts

; 
; 
; 
; 
<span id="Symresetchain">resetchain</span>      jsr     <a href="#SymClrPhases">ClrPhases</a>
                lda     <a href="#Symreqset">reqset</a>,x
                lda     <a href="#Symca2set">ca2set</a>,x
                ldy     #80               ;Hard reset for 80 ms
                jsr     <a href="#SymYMSWait">YMSWait</a>
; 
                jsr     <a href="#SymClrPhases">ClrPhases</a>
; 
                ldy     #10               ;About 10 mS reset time!
; 
<span id="SymYMSWait">YMSWait</span>         jsr     <a href="#SymOneMS">OneMS</a>
                dey
                bne     <a href="#SymYMSWait">YMSWait</a>
                rts

<span id="SymOneMS">OneMS</span>           ldx     #200
<span id="Symonems1">onems1</span>          dex
                bne     <a href="#Symonems1">onems1</a>
                rts

; 
<span id="Symenablechain">enablechain</span>     jsr     <a href="#SymSetXN0">SetXN0</a>
                lda     <a href="#Symcalset">calset</a>,x
                lda     <a href="#Symlstrbset">lstrbset</a>,x
                rts

; 
<span id="SymClrPhases">ClrPhases</span>       jsr     <a href="#SymSetXN0">SetXN0</a>
                lda     <a href="#Symreqclr">reqclr</a>,x
                lda     <a href="#Symca1clr">ca1clr</a>,x
                lda     <a href="#Symca2clr">ca2clr</a>,x
                lda     <a href="#Symlstrbclr">lstrbclr</a>,x
                rts

; 
<span id="SymSetXN0">SetXN0</span>          ldx     #$60
                rts

; 
; Shgift tables for use when reading.  Each table should not
;  straddle pages.
; 
<span id="Symshift1">shift1</span>          .bulk   $80,$80,$80,$80,$80,$80,$80,$80
                .bulk   $00,$00,$00,$00,$00,$00,$00,$00
<span id="Symshift2">shift2</span>          .bulk   $80,$80,$80,$80,$00,$00,$00,$00
                .bulk   $80,$80,$80,$80,$00,$00,$00,$00
<span id="Symshift3">shift3</span>          .bulk   $80,$80,$00,$00,$80,$80,$00,$00
                .bulk   $80,$80,$00,$00,$80,$80,$00,$00
<span id="Symshift4">shift4</span>          .bulk   $80,$00,$80,$00,$80,$00,$80,$00
                .bulk   $80,$00,$80,$00,$80,$00,$80,$00

; 
<span id="SymSendData">SendData</span>        lda     #(&gt;<a href="#SymRC2">RC2</a>)+5
                ldy     #<a href="#SymRC2">RC2</a>-5
                jsr     <a href="#SymSendPile">SendPile</a>
                bcc     <a href="#Symsdoubt">sdoubt</a>
                lda     #<a href="#SymCommReset">CommReset</a>
                jsr     <a href="#SymAssignID">AssignID</a>
<span id="Symsdoubt">sdoubt</span>          rts

; 
<span id="SymSendPack">SendPack</span>        jsr     <a href="#SymSendPile">SendPile</a>          ;Try to send a pack
                bcc     <a href="#Symsdoubt">sdoubt</a>
                lda     #<a href="#SymCommReset">CommReset</a>        ;This is a communications failure
                jsr     <a href="#SymAssignID">AssignID</a>
; 
                lda     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;Get back the packetlength
                sta     <a href="#Symbytecountl">bytecountl</a>
                lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>
                sta     <a href="#Symbytecounth">bytecounth</a>
; 
<span id="SymSendPile">SendPile</span>        lda     #(&gt;<a href="#SymRC1">RC1</a>)+173       ;Return count (big!)
                ldy     #&lt;<a href="#SymRC1">RC1</a>-173
; 
<span id="SymAltSendPile">AltSendPile</span>     ldx     <a href="#SymSlot">Slot</a>
                sta     <a href="#SymRetry">Retry</a>,x
                tya
                sta     <a href="#SymRetry2">Retry2</a>,x
; 
; SendPack destroys the bytecount
; 
<span id="Symspile1">spile1</span>          lda     <a href="#Symbytecountl">bytecountl</a>
                sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>
                lda     <a href="#Symbytecounth">bytecounth</a>
                sta     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>
; 
                jsr     <a href="#SymSendOnePack">SendOnePack</a>       ;Send the packet
; 
                lda     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>
                sta     <a href="#Symbytecountl">bytecountl</a>
                lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>
                sta     <a href="#Symbytecounth">bytecounth</a>
; 
                bcc     <a href="#Symspilout">spilout</a>
                ldx     <a href="#SymSlot">Slot</a>
                dec     <a href="#SymRetry">Retry</a>,x
                bne     <a href="#Symspile1">spile1</a>
                dec     <a href="#SymRetry2">Retry2</a>,x
                bpl     <a href="#Symspile1">spile1</a>            ;If all fails, carry is set
<span id="Symspilout">spilout</span>         rts

<span id="SymRecPack">RecPack</span>         ldy     <a href="#SymSlot">Slot</a>
                lda     #(&gt;<a href="#SymRC2">RC2</a>)+5
                sta     <a href="#SymRetry">Retry</a>,y
; 
<span id="Symrpk1">rpk1</span>            jsr     <a href="#SymReceivePack">ReceivePack</a>
                bcc     <a href="#Symrpout">rpout</a>
                ldy     #1
                jsr     <a href="#SymYMSWait">YMSWait</a>
                jsr     <a href="#Symdberror">dberror</a>           ;Recycle handshake and set carry
                ldx     <a href="#SymSlot">Slot</a>
                dec     <a href="#SymRetry">Retry</a>,x
                bne     <a href="#Symrpk1">rpk1</a>              ;Carry set still
<span id="Symrpout">rpout</span>           rts

********************************************************************************
*                                                                              *
* Divide7               Do DIV and MOD 7 and set auxptr                        *
*  This routine divides the bytecount by seven.  The                           *
*   quotient gives the number of groups of seven bytes to                      *
*   be sent, and the remainder gives the number of "odd"                       *
*   bytes.                                                                     *
*                                                                              *
*   Input:  bytecountl,h &lt;- # of bytes to write                                *
*           buffer       &lt;- pointer to data                                    *
*   Output: auxptr       &lt;- pointer to speed up csumming                       *
*           oddbytes     &lt;- bytecount MOD 7                                    *
*           grp7ctr      &lt;- bytecount DIV 7                                    *
*                                                                              *
********************************************************************************
<span id="Sympdiv7tab">pdiv7tab</span>        .bulk   $00,$24,$49
<span id="Sympmod7tab">pmod7tab</span>        .bulk   $00,$04,$01
<span id="Symdiv7tab">div7tab</span>         .bulk   $00,$01,$02,$04,$09,$12
<span id="Symmod7tab">mod7tab</span>         .bulk   $00,$01,$02,$04,$01,$02
; 
<span id="Symauxptrinc">auxptrinc</span>       .bulk   $00,$7f,$ff

; 
; Set up auxptr &lt;- buffer+$80   if $0FF &lt; bytecount &lt; $200
;     or auxptr &lt;- buffer+$100  if $1FF &lt; bytecount
; 
; aka Divide7
<span id="SymWritePrep">WritePrep</span>       ldx     <a href="#Symbytecounth">bytecounth</a>        ;0, 1 or 2
                beq     <a href="#Symnoauxptr">noauxptr</a>          ;Auxptr used only for full pages
; 
                lda     <a href="#Symbuffer">buffer</a>+17
                sta     <a href="#Symauxptr">auxptr</a>+1          ;Copy over hi order part
; 
                lda     #$80              ;Anticipate smaller bytecount
                cpx     #1                ;Check bytecount
                beq     <a href="#Symsap1">sap1</a>              ;=&gt; $0FF &lt; bytecount &lt; $200
; 
                inc     <a href="#Symauxptr">auxptr</a>+1          ;Add $100 to bytecount instead
                lda     #0                ;Make sure lo order unaltered
<span id="Symsap1">sap1</span>            clc
                adc     $54
                sta     <a href="#Symauxptr">auxptr</a>
                bcc     <a href="#Symnoauxptr">noauxptr</a>          ;skip if no carry
                inc     <a href="#Symauxptr">auxptr</a>+1          ;don't forget me
; 
; Now look up the first order guess for DIV and MOD.  X still has
;  bytecount DIV 256.
; 
<span id="Symnoauxptr">noauxptr</span>        lda     <a href="#Sympdiv7tab">pdiv7tab</a>,x
                sta     <a href="#Symgrp7ctr">grp7ctr</a>
                lda     <a href="#Sympmod7tab">pmod7tab</a>,x
                sta     <a href="#Symoddbytes">oddbytes</a>
; 
; Now add in the mods and divs for each of the five hi order
;  bits in the lo order bytecount, correcting each time MOD becomes
;  bigger than 6.
; 
                ldx     #5                ;Do for five bits
                lda     <a href="#Symbytecountl">bytecountl</a>
                sta     &lt;<a href="#Symtemp">temp</a>-159         ;Store lo order for shifting
                and     #%00000111        ;Save lo three for later
                tay
; 
<span id="Symdivide3">divide3</span>         asl     &lt;<a href="#Symtemp">temp</a>-159         ;C &lt;- next from bytecountl
                bcc     <a href="#Symdivide2">divide2</a>           ;If clear, no effect on DIV,MOD
                lda     <a href="#Symmod7tab">mod7tab</a>,x         ;Get MOD7 for 2^n
; 
<span id="Symdivide4">divide4</span>         clc
                adc     <a href="#Symoddbytes">oddbytes</a>          ;Got new MOD value
                cmp     #7                ;Is it too big?
                bcc     <a href="#Symdivide1">divide1</a>
                sbc     #7                ;Bring MOD under 7 - C still set
; 
<span id="Symdivide1">divide1</span>         sta     <a href="#Symoddbytes">oddbytes</a>
                lda     <a href="#Symdiv7tab">div7tab</a>,x         ;Get DIV for this 2^n
                adc     <a href="#Symgrp7ctr">grp7ctr</a>           ;Add to DIV along with correction (C)
                sta     <a href="#Symgrp7ctr">grp7ctr</a>           ;Update the DIV
; 
<span id="Symdivide2">divide2</span>         dex                       ;One less bit to deal with
                bmi     <a href="#Symdivide5">divide5</a>           ;Escape after 6 times through loop
                bne     <a href="#Symdivide3">divide3</a>           ;Take brnch 1st 5 loops
; 
                tya                       ;Get back the last three bits
                jmp     <a href="#Symdivide4">divide4</a>           ;Sixth pass add in remains

********************************************************************************
*                                                                              *
*  PreCheck                    Does the checksumming prepass                   *
*                                                                              *
*    Input:  bytecount   &lt;- bytes in buffer                                    *
*            buffer      &lt;- pointer to data to send                            *
*            auxptr      &lt;- extra pointer to speed process                     *
*   Output:  checksum    &lt;- 8 bit XOR of data to be sent                       *
*                                                                              *
********************************************************************************
<span id="Symdivide5">divide5</span>         lda     <a href="#Symbuffer">buffer</a>+17         ;Checksum any full pages
                pha                       ;Preserve buffer pointer
                lda     #0
                ldx     <a href="#Symbytecounth">bytecounth</a>
                beq     <a href="#Symlastpass">lastpass</a>          ;If no complete pages, skip this
; 
<span id="Symxor2">xor2</span>            ldy     <a href="#Symauxptrinc">auxptrinc</a>,x       ;Get number of bytes each ptr
; 
<span id="Symxor1">xor1</span>            eor     ($54),y
                eor     (<a href="#Symauxptr">auxptr</a>),y
                dey                       ;One less
                bne     <a href="#Symxor1">xor1</a>
                eor     ($54),y
                eor     (<a href="#Symauxptr">auxptr</a>),y        ;Have to deal with 0 case
; 
; Now move the buffer up for next section
; 
                cpx     #1
                beq     <a href="#Symxor5">xor5</a>              ;If 256 and up bytes, bump x1
                inc     <a href="#Symbuffer">buffer</a>+17         ; otherwise x2
<span id="Symxor5">xor5</span>            inc     <a href="#Symbuffer">buffer</a>+17
; 
; Do the remaining less than a page with a single pointer
; 
<span id="Symlastpass">lastpass</span>        ldy     <a href="#Symbytecount">bytecount</a>
                beq     <a href="#Symxor4">xor4</a>
                eor     ($54),y           ;Compensate for nth byte
<span id="Symxor3">xor3</span>            eor     ($54),y
                dey
                bne     <a href="#Symxor3">xor3</a>
                eor     ($54),y           ;Last damn (0th) byte
; 
; Store result away.  Retrieve old buffer value.
; 
<span id="Symxor4">xor4</span>            sta     <a href="#Symbushog">bushog</a>
                pla
                sta     <a href="#Symbuffer">buffer</a>+17
********************************************************************************
*                                                                              *
*  DetTopBits                    Get topbits for odd bytes                     *
*                                                                              *
*    Also sets buffer2 pointer to pointer at groups of                         *
* seven bytes.                                                                 *
*                                                                              *
*    Input:  oddbytes &lt;- # of "odd" bytes                                      *
*            buffer   &lt;- pointer to data                                       *
*   Output:  tbodd    &lt;- topbits for odd bytes                                 *
*            buffer2  &lt;- buffer+oddbytes                                       *
*                                                                              *
********************************************************************************
<span id="SymDecTopBits">DecTopBits</span>      ldy     <a href="#Symoddbytes">oddbytes</a>
                dey
                lda     #0
; 
                sta     <a href="#Symtbodd">tbodd</a>
<span id="Symgtbob">gtbob</span>           lda     ($54),y
                asl     A
                ror     <a href="#Symtbodd">tbodd</a>
                dey
                bpl     <a href="#Symgtbob">gtbob</a>
                sec
                ror     <a href="#Symtbodd">tbodd</a>
; 
                lda     <a href="#Symoddbytes">oddbytes</a>
                clc
                adc     $54
                sta     <a href="#Symbuffer2">buffer2</a>
                lda     <a href="#Symbuffer">buffer</a>+17
                adc     #0
                sta     <a href="#Symbuffer2">buffer2</a>+1
********************************************************************************
*                                                                              *
*  Sun                    Set up next buffer and topbits                       *
*                                                                              *
*    Primes the pip for the group of seven bytes routine                       *
*  setting the topbits byte and the "next" buffer.                             *
*  The routine also advances the buffer pointer by 7 to                        *
*  prepare for the groups of seven transfer.                                   *
*                                                                              *
*    Input:  buffer2   &lt;- points to groups of 7 data                           *
*   Output:  next1,7   &lt;- first 7 bytes in buffer                              *
*            topbits   &lt;- MSBs of first 7 bytes                                *
*                                                                              *
********************************************************************************
<span id="SymSun">Sun</span>             ldy     #6
<span id="Symsun2">sun2</span>            sec
                lda     (<a href="#Symbuffer2">buffer2</a>),y
                sta     <a href="#Symnext">next</a>,y
                bmi     <a href="#Symsun1">sun1</a>
                clc
<span id="Symsun1">sun1</span>            ror     <a href="#Symtopbits">topbits</a>
                dey
                bpl     <a href="#Symsun2">sun2</a>
                sec
                ror     <a href="#Symtopbits">topbits</a>
; 
; Advance the pointer
; 
                lda     <a href="#Symbuffer2">buffer2</a>
                clc
                adc     #7
                sta     <a href="#Symbuffer2">buffer2</a>
                bcc     <a href="#Symsun3">sun3</a>
                inc     <a href="#Symbuffer2">buffer2</a>+1
<span id="Symsun3">sun3</span>            rts

; 
; 
;  X is slot &amp; 16, Y is the desired mode
; 
;  Set up the IWM mode register.  Extreme care should be taken
;   here. Setting the mode byte with indexed stores causes a 
;   false byte to be written a cycle before the real value is
;   written.  This false value, if it enables the timer, causes
;   the IWM Rev A to pop the motor on, inhibiting the setting
;   of the mode until the motor times out! We avoid this by
;   setting the mode byte only when it is not what we want, and if
;   it's not we stay here until we see that it is what we want.
; 
<span id="SymSetIWMode">SetIWMode</span>       lda     <a href="#Symmonclr">monclr</a>,x          ;Motor must be off
                lda     <a href="#Syml6set">l6set</a>,x           ;Set up to access mode register
                jmp     <a href="#Symcareful">careful</a>           ;Don't mess unless we gotta

<span id="Symbiz">biz</span>             tya
                sta     <a href="#Syml7set">l7set</a>,x           ;Try storing the mode value
; 
<span id="Symcareful">careful</span>         tya                       ;Get back the target value
                eor     <a href="#Syml7clr">l7clr</a>,x           ;Compare with observed value
                and     #$1f              ;Can only read low 5 bits
                bne     <a href="#Symbiz">biz</a>               ;If not right, back to try again
                rts

; 
; Make sure you're in read mode and wait 'til Disk // motor is off
; 
<span id="SymWaitIWMOff">WaitIWMOff</span>      jsr     <a href="#SymSetXN0">SetXN0</a>            ;Set X
                lda     <a href="#Syml7clr">l7clr</a>,x
                lda     <a href="#Syml6set">l6set</a>,x
; 
<span id="Symwiwm1">wiwm1</span>           lda     <a href="#Syml7clr">l7clr</a>,x
                and     #%00100000
                bne     <a href="#Symwiwm1">wiwm1</a>
                lda     <a href="#Syml6clr">l6clr</a>,x
; 
; Wait an additional 700 usec to allow 12V on Disk // to decay
; 
                phy
                ldy     #140
<span id="Symwiwm2">wiwm2</span>           dey
                bne     <a href="#Symwiwm2">wiwm2</a>
                ply
; 
                rts

; 
; This takes grp7ctr and oddbytes and calculates 7*grp7ctr+oddbytes.
;   The results are in Y(hi) and A(low).  This is the number of bytes
;   that were received in the last ReceivePack.
; 
<span id="SymRcvcount">Rcvcount</span>        lda     <a href="#Symgrp7ctr">grp7ctr</a>
                tay
                ldx     #0
                stx     <a href="#Symgrp7ctr">grp7ctr</a>
                ldx     #3
<span id="Symtimes7">times7</span>          asl     A
                rol     <a href="#Symgrp7ctr">grp7ctr</a>
                dex
                bne     <a href="#Symtimes7">times7</a>
                clc
                adc     <a href="#Symoddbytes">oddbytes</a>
                bcc     <a href="#Symt71">t71</a>
                inc     <a href="#Symgrp7ctr">grp7ctr</a>
<span id="Symt71">t71</span>             sty     <a href="#Symoddbytes">oddbytes</a>
                sec
                sbc     <a href="#Symoddbytes">oddbytes</a>
                bcs     <a href="#Symt72">t72</a>
                dec     <a href="#Symgrp7ctr">grp7ctr</a>
<span id="Symt72">t72</span>             ldy     <a href="#Symgrp7ctr">grp7ctr</a>
                rts

; 
<span id="SymSlotDepRd">SlotDepRd</span>       ldy     #0
                lda     <a href="#Symgrp7ctr">grp7ctr</a>
                pha                       ;Save groups of seven counter
                bne     <a href="#Symstart35">start35</a>
                jmp     <a href="#Symdone5">done5</a>             ;Go get the checksum

; Okay, get the groups of seven
;   Start by getting the topbits for this group of seven
; 
<span id="Symstart35">start35</span>         lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff ;Get topbits
                bpl     <a href="#Symstart35">start35</a>
                sta     &lt;<a href="#Symtemp">temp</a>-159         ;Just a second
; Split up the seven bits into two indices for topbit tables
; 
                lsr     A                 ;0   1  d1  d2  d3  d4  d5  d6
                lsr     A                 ;0   0   1  d1  d2  d3  d4  d5
                lsr     A                 ;0   0   0   1  d1  d2  d3  d4
                and     #%00001111        ;0   0   0   0  d1  d2  d3  d4
                tax                       ;First index into the tables
                lda     &lt;<a href="#Symtemp">temp</a>-159         ;1  d1  d2  d3  d4  d5  d6  d7
                and     #%00000111        ;0   0   0   0   0  d5  d6  d7
                sta     &lt;<a href="#Symtemp">temp</a>-159         ;Keep for last three bytes
; 
; Read the 1st byte, reunite its msb, store and checksum it
; 
<span id="SymLCC90">LCC90</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#SymLCC90">LCC90</a>             ;Back 1 instruction
                eor     <a href="#Symshift1">shift1</a>,x          ;Recombine the MSB with data
                sta     (<a href="#Symbuffer2">buffer2</a>),y       ;Store it away
                eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
                sta     <a href="#Symbushog">bushog</a>
                iny
; 
;  Now, the second Y turn over occurs at this point in the
;   loop.  Update teh buffer pointer if it occured.
; 
                bne     <a href="#SymLCCA3">LCCA3</a>             ;*+4
                inc     <a href="#Symbuffer2">buffer2</a>+1
; 
; Now the second byte
; 
<span id="SymLCCA3">LCCA3</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#SymLCCA3">LCCA3</a>             ;Back 1 instruction
                eor     <a href="#Symshift2">shift2</a>,x          ;Recombine the MSB with data
                sta     (<a href="#Symbuffer2">buffer2</a>),y       ;Store it away
                eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
                sta     <a href="#Symbushog">bushog</a>
                iny
; 
; Now the third byte
; 
<span id="SymLCCB2">LCCB2</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#SymLCCB2">LCCB2</a>             ;Back 1 Instruction
                eor     <a href="#Symshift3">shift3</a>,x          ;Recombine the MSB with data
                sta     (<a href="#Symbuffer2">buffer2</a>),y       ;Store it away
                eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
                sta     <a href="#Symbushog">bushog</a>
                iny
; 
;  Now the fourth byte
; 
<span id="SymLCCC1">LCCC1</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#SymLCCC1">LCCC1</a>             ;Back 1 instruction
                eor     <a href="#Symshift4">shift4</a>,x          ;Recombine the MSB with data
                sta     (<a href="#Symbuffer2">buffer2</a>),y       ;Store it away
                eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
                sta     <a href="#Symbushog">bushog</a>
                iny
; 
;  The first Y turn over occurs at this point in the loop.  Update
;   the buffer poitner if it occured.
; 
                bne     <a href="#SymLCCD4">LCCD4</a>             ;*+4
                inc     <a href="#Symbuffer2">buffer2</a>+1
; 
<span id="SymLCCD4">LCCD4</span>           ldx     &lt;<a href="#Symtemp">temp</a>-159         ;Now we need the other index
; 
;  Now the fifth byte
; 
<span id="SymLCCD6">LCCD6</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#SymLCCD6">LCCD6</a>             ;Back 1 instruction
                eor     <a href="#Symshift2">shift2</a>,x          ;Recombine the MSB with data
                sta     (<a href="#Symbuffer2">buffer2</a>),y       ;Store it away
                eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
                sta     <a href="#Symbushog">bushog</a>
                iny
; 
;  Now the sixth byte
; 
<span id="SymLCCE5">LCCE5</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#SymLCCE5">LCCE5</a>             ;Back 1 instruction
                eor     <a href="#Symshift3">shift3</a>,x          ;Recombine the MSB with data
                sta     (<a href="#Symbuffer2">buffer2</a>),y       ;Store it away
                eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
                sta     <a href="#Symbushog">bushog</a>
                iny
; 
;  And, finallly, the seventh byte
; 
<span id="SymLCCF4">LCCF4</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#SymLCCF4">LCCF4</a>             ;Back 1 instruction
                eor     <a href="#Symshift4">shift4</a>,x          ;Recombine the MSB with data
                sta     (<a href="#Symbuffer2">buffer2</a>),y       ;Store it away
                eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
                sta     <a href="#Symbushog">bushog</a>
                iny
; 
;  Now see if this is the last group of seven to receive
; 
                dec     <a href="#Symgrp7ctr">grp7ctr</a>
                beq     <a href="#Symdone5">done5</a>             ;Go to get the checksum etc
                jmp     <a href="#Symstart35">start35</a>           ;Another topbits ...

; 
;  Get and reconstruct the checksum
; 
<span id="Symdone5">done5</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
                bpl     <a href="#Symdone5">done5</a>             ;*-3
                sta     &lt;<a href="#Symtemp">temp</a>-159         ;1 c6 1 c4 1 c2 1 c0
; 
                pla                       ;Restore groups of 7 counter
                sta     <a href="#Symgrp7ctr">grp7ctr</a>
; l6clr+TheOff
<span id="SymLCD14">LCD14</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;1 c7 1 c5 1 c3 1 c1
                bpl     <a href="#SymLCD14">LCD14</a>             ;*-3
                sec
                rol     A                 ;c7 1 c5 1 c3 1 c1 1
                and     &lt;<a href="#Symtemp">temp</a>-159         ;c7 c6 c5 c4 c3 c2 c1 c0
                eor     <a href="#Symbushog">bushog</a>            ;When we're done, should be zero
; 
;  Get the packet end mark. Is it correct?
; 
; l6clr+TheOff
<span id="Symrdha5">rdha5</span>           ldy     <a href="#Syml6clr">l6clr</a>+96          ;Preserve A
                bpl     <a href="#Symrdha5">rdha5</a>
; 
                cpy     #<a href="#Sympacketend">packetend</a>
                bne     <a href="#Symnpenderr5">npenderr5</a>
; 
;  Didn't have time before to checksum oddbytes.  Do it now
;   A still has the partial checksum
; 
                ldx     <a href="#Symoddbytes">oddbytes</a>
                beq     <a href="#Symicbt15">icbt15</a>
                ldy     #0
<span id="Symicbt5">icbt5</span>           eor     ($54),y
                iny
                dex
                bne     <a href="#Symicbt5">icbt5</a>
; 
; Okay, checksum oughta be zero.  If not, checksum error.
; 
<span id="Symicbt15">icbt15</span>          tax
                bne     <a href="#Symcserror5">cserror5</a>
; 
; Wait for /BSY to go low
; 
<span id="Symlstbsywait5">lstbsywait5</span>     lda     <a href="#Syml6clr">l6clr</a>+97          ;l6set+TheOff
<span id="Symrdh45">rdh45</span>           lda     <a href="#Syml7clr">l7clr</a>+96          ;l7clr+TheOff
                bmi     <a href="#Symrdh45">rdh45</a>
; 
; Got the bytes, now acknowledge their receipt
; 
; reqclr+TheOff
                lda     <a href="#Syml6clr">l6clr</a>+84          ;Lower REQ
; 
                clc
                rts

<span id="Symnpenderr5">npenderr5</span>       lda     #<a href="#Symnopackend">nopackend</a>
                bne     <a href="#Symgserror5">gserror5</a>

<span id="Symcserror5">cserror5</span>        lda     #<a href="#Symcsumerr">csumerr</a>
<span id="Symgserror5">gserror5</span>        sec
                rts

; include pc.main
; 
; 
<span id="SymEntry">Entry</span>           bcc     <a href="#Symbentry">bentry</a>            ;If non-boot, skip jump to boot
                jmp     <a href="#SymLC523">LC523</a>

; 
; X is still set to slot number
; 
<span id="Symbentry">bentry</span>          lda     #%01000000
                trb     <a href="#SymProFLAG">ProFLAG</a>+5         ;ProFlag is fixed in //c
; 
<span id="Symatentry">atentry</span>         cld                       ;Don't want decimal mode!!
                txa
                tay                       ;Really want it in Y... no ROR ABS,Y!
; 
; If this is a PC call, then get the address of the parm table
; 
                lda     <a href="#SymProFLAG">ProFLAG</a>,y
                bmi     <a href="#Symnoplay">noplay</a>
; 
                pla                       ;Get lo order
                sta     <a href="#SymSHTempX">SHTempX</a>,y         ;Keep lo parm address-1
                clc
                adc     #3
                tax                       ;Lo order new return address
                pla                       ;Get hi order address
                sta     <a href="#SymSHTempY">SHTempY</a>,y         ;Keep hi parm addr-1
                adc     #0
                pha                       ;Push back new return address hi
                txa
                pha                       ;Push new return address lo
; 
; On the //c, it is important to have the Disk // enable lines
;  off for as long as possible before using the IWM (phases,
;  /WRREQ lines). Wait here 'til the Disk // motors are off.
; 
<span id="Symnoplay">noplay</span>          jsr     <a href="#SymWaitIWMOff">WaitIWMOff</a>        ;Must Preserve Y!!
; 
; We can't tolerate ints in most of the code, so disable
; 
                php                       ;Save interrupt status
                sei                       ;No interrupts please
; 
; Preserve the zero page work area
; 
                ldx     #<a href="#SymZPSize">ZPSize</a>-1
<span id="Sympzp">pzp</span>             lda     <a href="#Symzeropage">zeropage</a>,x
                pha
                dex
                bpl     <a href="#Sympzp">pzp</a>
; 
; Okay, we're safe... now it's all right to store in zero page
; 
                sty     <a href="#SymSlot">Slot</a>
; 
; 
; Now map any ProDOS unit references to our sequential ones.
;  This method is bizzare and magicians never reveal their secrets.
; 
<span id="Symallset">allset</span>          lda     <a href="#SymCMDUnit">CMDUnit</a>           ;76543210 7&amp;6 specify unit
                rol     A                 ;6543210X C&lt;-7
                php                       ;Save drive num
                rol     A                 ;543210X7 C&lt;-6
                rol     A                 ;463210X76 (6 is grp of 2)
                plp                       ;C&lt;-7
                rol     A                 ;3210X767
                and     #%00000011        ;ProDOS only installs up to 4
                eor     #%00000010        ;000000/67; 6 was /grpoftwo
                cpy     #4                ;If in slot 1,2,or3 reverse grps of two
                bcs     <a href="#Symallset1">allset1</a>
                eor     #%00000010
<span id="Symallset1">allset1</span>         tax
                inx
                stx     <a href="#SymCMDUnit">CMDUnit</a>           ;You got it
; 
;  Now if this is through the MLI xface, gotta copy stuff into the
;   send buffer from the parameter list.
; 
                lda     <a href="#SymProFLAG">ProFLAG</a>,y
                bpl     <a href="#Symdarnit">darnit</a>
                jmp     <a href="#Symskipcopy">skipcopy</a>

; 
; Get the address of the in-line parameter table
; 
<span id="Symdarnit">darnit</span>          lda     <a href="#SymSHTempX">SHTempX</a>,y         ;Get back the low part buff adr
                sta     <a href="#Symbuffer">buffer</a>+16
                lda     <a href="#SymSHTempY">SHTempY</a>,y         ; and the hi part
                sta     <a href="#Symbuffer">buffer</a>+17
; 
; Now pull out the command code, and the address of the parameters.
; 
                ldy     #1                ;Stacked address is EA-1
                lda     ($54),y
                sta     <a href="#SymCMDCode">CMDCode</a>           ;Nice
                iny
                lda     ($54),y           ;Get lo part of parmlist address
                tax                       ;Save it
                iny
                lda     ($54),y           ;Get hi part
                sta     <a href="#Symbuffer">buffer</a>+17
                stx     $54
; 
; Now buffer points to parmlist
;  Check command type, and pidgeonhole the parmlist length
; 
                lda     #<a href="#SymBadCmd">BadCmd</a>
                ldx     <a href="#SymCMDCode">CMDCode</a>
                cpx     #$0a              ;Only valid codes are 0-9
                bcc     <a href="#Symnoeh">noeh</a>              ;=&gt; at least he got that right
<span id="SymErrorHitch">ErrorHitch</span>      jmp     <a href="#SymError">Error</a>             ;Gee, maybe we should promote this guy...

<span id="Symnoeh">noeh</span>            ldy     #0                ;Set for indct compare
                lda     ($54),y           ;Get # of parms?
                sta     <a href="#SymUnit">Unit</a>
; 
; Now copy the bytes
; 
<span id="Symokaycnt">okaycnt</span>         ldy     #<a href="#Symcmdlength">cmdlength</a>-1      ;Always copy the maximum
<span id="Symcopyloop">copyloop</span>        lda     ($54),y           ;Pull it out of their hat
                sta     <a href="#SymCMDCode">CMDCode</a>,y         ;Stuff it into mine
                dey
                bne     <a href="#Symcopyloop">copyloop</a>          ;Copy 'em all
; 
; Okay.  The caller of the PC could be making one of three calls
;  with a unit number of $00, Control, Init or Status.  Check for
;  these and do what is appropriate.
; 
                lda     <a href="#SymCMDUnit">CMDUnit</a>
                bne     <a href="#Symskipcopy">skipcopy</a>          ;Never mind
; 
; Check the parameter count for this call to unit#0
; 
                ldx     <a href="#SymCMDCode">CMDCode</a>
                lda     <a href="#Symparmctab">parmctab</a>,x        ;Get the length this command
                and     #$7f              ;Force 0 -&gt; MSB
                tay                       ;Hang on
                lda     #<a href="#SymBadPCnt">BadPCnt</a>          ;Antic bad count
                cpy     <a href="#SymUnit">Unit</a>              ;User's pcount is currently here
                bne     <a href="#SymErrorHitch">ErrorHitch</a>        ;What a baby!
; 
; Now service one of the three commands
; 
                cpx     #<a href="#SymInitCmd">InitCmd</a>
                bne     <a href="#Symnotinit">notinit</a>           ;Not an Init call
                lda     #<a href="#SymPowerReset">PowerReset</a>       ;Just like powerup or reset key (//c)
                jsr     <a href="#SymAssignID">AssignID</a>          ;Do a reset cycle
<span id="SymAokay">Aokay</span>           lda     #0                ;No error allowed
                jmp     <a href="#Symsa2">sa2</a>

<span id="Symnotinit">notinit</span>         txa                       ;Eqiv to 'cmp #StatusCMD'
                bne     <a href="#Symmaybectrl">maybectrl</a>
; 
                lda     #<a href="#SymBadCtl">BadCtl</a>           ;Antic a non zero stat code
                ldx     <a href="#SymCMDSCode">CMDSCode</a>          ;Stat unit#0 can only be code=0
                bne     <a href="#SymErrorHitch">ErrorHitch</a>
; 
                txa                       ;Equiv to `lda #0`
                ldx     <a href="#SymSlot">Slot</a>
                ldy     #7
<span id="Symnin1">nin1</span>            sta     (<a href="#SymCMDBufferl">CMDBufferl</a>),y    ;Clear some space
                dey
                bne     <a href="#Symnin1">nin1</a>
                lda     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+1,x
                sta     (<a href="#SymCMDBufferl">CMDBufferl</a>),y    ;Stick it where they want it
                iny
; 
                lda     <a href="#SymSCRNHOLE1">SCRNHOLE1</a>+1       ;//C Port 1 interrupt status
; 
                sta     (<a href="#Symbuffer">buffer</a>),y
; 
                lda     #8
                dey                       ;A,Y has 0008; # bytes status
                jsr     <a href="#Symsquirrel">squirrel</a>
; 
                jmp     <a href="#SymAokay">Aokay</a>             ;Skip down (up) with no error)

<span id="Symmaybectrl">maybectrl</span>       cmp     #<a href="#SymControlCmd">ControlCmd</a>
                bne     <a href="#SymBUnit">BUnit</a>             ;Unit #0 was a bad one
; 
                ldx     <a href="#SymCMDSCode">CMDSCode</a>          ;We allow two control calls for Unit#0
                beq     <a href="#Symenabint">enabint</a>           ;0 means enable interrupts
                dex
                beq     <a href="#Symdisabint">disabint</a>          ;1 means disable interrupts
                lda     #<a href="#Symbadctl">badctl</a>
; 
<span id="SymErrorHitch2">ErrorHitch2</span>     bne     <a href="#SymErrorHitch">ErrorHitch</a>        ;No other codes allowed
<span id="SymBUnit">BUnit</span>           lda     #<a href="#SymBadUnit">BadUnit</a>          ;Only certain calls can have Unit#0
                bne     <a href="#SymErrorHitch">ErrorHitch</a>        ;Branch always

; 
<span id="Symenabint">enabint</span>         lda     #$c0
                sta     <a href="#SymSCRNHOLE3">SCRNHOLE3</a>+1
                lda     #$0f
                tsb     $c09a
                bne     <a href="#Symaokayhitch">aokayhitch</a>
; 
<span id="Symdisabint">disabint</span>        lda     #$01
                trb     $c09a
<span id="Symaokayhitch">aokayhitch</span>      jmp     <a href="#SymAokay">Aokay</a>

; 
; Okay, everything's all groovy.  ProDOS re-enters here.
;  Check Unit number to be sure there is a corresponding device
; 
<span id="Symskipcopy">skipcopy</span>        lda     #<a href="#SymNoDrive">NoDrive</a>          ;Anticpate bad unit number
                ldy     <a href="#SymSlot">Slot</a>
                ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+1,y
                cpx     <a href="#SymA4H">A4H</a>
                bcc     <a href="#SymErrorHitch2">ErrorHitch2</a>       ;Safe- If C clr then Z is clr
; 
; Set buffer and bytecount in anticpation of the inevitable SendPack
; 
                lda     #<a href="#Symcmdlength">cmdlength</a>
                sta     <a href="#Symbytecountl">bytecountl</a>
                lda     #&gt;<a href="#Symcmdlength">cmdlength</a>
                sta     <a href="#Symbytecounth">bytecounth</a>
                sta     <a href="#Symbuffer">buffer</a>+17
                lda     #<a href="#SymCMDCode">CMDCode</a>
                sta     $54
; 
; If it's a PC call, omit the next two steps
; 
                ldx     <a href="#SymSlot">Slot</a>
                lda     <a href="#SymProFLAG">ProFLAG</a>,x         ;Is it a call from ProDOS?
                bpl     <a href="#Symnotstat">notstat</a>           ;=&gt; Statcode already set...
; 
; Need to generate a paramter count for a ProDOS call
; 
                ldx     <a href="#SymCMDCode">CMDCode</a>
                lda     <a href="#Symparmctab">parmctab</a>,x
                and     #$7f
                sta     <a href="#SymUnit">Unit</a>
; 
; ProDOS always needs the highest blockno byte zeroed
; 
                lda     #0
                sta     <a href="#SymCMDBlocks">CMDBlocks</a>
; 
;  IF this is a ProDOS status call, set stat code to zero
; 
                lda     <a href="#SymCMDCode">CMDCode</a>
                bne     <a href="#Symnotstat">notstat</a>           ;=&gt; Not status so forget it
; lda #SCDeviceStat  ;A is already zero
                sta     <a href="#SymCMDSCode">CMDSCode</a>          ;Store in command table
; 
; Okay, finally send over the damn command
; 
<span id="Symnotstat">notstat</span>         lda     <a href="#SymUnit">Unit</a>
                ldx     <a href="#SymCMDPcount">CMDPcount</a>         ;Swap the Parmcount &amp; unit#
                stx     <a href="#SymUnit">Unit</a>
                sta     <a href="#SymCMDPcount">CMDPcount</a>         ;Now they're correct
; 
                lda     #<a href="#Symcmdmark">cmdmark</a>
                sta     <a href="#SymWpacketType">WpacketType</a>       ;WPacketType
; 
                jsr     <a href="#SymClrPhases">ClrPhases</a>         ;Bring all phases off for Quark
; 
                jsr     <a href="#SymSendPack">SendPack</a>
                bcs     <a href="#Symbehitch">behitch</a>           ;If not okay, skip to bus error
; 
; Now copy over the buffer address for any data xfer
; 
                lda     <a href="#SymCMDBuffer">CMDBuffer</a>
                sta     $54
                lda     <a href="#SymCMDBuffer">CMDBuffer</a>+1
                sta     <a href="#Symbuffer">buffer</a>+17
; 
; Now for some commands, we have to send over a packet of data, too.
;  See if this command is one of THOSE.
; 
                ldx     <a href="#SymCMDCode">CMDCode</a>
                lda     <a href="#Symparmctab">parmctab</a>,x
                bpl     <a href="#Symnoxtrasend">noxtrasend</a>        ;Encoded in top bit
; 
; The buffer address and bytecount depend on the call type.
; 
                cpx     #<a href="#SymControlCmd">ControlCmd</a>
                bne     <a href="#SymNOControl">NOControl</a>
; 
; In the case of control, bytecount:=(buffer)
; and buffer :=buffer+2
; 
                ldy     #1
                lda     ($54),y           ;Get Hi order bytecount
                tax
                dey
                lda     ($54),y
                pha                       ;Keep for later
                clc
                lda     #2
                adc     $54
                sta     $54
                pla                       ;Get back Lo order bytecount
                bcc     <a href="#Symsecondsend">secondsend</a>        ;Skip hi ord increment
                inc     <a href="#Symbuffer">buffer</a>+17
                jmp     <a href="#Symsecondsend">secondsend</a>        ;Skip to store bytecount

<span id="SymNOControl">NOControl</span>       cpx     #<a href="#SymWriteCmd">WriteCmd</a>         ;Check for a writeblock
                bne     <a href="#SymNOWBlock">NOWBlock</a>          ;Must be control or write
; 
;  In the case of WriteBlock, the length is 512 and the buffer
;   address is at buffer in the command table
; 
                lda     #0
                ldx     #2
                bne     <a href="#Symsecondsend">secondsend</a>

; 
; For FileWrite, the buffer address is at CMDbuffer
;  and the length is at CMDblock.
; 
<span id="SymNOWBlock">NOWBlock</span>        ldx     <a href="#SymCMDBlockh">CMDBlockh</a>
                lda     <a href="#SymCMDBlockl">CMDBlockl</a>
; 
<span id="Symsecondsend">secondsend</span>      stx     <a href="#Symbytecounth">bytecounth</a>
                sta     <a href="#Symbytecountl">bytecountl</a>
; 
                lda     #<a href="#Symdatamark">datamark</a>
                sta     <a href="#SymWpacketType">WpacketType</a>       ;Identify this as a data packet
; 
                jsr     <a href="#SymSendData">SendData</a>
                bcc     <a href="#Symnoxtrasend">noxtrasend</a>
; 
<span id="Symbehitch">behitch</span>         lda     #<a href="#SymBusErr">BusErr</a>           ;This is a bus error hitch
                bne     <a href="#SymError">Error</a>

; 
; On ProDOS status call, we've got to a point the buffer pointer
;  correctly to zero page... it's the only case special case
;  (on Write, Format and Control no data comes back).
; 
<span id="Symnoxtrasend">noxtrasend</span>      ldy     <a href="#SymSlot">Slot</a>
                lda     <a href="#SymProFLAG">ProFLAG</a>,y
                bpl     <a href="#Symgetresults">getresults</a>
                lda     <a href="#SymCMDCode">CMDCode</a>
                bne     <a href="#Symgetresults">getresults</a>
; 
                lda     #<a href="#SymCMDBufferh">CMDBufferh</a>       ;Want status in these four
                ldx     #&gt;<a href="#SymCMDBufferh">CMDBufferh</a>
                sta     $54
                stx     <a href="#Symbuffer">buffer</a>+17
; 
; Please to be calling ReceivePack
; 
<span id="Symgetresults">getresults</span>      jsr     <a href="#SymRecPack">RecPack</a>           ;Get status byte (maybe read data too)
                bcs     <a href="#Symbehitch">behitch</a>
; 
; Figure out how many bytes were sent and put that in X,Y temps
; 
                jsr     <a href="#SymRcvcount">Rcvcount</a>          ;Do the time 7...
                jsr     <a href="#Symsquirrel">squirrel</a>          ;Store away count in SHTEMPs
; 
; For the ProDOS status call, we've got to look at the status byte
;  returned and return a DIP error if appropriate. Also overwrite
;  the X,Y temps with # blocks if this is a ProDOS Stat Call.
; 
                lda     <a href="#SymCMDCode">CMDCode</a>           ;Is this a ProDOS status call
                bne     <a href="#Symnoerror">noerror</a>
                ldx     <a href="#SymSlot">Slot</a>
                lda     <a href="#SymProFLAG">ProFLAG</a>,x
                bpl     <a href="#Symnoerror">noerror</a>
; 
                lda     <a href="#SymCMDBlockl">CMDBlockl</a>         ;This'll get loaded into the XY regs later
                sta     <a href="#SymSHTempX">SHTempX</a>,x
                lda     <a href="#SymCMDBlockh">CMDBlockh</a>
                sta     <a href="#SymSHTempY">SHTempY</a>,x
                lda     <a href="#SymCMDBufferh">CMDBufferh</a>        ;Check status byte
                lsr     A
                lsr     A
                lsr     A
                bcc     <a href="#SymChkOffLn">ChkOffLn</a>          ;no error, go check off line
                lda     #<a href="#SymWriteProt">WriteProt</a>        ;else set WPROT error
                bra     <a href="#SymError">Error</a>

<span id="SymChkOffLn">ChkOffLn</span>        lsr     A
                lsr     A
                lda     #<a href="#SymOffline">Offline</a>          ;Assume error
                bcc     <a href="#SymError">Error</a>
; 
; Now it's time to think about returning to the caller
;  Remember that ProDOS doesn't want to know about soft errors, 
;  only fatal ones.  If this is a ProDOS call, and the soft error
;  bit in the statbyte is set, there IS NO error (statbyte is 
;  cleared). Also, ProDOS wants only, I/O, Write Protect, No Device,
;  Offline.  If any other hard error comes from the device
;  on a ProDOS call, map it to an I/O Error. (Gross me out.)
; 
<span id="Symnoerror">noerror</span>         lda     <a href="#Symstatbyte">statbyte</a>
; 
<span id="SymError">Error</span>           ldy     <a href="#SymSlot">Slot</a>              ;Need access to screenholes
                sta     <a href="#SymRetry">Retry</a>,y           ;Keep unadulterated error in shole
                tax                       ;set the Z flag
                beq     <a href="#Symsa2">sa2</a>               ;Special case the zero
                ldx     <a href="#SymProFLAG">ProFLAG</a>,y         ;Set N to ProDOS call or not
                bpl     <a href="#Symsa2">sa2</a>               ;If PC call, no mapping occurs
                ldx     #0                ;Assume a soft error
                cmp     #%01000000        ;Soft Error Check
                bcs     <a href="#Symstoreaway">storeaway</a>         ;If $40 or bigger, map to zero
; 
                ldx     #<a href="#SymIOError">IOError</a>          ;Now anticipate ProDOS I/O error
                cmp     #<a href="#SymWriteProt">WriteProt</a>
                beq     <a href="#Symsa2">sa2</a>               ;OK to return Write Protect
                cmp     #<a href="#SymNoDrive">NoDrive</a>
                beq     <a href="#Symsa2">sa2</a>               ;OK to return Drive disconnected
                cmp     #<a href="#SymOffline">Offline</a>
                beq     <a href="#Symsa2">sa2</a>
; 
<span id="Symstoreaway">storeaway</span>       txa                       ;Use the default value
; 
<span id="Symsa2">sa2</span>             ldy     <a href="#SymSlot">Slot</a>
                sta     <a href="#SymSHTemp1">SHTemp1</a>,y         ;Keep in screenhole
; If this is the //c version, we need to reset the IWN to its
;  former disk // state.  This is done by setting the mode register
;  to a little known (and less documented) mode which speeds up the 
;  internal motor timeout.  When the motor enable has timed out, the
;  mode can be set back to zero.  This method is necessary because
;  if the timer is enabled within the timeout period, the motor on a 
;  Rev A IWM pops on for the full timeout period (since mode changes
;  are disabled when the motor is on.  It's bizzare. Blame Mac.
                lda     <a href="#Symmonclr">monclr</a>+96         ;Motor Off
                bit     <a href="#Syml6set">l6set</a>+96          ;Into mode reg access mode
                lda     #$2b              ;This is the magic "speed up" value
                sta     <a href="#Syml7set">l7set</a>+96          ;Throw into mode register
                nop                       ;You're supposed to wait a while
                nop
                nop
                nop
; 
<span id="Symwaitoff">waitoff</span>         lda     <a href="#Syml7clr">l7clr</a>+96          ;Wait 'til motor off
                and     #$20
                bne     <a href="#Symwaitoff">waitoff</a>
                ldy     #0                ;Now set the reg back to $00
                ldx     #$60              ;IWM's in slot 6
                jsr     <a href="#SymSetIWMode">SetIWMode</a>
                lda     <a href="#Syml6clr">l6clr</a>+96
                lda     <a href="#Symca1clr">ca1clr</a>+96
                lda     <a href="#Symlstrbclr">lstrbclr</a>+96
                ldy     <a href="#SymSlot">Slot</a>              ;Need Slot in Y
; 
;  Now, restore our zero page area.
; 
                ldx     #0
<span id="Symrzp">rzp</span>             pla
                sta     <a href="#Symzeropage">zeropage</a>,x
                inx
                cpx     #<a href="#SymZPSize">ZPSize</a>
                bcc     <a href="#Symrzp">rzp</a>
; 
;  We're into the stretch!  Restore interrupt mask, load X, Y,
;    and A and set the carry if the error byte is non-zero.
; 
                plp                       ;Restore interrupt flag
                lda     <a href="#SymSHTempX">SHTempX</a>,y         ;Get X value
                tax
                lda     <a href="#SymSHTemp1">SHTemp1</a>,y         ;Grab the error result code
                pha
                lda     <a href="#SymSHTempY">SHTempY</a>,y         ;Pull out the Y value
                tay                       ;No more access to screenholes
                clc                       ;Anticipate zero result code
                pla                       ;Pull back result code
                beq     <a href="#Symfinalskip">finalskip</a>         ;Return with carry clear
                sec                       ;Some type of error
; 
<span id="Symfinalskip">finalskip</span>       php                       ;Save carry and Z flag
                bit     <a href="#SymProFLAG">ProFLAG</a>+5         ;Ick - ProFlag is fixed in //c
                bvs     <a href="#Symick1">ick1</a>              ;If bit 6=1, then return to alt ROM
                plp                       ;Vclr so return across ROM bank bdy
                jmp     <a href="#Symswrts2">swrts2</a>

<span id="Symick1">ick1</span>            plp
                rts                       ;Flags set correctly again

<span id="Symparmctab">parmctab</span>        .dd1    %00000011         ;Status:  3 parms/no data send
                .dd1    %00000011         ;Read:    3 parms/no data send
                .dd1    %10000011         ;Write:   3 parms/data send
                .dd1    %00000001         ;Format:  1 parm /no data send
                .dd1    %10000011         ;Control: 3 parms/data send
                .dd1    %00000001         ;Init:    1 parm /no data send
                .dd1    %00000001         ;Open:    1 parm /no data send
                .dd1    %00000001         ;Close:   1 parm /no data send
                .dd1    %00000011         ;CharRead: 3 parms/data send
                .dd1    %10000011         ;CharWrite: 3 parms/data send

<span id="SymAssignID">AssignID</span>        pha                       ;Save the init code
                jsr ▼   <a href="#Symresetchain">resetchain</a>        ;Reset all of those things
<span id="Symm_oveirq">m_oveirq</span>        eor ▼   $68ca,x
                pla
                tax                       ;Save InitCode
; 
;  Save the command code, unit, and init code
;  'cause we'll trample 'em:
                lda     <a href="#SymCMDCode">CMDCode</a>
                pha
                lda     <a href="#SymCMDPcount">CMDPcount</a>
                pha
                lda     <a href="#SymCMDSCode">CMDSCode</a>
                pha
                stx     <a href="#SymCMDSCode">CMDSCode</a>          ;Store away the type of INIt
; 
;  Set up to send DefID command packets
; 
                lda     #<a href="#SymInitCmd">InitCmd</a>
                sta     <a href="#SymCMDCode">CMDCode</a>
                lda     #0
                sta     <a href="#SymUnit">Unit</a>
                lda     #2                ;# parms in Init Call
                sta     <a href="#SymCMDPcount">CMDPcount</a>
; 
;  Point the buffer pointer
; 
                lda     #<a href="#SymCMDCode">CMDCode</a>
                sta     $54
                lda     #&gt;<a href="#SymCMDCode">CMDCode</a>
                sta     <a href="#Symbuffer">buffer</a>+17
                lda     #<a href="#Symcmdmark">cmdmark</a>
                sta     <a href="#SymWpacketType">WpacketType</a>
                jsr     <a href="#SymClrPhases">ClrPhases</a>         ;Make sure phases are off for Quark
; 
;  Send an ID for the next device in the chain
; 
<span id="Symmordevices">mordevices</span>      inc     <a href="#SymUnit">Unit</a>
                lda     #<a href="#Symcmdlength">cmdlength</a>
                sta     <a href="#Symbytecountl">bytecountl</a>        ;ReceivePack scrambles count
                lda     #&gt;<a href="#Symcmdlength">cmdlength</a>
                sta     <a href="#Symbytecounth">bytecounth</a>
; 
                jsr     <a href="#SymSendOnePack">SendOnePack</a>       ;Send the command
                bcc     <a href="#Symmdev2">mdev2</a>             ;If okay, skip to get response
; 
                dec     <a href="#SymUnit">Unit</a>
                jmp     <a href="#Symmdev1">mdev1</a>

<span id="Symmdev2">mdev2</span>           jsr     <a href="#SymReceivePack">ReceivePack</a>       ;Get the response
                lda     <a href="#Symbytecount">bytecount</a>
                beq     <a href="#Symmordevices">mordevices</a>
; 
;  Okay, we done last device.  Squirrel away the number of devices.
; 
<span id="Symmdev1">mdev1</span>           lda     <a href="#SymUnit">Unit</a>
                ldy     <a href="#SymSlot">Slot</a>
                sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+1,y     ;Devices out there
; 
;  Recover the scrambled ProDOS parms
; 
                pla
                sta     <a href="#SymCMDSCode">CMDSCode</a>
                pla
                sta     <a href="#SymCMDPcount">CMDPcount</a>
                pla
                sta     <a href="#SymCMDCode">CMDCode</a>
; 
                rts

<span id="Symsquirrel">squirrel</span>        ldx     <a href="#SymSlot">Slot</a>
                sta     <a href="#SymSHTempX">SHTempX</a>,x
                tya
                sta     <a href="#SymSHTempY">SHTempY</a>,x
                rts

                .fill   6,$00

********************************************************************************
* The command routine now supports 5 new 2-character commands.  These          *
* commands enable or disable af eature of the serial port and                  *
* are derived from their equivalent in the super serial card for the //.       *
*                                                                              *
* The new commands are as follows:                                             *
*   L - send LF out after CR                                                   *
*   X - detect XOFF, and wait for XON                                          *
*   F - accept keyboard input                                                  *
*   M - ignore LF in after CR                                                  *
*   C - auto CR when column count &gt; printer width                              *
*                                                                              *
* Usage of location $779 (port 1) and $77A (port 2) are as follows:            *
*   bit 7 - echo output to screen if on                                        *
*   bit 6 - generate LF after CR if on                                         *
*   bit 5 - accept XOFF if on                                                  *
*   bit 4 - ignore keyboard input if on                                        *
*   bit 3 - accept LF in after CR if on                                        *
*   bit 2 - a character was received through the ACIA and is in                *
*      location $5FE (port 1) or $67E (port 2) if on                           *
*   bit 1 - XOFF is accepted, awaiting XON if on                               *
*   bit 0 - signifies comm port if on, printer port if off                     *
********************************************************************************
<span id="Symcommand">command</span>         pha                       ;shove character on stack
                bit     <a href="#Symsermode">sermode</a>,x         ;Already in command?
                bmi     <a href="#Symincmd">incmd</a>             ;If so, go do it
                ldy     <a href="#Symeschar">eschar</a>,x          ;If eschar = 0 ignore commands
                beq     <a href="#Symnocmd">nocmd</a>
                eor     <a href="#Symsl_scrn6">sl_scrn6</a>,x        ;Is it the command char?
                asl     A                 ;Ignore high bit
                bne     <a href="#Symnocmd">nocmd</a>             ;char not command char
<span id="Symcommand1">command1</span>        ldy     <a href="#Symcursor">cursor</a>            ;Save the cursor
                sty     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1
                ldy     #<a href="#Symcmdcur">cmdcur</a>           ;Set command cursor
                sty     <a href="#Symcursor">cursor</a>
                jmp     <a href="#Symcominit1">cominit1</a>          ;initiate command mode

<span id="Symnocmd">nocmd</span>           sec                       ;Mark char not handled
<span id="Symnocmd2">nocmd2</span>          pla                       ;Restore original char
                rts

<span id="Symincmd">incmd</span>           ldy     <a href="#Symdevno2">devno2</a>,x          ;Get index for ACIA
                and     #$5f              ;no hi-bit and upshift lower case
                pha                       ;save character
                lda     <a href="#Symsermode">sermode</a>,x         ;need to see if in 2-chr command
                bit     #$08              ;bit 3 set if so
                bne     <a href="#Symincmd2">incmd2</a>            ;branch if so
                pla                       ;pull char back, not in 2-chr cmd
                bra     <a href="#Symincmd1">incmd1</a>            ;go on with regular command mode

; handle 2nd chr of 2-char commands
<span id="Symincmd2">incmd2</span>          pla                       ;pull char off stack
                pha                       ; &amp; reshove it to keep stack neat
                cmp     #<a href="#Symucspace">ucspace</a>          ;is it a space? (uppercased)
                bne     <a href="#Symincmd3">incmd3</a>            ;no, go on with 2-chr cmd handling
                clc                       ;yes, ignore spaces between characters
;                                        of 2-chr commands
                pla                       ;pull uppercased char off stack
                bra     <a href="#Symnocmd2">nocmd2</a>            ;ie mark them "handled" and don't do anything else

<span id="Symincmd3">incmd3</span>          lda     <a href="#Symsermode">sermode</a>,x         ;get sermode back
                pha                       ;save sermode for a minit
                and     #7                ;throw out all but bits 0-2
                sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;save - this is index of which cmd it is
                pla                       ;get sermode back
                and     #$f0              ;now clear bits 0-3
                sta     <a href="#Symsermode">sermode</a>,x         ;since we're done with them now
                pla                       ;get character back
                phx                       ;shove x (Cn) on stack
                ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;get index to command's 1st chr
                cmp     #$45              ;is it an E?
                beq     <a href="#Symenable">enable</a>            ;yes
                cmp     #$44              ;no, is it a D?
                beq     <a href="#Symdisable">disable</a>           ;yes
                plx                       ;retriefve X=Cn (old X still in temp)
                phx                       ;push it back to keep stack neat
                cmp     <a href="#Symsl_scrn6">sl_scrn6</a>,x        ;compare to the command character
                php                       ;save result of comparison for a bit
                ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;reload X= index to cmd's first chr
                plp                       ;retrieve result of comparison of char
;                                        to command char
                beq     <a href="#Symflagit">flagit</a>            ;yes tis 1-chr cmd followed by nother cmd
                cmp     #<a href="#SymcharCR">charCR</a>           ;is it a (guess what) CR?
                beq     <a href="#Symoneletter">oneletter</a>         ;yes - a 1-chr command
; 
; come here for unimplemented byt legal 2-char commands
; 
<span id="Symcmd2null">cmd2null</span>        plx                       ;pull x (Cn) off stack
                lda     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;restore non-cmd-mode cursor
                sta     <a href="#Symcursor">cursor</a>
                asl     <a href="#Symsermode">sermode</a>,x         ;clear cmd-mode bit (bit 7 of sermode)
                lsr     <a href="#Symsermode">sermode</a>,x         ;by shifting out bit 7 &amp; shifting in a 0
                bra     <a href="#Symnocmd">nocmd</a>             ;return marking character not handled

;                                       ;come here if eschar after LXFM or T
<span id="Symflagit">flagit</span>          plx                       ;next X=Cn to set bit 0 of sermode
                phx                       ;but leave Cn on stack too
                inc     <a href="#Symsermode">sermode</a>,x         ;bit 0 was 0, but is now 1
;                                        1 means new command mode
                ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;X= index to cmd's first chr
;                                       ;come here if 2-chr cmd turns out 1 chr
<span id="Symoneletter">oneletter</span>       lda     <a href="#Symcmd2list">cmd2list</a>,x        ;get command chr
                bra     <a href="#Symbackto1">backto1</a>           ;treat it as if we jot got it

;                                       ;in command mode, not 2-chrs tho
<span id="Symincmd1">incmd1</span>          phx                       ;Save slot
                ldx     #4                ;check 5 possible 5-chr cmds
<span id="Symcmd2loop">cmd2loop</span>        cmp     <a href="#Symcmd2list">cmd2list</a>,x        ;is it there?
                beq     <a href="#Symcmd2found">cmd2found</a>         ;yes, need to flag it for next time
                dex                       ;nope
                bpl     <a href="#Symcmd2loop">cmd2loop</a>          ;try next if there is one
;                                       ;come here to check for 1-chr cmds
<span id="Symbackto1">backto1</span>         ldx     #12               ;Check 13 commands
<span id="Symcmdloop">cmdloop</span>         cmp     <a href="#Symcmdlist">cmdlist</a>,x
                beq     <a href="#Symcmfound">cmfound</a>           ;Right char?
                dex
                bpl     <a href="#Symcmdloop">cmdloop</a>
                plx                       ;We didn't find it
                pla
                pha
                and     #$7f              ;if char is cntl char
                cmp     #$20              ;it can be the new comd char
                bcs     <a href="#Symckdig">ckdig</a>             ;branch if not cntrl character
<span id="Symcmdz2">cmdz2</span>           sta     <a href="#Symsl_scrn6">sl_scrn6</a>,x        ;save command char and
;                                        drop thur ckdig to cdone
<span id="Symckdig">ckdig</span>           eor     #$30              ;zap it down to 0n if char was a digit
                cmp     #$0a              ;is it a digit?
                bcs     <a href="#Symcdone">cdone</a>             ;skip if no, an unexpected intruder
                ldy     #10               ;A = A + 10 * current number
<span id="Symdigloop">digloop</span>         adc     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6       ;C=0 on first entry
                dey
                bne     <a href="#Symdigloop">digloop</a>
                bra     <a href="#Symcominit">cominit</a>           ;not starting new cmd mode, just save #

;                                       ;start new cmd mode here
<span id="Symcominit1">cominit1</span>        lda     <a href="#Symsermode">sermode</a>,x         ;get sermode
                and     #$c0              ;clear bits 0-5 (starting a new cmd seq--
                sta     <a href="#Symsermode">sermode</a>,x         ;they are used for misc during cmd mode)
                lda     #0                ;load a 0 to stuff in NUMBER
<span id="Symcominit">cominit</span>         sta     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6
                sec                       ;Mark in command mode
                bra     <a href="#Symcmset">cmset</a>

;                                       ;got a 2-chr command aE
<span id="Symenable">enable</span>          sec                       ;set charry
                .dd1    $90               ;bcc to skip next byte (the CLC)
;                                       ;got a 2-chr command aD
<span id="Symdisable">disable</span>         clc                       ;clear carry
                php                       ;push P to save carry
                cpx     #0                ;if X=0 then command is LE or LD
                beq     <a href="#Symcmd21">cmd21</a>             ;so just make it act like L or K
                cpx     #4                ;if X=4 then command is CE or CD
                beq     <a href="#Symcmd_c">cmd_c</a>             ;skip if so
********************************************************************************
* for other 2-chr cmds, their FLAGS masks' indexes are 2X+3                    *
* for an E or 2X+4 for a D                                                     *
********************************************************************************
                txa                       ;copy x to acc for arithmetic
                clc                       ;clear carry for arithmetic
                asl     A                 ;multiply index by 2
                adc     #3                ;add 3 to get mask index
                tax                       ;put mask index in X
                plp                       ;get carry back
                bcs     <a href="#Symxready">xready</a>            ;carry set = Enable so X is ready
                inx                       ;cmd was Disable so inc X to next mask
<span id="Symxready">xready</span>          jmp     <a href="#Symcmdi">cmdi</a>              ;go do mask stuff to FLAGS

; ;$D0DE: ;sermode bit 0 tells whether to set or clear command mode
<span id="Symcdone">cdone</span>           lda     <a href="#Symsermode">sermode</a>,x         ;so get it
                lsr     A                 ;shift bit 0 to carry
                bcs     <a href="#Symcominit1">cominit1</a>          ;if set, start new cmd mode
                lda     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;Restore the cursor
                sta     <a href="#Symcursor">cursor</a>            ;&amp; fall through to cmset with carry clear
<span id="Symcmset">cmset</span>           php
                asl     <a href="#Symsermode">sermode</a>,x         ;set command mode according to carry
                plp
                ror     <a href="#Symsermode">sermode</a>,x         ;leaves carry clear
                pla                       ;character handled
                rts                       ;because carry clear...

;                                       ;come here to handle LE &amp; LD
<span id="Symcmd21">cmd21</span>           lda     #$4c              ;make LE look like L
                plp                       ;get P back with carry indicating E or D
                bcs     <a href="#Symbackto1">backto1</a>           ;carry set means it was an E
                lda     #$4b              ;make LD look like X
                bra     <a href="#Symbackto1">backto1</a>

<span id="Symcmd2found">cmd2found</span>       txa                       ;copy index of cmd to acc
                plx                       ;restore X to Cn
                ora     <a href="#Symsermode">sermode</a>,x         ;copy top 2 bits of sermode
                ora     #$08              ;&amp; set bit 3 - 2-chr-command-mode flag
                sta     <a href="#Symsermode">sermode</a>,x         ;sermode = index to 2-chr cmds issued
                sec                       ;set carry so we stay in command mode
                bra     <a href="#Symcmset">cmset</a>             ;for next time

<span id="Symcmfound">cmfound</span>         lda     #&gt;<a href="#Symcmdcr">cmdcr</a>           ;get hi byte of where to go
                pha                       ;save it on stack
                lda     <a href="#Symcmdtable">cmdtable</a>,x        ;get lo byte of where to go
                pha                       ;save it on stack
                rts                       ;go there by RTSing

<span id="Symcmd_c">cmd_c</span>           plp                       ;restore status to check carry bit
                plx                       ;restore slot number in x
                bcs     <a href="#Symcmd_cl">cmd_cl</a>            ;skip if enable
                stz     <a href="#Sympower2">power2</a>,x          ;CD is same as PWDTH=0, no CR
                bra     <a href="#Symcdone">cdone</a>             ;we're done here

;                       ;defidx2-$C1
<span id="Symcmd_cl">cmd_cl</span>          ldy     <a href="#SymLD186">LD186</a>,x           ;get y index into aux screenholes
                jsr     <a href="#Symr_getalt">r_getalt</a>          ;go get it from aux
                sta     <a href="#Sympower2">power2</a>,x          ;restore default PWDTH
                bra     <a href="#Symcdone">cdone</a>             ;we're done here

<span id="Symcmdz">cmdz</span>            plx                       ;Zero escape character
                stz     <a href="#Sympower2">power2</a>,x          ;And the width
                lda     #0
                jmp     <a href="#Symcmdz2">cmdz2</a>

; cmdcr equ D12F
; cmdn  equ D12F
                ply
                lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6       ;Get number inputted
                beq     <a href="#Symcmdi2">cmdi2</a>             ;skip if 0
                sta     <a href="#Sympower2">power2</a>,y          ;Update printer width
                .dd1    $f0               ;BEQ opcode to skip next byte (the PLY)
; cmdi equ D139
; cmdk equ D139
; cmkl equ D139
<span id="Symcmdi">cmdi</span>            ply
<span id="Symcmdi2">cmdi2</span>           lda     <a href="#Sympowerup">powerup</a>,y
                and     <a href="#Symmask1">mask1</a>,x           ;Mask off bit we'll change
                ora     <a href="#Symmask2">mask2</a>,x           ;Change it
                sta     <a href="#Sympowerup">powerup</a>,y         ;Back it goes
                tya                       ;Put slot back in x
                tax                       ;(via acc)
<span id="Symcdone2">cdone2</span>          jmp     <a href="#Symcdone">cdone</a>             ;Good byte

<span id="Symcmdp">cmdp</span>            dey                       ;Make y point to command reg
<span id="Symcmdd">cmdd</span>            lda     #$1f              ;Mask off high three bits
                sec                       ;C=1 means high 3 bits
                .dd1    $90               ;BCC opcode to skip next byte
<span id="Symcmdb">cmdb</span>            lda     #$f0              ;mask off lower 4 bits F0 = BNE
                clc                       ;F= will skip this if cmdp or cmdd
                and     <a href="#Symdata">data</a>,y            ;mask off bits being changed
                sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;Save it
                plx
                lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6       ;Get inputed number
                and     #$0f              ;Only lower nibble valid
                bcc     <a href="#Symnoshift">noshift</a>           ;If C=1 shift tto upper 3 bits

                asl     A
                asl     A
                asl     A
                asl     A
                asl     A
<span id="Symnoshift">noshift</span>         ora     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;Get the rest of the bits
                iny                       ;Put them in the ACIA
                bra     <a href="#Symcmdp2">cmdp2</a>             ;increment puts em away where they go.

<span id="Symcmds">cmds</span>            lda     <a href="#Symscmod">scmod</a>,y           ;Transmit a break
                pha                       ;Save current ACIA state
                ora     #$0c              ;Do the break
                sta     <a href="#Symscmod">scmod</a>,y
                lda     #233              ;For 233 ms
<span id="Symmswait">mswait</span>          ldx     #83               ;Wait 1 ms
<span id="Symmsloop">msloop</span>          pha                       ;((12*82)+11)+2+3=1000us
                pla
                dex
                bne     <a href="#Symmsloop">msloop</a>
                dec     A
                bne     <a href="#Symmswait">mswait</a>
                pla
                plx
<span id="Symcmdp2">cmdp2</span>           sta     <a href="#Symscmod">scmod</a>,y
<span id="SymLD186">LD186</span>           bra     <a href="#Symcdone2">cdone2</a>

<span id="Symcmdr">cmdr</span>            sta     <a href="#Symaddrm">addrm</a>,y           ;Reset the ACIA
                lda     <a href="#Symvfactv">vfactv</a>            ;Check if video firmware active
                asl     A                 ;Save it in C
                jsr     <a href="#Symswsthk2">swsthk2</a>           ;assume video firmware active
                bcc     <a href="#Symcmdq">cmdq</a>              ;branch if good guesser...
                jsr     <a href="#Symswzzqt2">swzzqt2</a>           ;Reset the hooks
<span id="Symcmdq">cmdq</span>            clc                       ;Quit terminal mode
                .dd1    $b0               ;BCS to skip next byte
<span id="Symcmdt">cmdt</span>            sec                       ;Into terminal mode
                plx                       ;Recover X
                jsr     <a href="#Symsetterm">setterm</a>
                bra     <a href="#Symcdone2">cdone2</a>

;                                       ;set/clear terminal mode
<span id="Symsetterm">setterm</span>         lda     <a href="#Symsermode">sermode</a>,x         ;Get terminal mode status
                bit     #$40              ;Z=1 if not in terminal mode
                bcc     <a href="#Symstclr">stclr</a>             ;Branch if clearing terminal mode
                bne     <a href="#Symstwasok">stwasok</a>           ;Was already set
                cpx     <a href="#Symkswh">kswh</a>              ;Are we in the input hooks
                bne     <a href="#Symstrts">strts</a>             ;Leaves C=1 if =
                ora     #$40              ;Set term mode bit
                ldy     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;Save what was in oldcur
                sty     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+2
                ldy     #<a href="#Symtermcur">termcur</a>          ;Get new cursor value
                bra     <a href="#Symstset">stset</a>

<span id="Symstclr">stclr</span>           .dd1    $f0               ;Branch if already clear
                .dd1    $0e
                .dd1    $29               ;Clear the bit
                .dd1    $bf
                .dd1    $ac               ;Restore the cursor
                .dd1    $7a
                .dd1    $06

<span id="Symstset">stset</span>           sta     <a href="#Symsermode">sermode</a>,x
                sty     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;Save cursor to be restored after command
                sty     <a href="#Symcursor">cursor</a>
<span id="Symstwasok">stwasok</span>         ldy     <a href="#Symdevno2">devno2</a>,x
                cli                       ;want to leave with interrupts active
                php
                sei                       ;but off while we twittle bits
                lda     <a href="#Symscmod">scmod</a>,y
                ora     #2                ;disable receiver interrupts if
                bcc     <a href="#Symcmdt2">cmdt2</a>             ; not in terminal mode
                and     #$fd              ;enable when in terminal mode
<span id="Symcmdt2">cmdt2</span>           sta     <a href="#Symscmod">scmod</a>,y
                lda     #0
                ror     A                 ;set kbd interrupts according to t-mode
                sta     <a href="#SymSCRNHOLE3">SCRNHOLE3</a>+2
                bpl     <a href="#Symcmdt3">cmdt3</a>             ;branch if leaving terminal mode
                stz     <a href="#SymSCRNHOLE2">SCRNHOLE2</a>+4       ; and ser buf...
                stz     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+4
                txa                       ;use x to enable serial buffering
<span id="Symcmdt3">cmdt3</span>           sta     <a href="#SymSCRNHOLE1">SCRNHOLE1</a>+4
                plp                       ;restore carry, enable interrupts.
<span id="Symflush">flush</span>           stx     <a href="#SymSCRNHOLE3">SCRNHOLE3</a>+4       ;Flush the type ahead buffer
                stx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+7
<span id="Symstrts">strts</span>           rts

;                       ;command routines'  lo bytes
<span id="Symcmdtable">cmdtable</span>        .dd1    &lt;<a href="#Symcmdi">cmdi</a>-1
                .dd1    &lt;<a href="#Symcmdk">cmdk</a>-1
                .dd1    &lt;<a href="#Symcmdl">cmdl</a>-1
                .dd1    &lt;<a href="#Symcmdn">cmdn</a>-1
                .dd1    &lt;<a href="#Symcmdcr">cmdcr</a>-1
                .dd1    &lt;<a href="#Symcmdb">cmdb</a>-1
                .dd1    &lt;<a href="#Symcmdd">cmdd</a>-1
                .dd1    &lt;<a href="#Symcmdp">cmdp</a>-1
                .dd1    &lt;<a href="#Symcmdq">cmdq</a>-1
                .dd1    &lt;<a href="#Symcmdr">cmdr</a>-1
                .dd1    &lt;<a href="#Symcmds">cmds</a>-1
                .dd1    &lt;<a href="#Symcmdt">cmdt</a>-1
                .dd1    &lt;<a href="#Symcmdz">cmdz</a>-1
; masks for:              I   K   L   N   CR  XE  XD  FE  FD  ME  MD
<span id="Symmask1">mask1</span>           .bulk   $7f,$bf,$bf,$7f,$ff,$df,$df,$ef,$ef,$f7,$f7
<span id="Symmask2">mask2</span>           .bulk   $80,$00,$40,$00,$00,$20,$00,$00,$10,$00,$08
<span id="Symcmdlist">cmdlist</span>         .str    “IKLN”
                .dd1    $0d               ;cr (part of cmdlist)
                .str    “BDPQRSTZ”
<span id="Symcmd2list">cmd2list</span>        .str    “LXFMC”           ;2-chr commands' first char

********************************************************************************
* R_GETALT is the same as GETALT in main rom.  Only the                        *
* location is different.                                                       *
********************************************************************************
<span id="Symr_getalt">r_getalt</span>        lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;save state of aux memory
                asl     A
                lda     <a href="#SymRD80COL">RD80COL</a>           ;and the 80STORE switch
                php
                sta     <a href="#SymCLR80COL">CLR80COL</a>          ;no 80STORE to get page 1
                sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;pop in the other half of RAM
                lda     $0478,y           ;read the desired byte
                plp                       ;and restore memory
                bcs     <a href="#Symr_getalt1">r_getalt1</a>
                sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>
<span id="Symr_getalt1">r_getalt1</span>       bpl     <a href="#Symr_getalt2">r_getalt2</a>
                sta     <a href="#SymSET80COL">SET80COL</a>
<span id="Symr_getalt2">r_getalt2</span>       rts

                .dd1    $03
                .dd1    $07
                .fill   439,$00

********************************************************************************
* BASICIN - input from basic                                                   *
*                                                                              *
* creates +XXXXX,+YYYYY,+SS                                                    *
* XXXXX = x position, YYYYY = y position, SS = status                          *
*       - = key pressed                                                        *
*       1 = button pressed                                                     *
*       2 = button just pressed                                                *
*       3 = button just released                                               *
*       4 = button not pressed                                                 *
********************************************************************************
<span id="Symbasicin">basicin</span>         sta     (<a href="#Symbasl">basl</a>),y          ;fix flashing char
                lda     #<a href="#Syminent">inent</a>            ;fix input entry
                sta     <a href="#Symkswl">kswl</a>
                lda     <a href="#SymKBD">KBD</a>               ;test the keyboard
                asl     A
                php                       ;save kbd and int stat for later
                sei                       ;no interrupts while getting position
                jsr     <a href="#Symx_mread">x_mread</a>
                ldy     #5                ;move x position into the buffer
                ldx     <a href="#Symmouxh">mouxh</a>
                lda     <a href="#Symmouxl">mouxl</a>
                jsr     <a href="#Symhextodec">hextodec</a>          ;convert it
                ldy     #12
                ldx     <a href="#Symmouyh">mouyh</a>
                lda     <a href="#Symmouyl">mouyl</a>
                jsr     <a href="#Symhextodec">hextodec</a>
                lda     <a href="#Symmoustat">moustat</a>
                rol     A
                rol     A
                rol     A
                and     #3
                eor     #3
                inc     A
                plp                       ;restore int &amp; kbd status
                ldy     #16
                jsr     <a href="#Symhexdec2">hexdec2</a>           ;x=0 from last div10
                ply
                ldx     #17               ;x = eol
                lda     #$8d              ;cr
<span id="Symputinbuf">putinbuf</span>        sta     <a href="#Syminbuf">inbuf</a>,x
                jmp     <a href="#Symswrts2">swrts2</a>            ;goback

********************************************************************************
* HEXTODEC - puts +0000, into the input buffer                                 *
* inputs: a = low byte of number                                               *
*         x = high byte of number                                              *
*         y = positions of one digit                                           *
********************************************************************************
<span id="Symhextodec">hextodec</span>        cpx     #$80              ;is it a negative number?
                bcc     <a href="#Symhexdec2">hexdec2</a>
                eor     #$ff              ;form two's complement
                adc     #0                ;c = 1 from compare
                pha                       ;save it
                txa
                eor     #$ff
                adc     #0
                tax
                pla
                sec
<span id="Symhexdec2">hexdec2</span>         sta     $0214             ;store the number to convert
                stx     $0215
                lda     #‘+’              ;store the sign in the buffer
                bcc     <a href="#Symhdpos2">hdpos2</a>
                lda     #‘-’
<span id="Symhdpos2">hdpos2</span>          pha                       ;save the sign
                lda     #‘,’              ;store a comma after the number
                sta     <a href="#Syminbuf">inbuf</a>+1,y
; 
; divide BINH,L by 10 and leave remainder in a
;                      ;#16+1
<span id="Symhdloop">hdloop</span>          ldx     #17               ;16 bits and first time to do nothing
                lda     #0
                clc                       ;c=0 so first ROL leaves a=0
<span id="Symdv10loop">dv10loop</span>        rol     A
                cmp     #10               ;a &gt;= 10?
                bcc     <a href="#Symdv10lt">dv10lt</a>            ;branch if &lt;
                sbc     #10               ;c = 1 from compare and is left set
<span id="Symdv10lt">dv10lt</span>          rol     $0214
                rol     $0215
                dex
                bne     <a href="#Symdv10loop">dv10loop</a>
                ora     #‘0’              ;make a ascii char
                sta     <a href="#Syminbuf">inbuf</a>,y
                dey
                beq     <a href="#Symhddone">hddone</a>            ;stop on 0,6,12
                cpy     #7
                beq     <a href="#Symhddone">hddone</a>
                cpy     #14
                bne     <a href="#Symhdloop">hdloop</a>
<span id="Symhddone">hddone</span>          pla                       ;get the sign
                sta     <a href="#Syminbuf">inbuf</a>,y
                rts

********************************************************************************
* These routines test all 128K ram.  All combinations of                       *
* switches applicable to the //c are tested and verified.                      *
*                                                                              *
* In the event of any failure, the diagnostic is halted. A message             *
* is written to screen memory indicating the source of the failure.            *
* When RAM fails the message is composed of "RAM ZP" (indicating               *
* failure detected in the first page of RAM) or "RAM" (meaning the             *
* other 63.75K), followed by a binary representation of the failing            *
* bits set to "1".  For example, "RAM   0 1 1 0 0 0 0 0" indicates             *
* that bits 5 and 6 were detected as failing. To represent                     *
* auxillary memory, a "*" symbol is printed preceeding the message.            *
*                                                                              *
* When the MMU or IOU fail, the message is simply "MMU" or "IOU".              *
* If the IOUDIS or DHIRES switch fails, the message is "GLU."                  *
*                                                                              *
* The test will run continiuously for as long as the Open and Closed           *
* Apple keys remain depressed (or no keyboard is connected) and no             *
* failures are encountered.  The message "System OK" will appear in            *
* the middle of the screen when a successful cycle has been run and            *
* either of the Apple keys are no longer depressed.  Another cycle             *
* may be initiated by pressing both Apple keys again while this                *
* message is on the screen.  To exit diagnostics, Control-Reset                *
* must be pressed without the Apple keys depressed.                            *
********************************************************************************
<span id="Symdiags">diags</span>           sta     <a href="#SymTXTCLR">TXTCLR</a>            ;text mode off
                sta     <a href="#Symioudsbl">ioudsbl</a>           ;Disable IOU
                sta     <a href="#SymSETAN3">SETAN3</a>+1          ;Double hires off
; 
; Test Zero-page, then all of memory.  Report errors when
; encountered.  Accumulator can be anything on entry.  All
; registers used, but no stack.  Addresses between $C000
; and $CFFFF are mapped to main $D000 bank.  Addresses
; between $C000 and $CFFF are mapped to main $D000 bank.
; 
<span id="SymTSTZPG">TSTZPG</span>          ldy     #4
                ldx     #0
<span id="Symzp1">zp1</span>             clc                       ;fill zero page with a pattern
                adc     <a href="#Symntbl">ntbl</a>,y
                sta     $00,x
                inx
                bne     <a href="#Symzp1">zp1</a>               ;after all bytes filled,
<span id="Symzp2">zp2</span>             clc                       ; ACC has original value again.
                adc     <a href="#Symntbl">ntbl</a>,y            ;so valuescan be tested
                cmp     $00,x
                bne     <a href="#SymZPERROR">ZPERROR</a>           ;branched if memory failed
                inx
                bne     <a href="#Symzp2">zp2</a>               ;loop until all 256 bytes tested
                ror     A                 ;change ACC so locations $FF will change
                bit     <a href="#Symrdvblbar">rdvblbar</a>          ; use RDVBL for a little randomness...
                bpl     <a href="#Symzp3">zp3</a>
                eor     #$a5
<span id="Symzp3">zp3</span>             dey                       ;use a different pattern now
                bpl     <a href="#Symzp1">zp1</a>               ;branch to retest with other value
                bmi     <a href="#SymTSTMEM2">TSTMEM2</a>           ;branch always

<span id="SymZPERROR">ZPERROR</span>         eor     $00,x             ;which bits are bad?
                clc                       ;indicate zero page failure
                jmp     <a href="#SymBADBITS">BADBITS</a>

<span id="SymTSTMEM2">TSTMEM2</span>         jmp     <a href="#SymTSTMEM">TSTMEM</a>            ;Off to the rest

<span id="Symzznm">zznm</span>            jsr     <a href="#Symswzzqt2">swzzqt2</a>           ;Get out of the hooks
                pla                       ;get junk off of stack
                ply
                pla
                lda     #$ff
                tax
<span id="Symzzloop">zzloop</span>          inx
                eor     <a href="#Symqtbl">qtbl</a>,x
                sta     <a href="#Syminbuf">inbuf</a>,x
                bpl     <a href="#Symzzloop">zzloop</a>
                jmp     <a href="#Symswrts2">swrts2</a>

<span id="Symqtbl">qtbl</span>            .bulk   $ad,$3b,$0a,$0b,$48,$77,$3e,$05
                .bulk   $00,$05,$08,$0c,$1e,$53,$65,$37
                .bulk   $1c,$07,$0c,$45,$62,$27,$00,$17
                .bulk   $1c,$07,$07,$05,$4b,$6d,$24,$02
                .bulk   $0e,$45,$61,$32,$18,$02,$07,$1d
                .bulk   $53,$6a,$2b,$0c,$08,$16,$53,$68
                .bulk   $3d,$06,$07,$1b,$01,$e3
                .fill   240,$00

********************************************************************************
* Initmouse - reset the  mouse                                                 *
*  Also clears all of the mouse holes                                          *
* note that ious access fires pdlstrb &amp; makes mouse happy                      *
********************************************************************************
<span id="Symi_nitmouse">i_nitmouse</span>      stz     <a href="#Symmoustat">moustat</a>           ;Clear status
                ldx     #$80
                ldy     #1
<span id="Symxrloop">xrloop</span>          stz     <a href="#Symminxl">minxl</a>,x           ;Minimum = $0000
                stz     <a href="#Symminxh">minxh</a>,x
                lda     #$ff              ;Maximum = $03FF
                sta     <a href="#Symmaxxl">maxxl</a>,x
                lda     #$03
                sta     <a href="#Symmaxxh">maxxh</a>,x
                ldx     #0
                dey
                bpl     <a href="#Symxrloop">xrloop</a>
                jsr     <a href="#Symx_mhome">x_mhome</a>           ;Clear the mouse holes
                lda     #0                ;Faill into SETMOU
********************************************************************************
* XSETMOU - Sets the mouse code to A                                           *
********************************************************************************
<span id="Symx_setmou">x_setmou</span>        tax
                jsr     <a href="#Symm__oveirq">m__oveirq</a>         ;Make sure interrupt vector is right
                txa                       ;Only x preserved by moveirq
                sta     <a href="#Symmoutemp">moutemp</a>
                lsr     A                 ;D0 = 1 if mouse active
                ora     <a href="#Symmoutemp">moutemp</a>           ;D2 = 1 if vbl active
                cmp     #$10              ;If &gt;=$10 then invalid mode
                bcs     <a href="#Symsminvalid">sminvalid</a>
                and     #5                ;Extract VBL &amp; Mouse
                beq     <a href="#Symxsoff">xsoff</a>             ;Turning it off?
                cli                       ;If not, ints active
<span id="Symxsoff">xsoff</span>           adc     #$55              ;Make iou byte C=0
********************************************************************************
*                                                                              *
* SETIOU - Sets the IOU interrupt modes to A                                   *
*  Inputs: A = bits to change                                                  *
*  D7 = Y int on falling edge                                                  *
*  D6 = Y int on rising edge                                                   *
*  D5 = X int on falling edge                                                  *
*  D4 = X int on rising edge                                                   *
*  D3 = Enable VBL int                                                         *
*  D2 = Disable VBL int                                                        *
*  D1 = Enable mouse int                                                       *
*  D0 = Disable mount int                                                      *
*                                                                              *
********************************************************************************
<span id="Symsetiou">setiou</span>          php
                sei                       ;Don't allow ints while iou enabled
                stx     <a href="#Symmoumode">moumode</a>
                sta     <a href="#Symiouenbl">iouenbl</a>           ;Enable iou access
                ldx     #8
<span id="Symsiloop">siloop</span>          dex
                asl     A                 ;Get a bit to check
                bcc     <a href="#Symsinoch">sinoch</a>            ;No change if C=0
                sta     <a href="#Symiou">iou</a>,x             ;Set it
<span id="Symsinoch">sinoch</span>          bne     <a href="#Symsiloop">siloop</a>            ;Any bits left in A?
                sta     <a href="#Symioudsbl">ioudsbl</a>           ;Turn off iou access
                plp
                clc
<span id="Symsminvalid">sminvalid</span>       rts

********************************************************************************
* XMHOME - Clears mouse position &amp; status                                      *
********************************************************************************
<span id="Symx_mhome">x_mhome</span>         ldx     #$80
                bra     <a href="#Symxmh2">xmh2</a>

<span id="Symxmhloop">xmhloop</span>         ldx     #0                ;Point mouse to upper left
<span id="Symxmh2">xmh2</span>            lda     <a href="#Symminxl">minxl</a>,x
                sta     <a href="#Symmouxl">mouxl</a>,x
                lda     <a href="#Symminxh">minxh</a>,x
                sta     <a href="#Symmouxh">mouxh</a>,x
                dex
                bpl     <a href="#Symxmhloop">xmhloop</a>
                bra     <a href="#Symxmcdone">xmcdone</a>

********************************************************************************
* XMCLEAR - Sets the mouse to 0,0                                              *
********************************************************************************
<span id="Symx_mclear">x_mclear</span>        stz     <a href="#Symmouxl">mouxl</a>
                stz     <a href="#Symmouxh">mouxh</a>
                stz     <a href="#Symmouyl">mouyl</a>
                stz     <a href="#Symmouyh">mouyh</a>
<span id="Symxmcdone">xmcdone</span>         stz     <a href="#Symmouarm">mouarm</a>
                clc
                rts

********************************************************************************
* XMREAD - Updates the screen holes                                            *
********************************************************************************
<span id="Symx_mread">x_mread</span>         lda     #<a href="#Symmovarm">movarm</a>           ;Has mouse moved?
                trb     <a href="#Symmoustat">moustat</a>           ;Clear moved bit in stat
                and     <a href="#Symmouarm">mouarm</a>
                trb     <a href="#Symmouarm">mouarm</a>            ;Clear arm bit
                bit     <a href="#Symmoumode">moumode</a>           ;If D7 = 1 leave butttons alone
                bmi     <a href="#Symxmrd2">xmrd2</a>
                bit     <a href="#Symmoubut">moubut</a>            ;Button pressed?
                bmi     <a href="#Symxrbut">xrbut</a>
                ora     #$80
<span id="Symxrbut">xrbut</span>           bit     <a href="#Symmoustat">moustat</a>           ;Pressed last time?
                bpl     <a href="#Symxrbut2">xrbut2</a>
                ora     #$40
<span id="Symxrbut2">xrbut2</span>          sta     <a href="#Symmoustat">moustat</a>
                clc
                rts

;                       ;Leave button bits alone
<span id="Symxmrd2">xmrd2</span>           ora     <a href="#Symmoustat">moustat</a>
                and     #$e0              ;Button bits
                bra     <a href="#Symxrbut2">xrbut2</a>

********************************************************************************
* XMCLAMP - Store new bounds                                                   *
*  Inputs A = 1 for Y, 0 for X axis                                            *
*    minl, minh, maxl, maxh = new bounds                                       *
********************************************************************************
<span id="Symx_mclamp">x_mclamp</span>        ror     A                 ;1 -&gt; 80
                ror     A
                and     #$80
                tax
                lda     <a href="#Symminl">minl</a>
                sta     <a href="#Symminxl">minxl</a>,x
                lda     <a href="#Symminh">minh</a>
                sta     <a href="#Symminxh">minxh</a>,x
                lda     <a href="#Symmaxl">maxl</a>
                sta     <a href="#Symmaxxl">maxxl</a>,x
                lda     <a href="#Symmaxh">maxh</a>
                sta     <a href="#Symmaxxh">maxxh</a>,x
                clc                       ;No error
                rts

********************************************************************************
* XMTSTINT - Checks mouse status bits                                          *
* Used for user mouser interrupt                                               *
********************************************************************************
<span id="Symx_mtstint">x_mtstint</span>       pha
                clc
                lda     #$0e
                and     <a href="#Symmoustat">moustat</a>
                bne     <a href="#Symnostat2">nostat2</a>
                sec
<span id="Symnostat2">nostat2</span>         pla
                rts

                .fill   306,$00
                .adrend ↑ $c3c6

********************************************************************************
* execution routines. these routines must begin in the same page               *
* **************************************************************************** *
*                                                                              *
* **************************************************************************** *
* EXECUTE - does command in command                                            *
*           inputs: a = command                                                *
********************************************************************************
<span id="Symexecute">execute</span>         sta     <a href="#SymA4L">A4L</a>
;                       ;#4+$C0
                ldy     #$c4
                sty     <a href="#Symsl_mslot">sl_mslot</a>
;                       ;#4+$10+$88
                ldx     #$c8
                stx     <a href="#Symsl_devno">sl_devno</a>          ;save command and hardware index
                lda     #0                ;clear error flag
                sta     <a href="#Symerror">error</a>
                jsr     <a href="#Symsl_format">sl_format</a>         ;do we need to format?
                ldy     <a href="#SymA4L">A4L</a>               ;get command
                lda     <a href="#Symparmtbl">parmtbl</a>,y         ;check parameter count
                bmi     <a href="#Symexec2">exec2</a>             ;if negative, no parm check
                cmp     <a href="#SymA4H">A4H</a>
                bne     <a href="#Sympzcnt">pzcnt</a>
<span id="Symexec2">exec2</span>           lda     #&gt;<a href="#Symxstatus">xstatus</a>         ;all entry points on same page
                bra     <a href="#Symexec3">exec3</a>             ;skip around the basic patch

                .dd1    $00               ;break handler will correct for this

<span id="Symexec3">exec3</span>           pha
                lda     <a href="#Symcmdtbl">cmdtbl</a>,y
                pha
                ldy     <a href="#Symsl_mslot">sl_mslot</a>
                ldx     <a href="#Symsl_devno">sl_devno</a>
                rts

<span id="Sympzcmd">pzcmd</span>           lda     #<a href="#Symbadcmd">badcmd</a>           ;invalid command
                bne     <a href="#Sympzcnt2">pzcnt2</a>

<span id="Sympzcnt">pzcnt</span>           lda     #<a href="#Symbadpcnt">badpcnt</a>
<span id="Sympzcnt2">pzcnt2</span>          sta     <a href="#Symerror">error</a>
<span id="Symiorts">iorts</span>           rts

<span id="Sympread2_z">pread2_z</span>        jmp     <a href="#Symsl_pread">sl_pread</a>          ;entry point in this page

<span id="Sympwrite2">pwrite2</span>         jmp     <a href="#Symsl_pwrite">sl_pwrite</a>         ;entry point in this page

<span id="Symdosconv2">dosconv2</span>        jmp     <a href="#Symdosconv">dosconv</a>           ;entry point in this page

<span id="Symxdiag">xdiag</span>           jmp     <a href="#Symxdiagz">xdiagz</a>            ;entry point in this page

********************************************************************************
* XSTATUS - ProDOS status call                                                 *
********************************************************************************
<span id="Symxstatus">xstatus</span>         lda     <a href="#Symnumbanks">numbanks</a>,y        ;size = # 64K banks / 2
                lsr     A
                sta     <a href="#Symyval">yval</a>
                lda     #0
                sta     <a href="#Symxval">xval</a>
                rts

********************************************************************************
* PSTAT0 - Status call for device 0                                            *
*          returns status block for call 0                                     *
*          1 0 0 0 0 0 0 0                                                     *
********************************************************************************
<span id="Sympstat0">pstat0</span>          lda     <a href="#Sympstat">pstat</a>             ;must be call 0
                bne     <a href="#Symstbad">stbad</a>             ;branch if bad
                sta     <a href="#Symmaxh">maxh</a>              ;set bytes read count
                ldy     #8
                sty     <a href="#Symxval">xval</a>
                dey
<span id="Symst01p">st01p</span>           sta     (<a href="#Symcompdata">compdata</a>),y      ;save out the 0s
                dey
                bne     <a href="#Symst01p">st01p</a>
                lda     #1
                sta     (<a href="#Symcompdata">compdata</a>),y
                rts

********************************************************************************
* PCNTL - control call                                                         *
*         call 0 (reset) is implemented for both devices                       *
********************************************************************************
<span id="Sympcntl">pcntl</span>           lda     <a href="#Sympstat">pstat</a>             ;call 0?
                beq     <a href="#Sympcntok">pcntok</a>
<span id="Symstbad">stbad</span>           lda     #<a href="#Symbadctl">badctl</a>           ;oops! bad status/control number
                sta     <a href="#Symerror">error</a>
<span id="Sympcntok">pcntok</span>          rts

********************************************************************************
* PSTATUS - status call for device 1                                           *
*           call 0,3 supported                                                 *
********************************************************************************
<span id="Symsl_pstatus">sl_pstatus</span>      lda     #4                ;number bytes for call 0
                ldx     <a href="#Sympstat">pstat</a>
                beq     <a href="#Sympst0">pst0</a>
                cpx     #3                ;is it #3?
                bne     <a href="#Symstbad">stbad</a>             ;branch if bad call
                lda     #25               ;# bytes for call 3
<span id="Sympst0">pst0</span>            sta     <a href="#Symxval">xval</a>
                ldx     #0
                stx     <a href="#Symyval">yval</a>
                tay
                dey
<span id="Sympstmov">pstmov</span>          lda     <a href="#Symstattbl">stattbl</a>,y         ;move the status info
                sta     (<a href="#Symcompdata">compdata</a>),y
                dey
                bpl     <a href="#Sympstmov">pstmov</a>
                ldy     <a href="#Symsl_mslot">sl_mslot</a>          ;get the size
                lda     <a href="#Symnumbanks">numbanks</a>,y
                lsr     A
                ldy     #2
                sta     (<a href="#Symcompdata">compdata</a>),y
                rts

********************************************************************************
* XREAD  - read a block                                                        *
* XWRITE - write a block                                                       *
*                                                                              *
* ProDOS read &amp; write are changed into Protocol converter read block           *
* and write block which are then changed into read &amp; write                     *
********************************************************************************
<span id="Symxread">xread</span>           bit     <a href="#Symiorts">iorts</a>             ;V = 1 for read
                .dd1    $50               ;VNC never taken
<span id="Symxwrite">xwrite</span>          clv                       ;V = 0 for write
; 
<span id="Symxrwcmn">xrwcmn</span>          lda     <a href="#Symblock">block</a>+1           ;move block &amp; buffer pointer
                sta     <a href="#Sympblock">pblock</a>+1
                lda     <a href="#Symlimit">limit</a>             ;be careful not to step
                sta     <a href="#Symvalue">value</a>             ;on our own toes
                lda     <a href="#Symbuffer">buffer</a>+1
                sta     <a href="#Sympbuff">pbuff</a>+1
                lda     <a href="#Symbuffer">buffer</a>
                sta     <a href="#Symcompdata">compdata</a>
                lda     #0
                sta     <a href="#Sympblock">pblock</a>+2
                beq     <a href="#Symxread2">xread2</a>            ;skip past other sev &amp; clv

********************************************************************************
* PRDBLK - Protocol converter block read                                       *
* PWRBLK - Protocol converter block write                                      *
********************************************************************************
<span id="Symprdblk">prdblk</span>          bit     <a href="#Symiorts">iorts</a>             ;V = 1 for read
                .dd1    $50               ;BVC never taken
<span id="Sympwrblk">pwrblk</span>          clv
<span id="Symxread2">xread2</span>          lda     <a href="#Symvalue">value</a>             ;convert block into 512 bytes
                asl     A
                sta     <a href="#Sympaddr">paddr</a>+1
                lda     <a href="#Sympblock">pblock</a>+1
                rol     A
                sta     <a href="#Sympaddr">paddr</a>+2
                bcs     <a href="#Symprbad2">prbad2</a>            ;if C=1 then bad address
                lda     <a href="#Sympblock">pblock</a>+2          ;third byte must b 0
                bne     <a href="#Symprbad2">prbad2</a>
                sta     <a href="#Sympaddr">paddr</a>             ;low byte of address is 0
                sta     <a href="#Sympcount">pcount</a>            ;count = $200
                lda     #2
                sta     <a href="#Sympcount">pcount</a>+1
                lda     <a href="#SymRDRAMWRT">RDRAMWRT</a>          ;fix aux bit in address
                bvs     <a href="#Symprdread">prdread</a>
                lda     <a href="#SymRDRAMRD">RDRAMRD</a>
<span id="Symprdread">prdread</span>         and     #$80              ;D7 = 1 if aux
                ora     <a href="#Sympaddr">paddr</a>+2
                sta     <a href="#Sympaddr">paddr</a>+2
                bvs     <a href="#Symprbad3">prbad3</a>            ;go do read
                jmp     <a href="#Symsl_pwrite">sl_pwrite</a>

<span id="Symprbad2">prbad2</span>          jmp     <a href="#Symprbad">prbad</a>

<span id="Symprbad3">prbad3</span>          jmp     <a href="#Symsl_pread">sl_pread</a>

********************************************************************************
* here is the rest of the boot code                                            *
* input: a = kswh, output: v = 1 if boot fails                                 *
* jumps to DOS patch if IN# from DOS                                           *
********************************************************************************
<span id="Symbool_sl">bool_sl</span>         ldy     #$c4              ;#4+$C0
                sty     <a href="#Symsl_mslot">sl_mslot</a>
;                       ;#4+$10+$88
                ldx     #$c8
                stx     <a href="#Symsl_devno">sl_devno</a>
                cmp     <a href="#Symsl_mslot">sl_mslot</a>          ;is it a IN#
                bne     <a href="#Symbtnodos">btnodos</a>
                lda     <a href="#Symproflag">proflag</a>           ;are we in DOS?
                beq     <a href="#Symbtnodos">btnodos</a>           ;0 = Pascal
                cmp     #$4c              ;JMP = ProDOS
                bne     <a href="#Symdospatch">dospatch</a>          ;go patch DOS
; 
<span id="Symbtnodos">btnodos</span>         stz     <a href="#Symbootbuf">bootbuf</a>+1         ;assume fail
; lda power2,y ;if power up bytes not set, don't boot
; eor #$A5
; cmp powerup,y
                lda     <a href="#Sympowerup">powerup</a>,y
                cmp     #$a5
                bne     <a href="#Symbtfail">btfail</a>
                ldy     #3
<span id="Symbtmv">btmv</span>            lda     <a href="#Symbtcmd">btcmd</a>,y
                sta     <a href="#Symbuffer">buffer</a>,y
                dey
                bpl     <a href="#Symbtmv">btmv</a>
                ldy     <a href="#Symsl_mslot">sl_mslot</a>
                jsr     <a href="#Symxread">xread</a>             ;go read the block and return
<span id="Symbtfail">btfail</span>          rts

<span id="Symbtcmd">btcmd</span>           .dd2    $0800
                .dd2    $0000             ;read in block 0 @ $800

********************************************************************************
* DOSPATCH - patches rwts to jump to us                                        *
********************************************************************************
<span id="Symdospatch">dospatch</span>        lda     #$4c              ;JMP opcode
                sta     <a href="#Symrwts">rwts</a>
                lda     #$d1
                sta     <a href="#Symrwts">rwts</a>+1            ;make page 3 vector point to us
                sty     <a href="#Symrwts">rwts</a>+2            ;Y = Cn
                lda     #$c3              ;patch out init command
                sta     <a href="#Symdosinit">dosinit</a>
                lda     #$a6
                sta     <a href="#Symdosinit">dosinit</a>+1
                pla                       ;pop off return address
                pla
; 
                plx
                inc     $c000,x           ;restore language card
                plx                       ;restore real x
                pla
                pla
                ldx     #0
                lda     #$98              ;return a control-X
                jmp     <a href="#Symswrts2">swrts2</a>            ;switch rom bank and return

<span id="Symdcrts">dcrts</span>           rts

********************************************************************************
* DOSCONV - changes DOS command into ours                                      *
* output: command table in zp Y = command                                      *
********************************************************************************
<span id="Symdosconv">dosconv</span>         ldy     #<a href="#Symibdrvn">ibdrvn</a>           ;get drive 1 or 2
                lda     (<a href="#Symiobpl">iobpl</a>),y
                cmp     #1                ;only 1 valid
                beq     <a href="#Symdcl">dcl</a>
<span id="Symdcerr">dcerr</span>           jmp     <a href="#Sympzcmd">pzcmd</a>             ;bad drive number

<span id="Symdcl">dcl</span>             ldy     #<a href="#Symibtrk">ibtrk</a>            ;get track &amp; sector
                lda     (<a href="#Symiobpl">iobpl</a>),y         ;addr = 00000TTT TTTSSSSS 00000000
                lsr     A
                ror     <a href="#Sympaddr">paddr</a>+1
                lsr     A
                ror     <a href="#Sympaddr">paddr</a>+1
                lsr     A
                sta     <a href="#Sympaddr">paddr</a>+2
                lda     <a href="#Sympaddr">paddr</a>+1
                ror     A
                and     #$e0
                iny
                ora     (<a href="#Symiobpl">iobpl</a>),y         ;or in sector
                sta     <a href="#Sympaddr">paddr</a>+1
                ldy     #<a href="#Symibbufp">ibbufp</a>           ;get pointer to user's buffer
                lda     (<a href="#Symiobpl">iobpl</a>),y
                sta     <a href="#Symcompdata">compdata</a>
                iny
                lda     (<a href="#Symiobpl">iobpl</a>),y
                sta     <a href="#Sympbuff">pbuff</a>+1
                ldy     #<a href="#Symibcmd">ibcmd</a>            ;get command
                lda     (<a href="#Symiobpl">iobpl</a>),y
                beq     <a href="#Symdcrts">dcrts</a>             ;0 = null = do nothing
                and     #3
                beq     <a href="#Symdcerr">dcerr</a>             ;4 = format is an error
                ora     #17               ;1 -&gt; 17, 2-&gt; 19
                tay                       ;Y = command
                ldx     #0
                stx     <a href="#Sympcount">pcount</a>            ;count = $100 bytes
                stx     <a href="#Sympaddr">paddr</a>
                inx
                stx     <a href="#Sympcount">pcount</a>+1
                jmp     <a href="#Symexec2">exec2</a>

********************************************************************************
* TESTSIZE - determines ramdisk size nondestructively                          *
* Inputs: Y = mslot X = devno                                                  *
********************************************************************************
<span id="Symtestsize">testsize</span>        lda     #0                ;Set address reg
                sta     <a href="#Symaddrl">addrl</a>,x
                sta     <a href="#Symaddrm">addrm</a>,x
                lda     #$10              ;Start at 1 meg and go down
                sec
<span id="Symtsloop">tsloop</span>          sbc     #1                ;Move down a bank
                sta     <a href="#Symscmod">scmod</a>,x
                lda     <a href="#Symdata">data</a>,x            ;Save the data that is there
                pha
                dec     <a href="#Symaddrl">addrl</a>,x           ;Fix address
                lda     #$a5              ;Store something there
                sta     <a href="#Symdata">data</a>,x
                dec     <a href="#Symaddrl">addrl</a>,x
                eor     <a href="#Symdata">data</a>,x            ;0 if the data is there
                dec     <a href="#Symaddrl">addrl</a>,x
                cmp     #1                ;C = 0 if data ok
                pla
                sta     <a href="#Symdata">data</a>,x            ;Restore what was there
                lda     <a href="#Symscmod">scmod</a>,x
                and     #$0f              ;Only lower 4 bits valid
                beq     <a href="#Symtsnoram">tsnoram</a>           ;No ram somehow!!!
                bcs     <a href="#Symtsloop">tsloop</a>            ;Loop until we find a bank
                adc     #1                ;C = 0 from compare
<span id="Symtsnoram">tsnoram</span>         sta     <a href="#Symnumbanks">numbanks</a>,y
                lsr     A                 ;Sizetemp = &lt; block count
                sta     <a href="#Symsizetemp">sizetemp</a>
                rts

********************************************************************************
* Routines for making a directory on the disk                                  *
* *******************************************                                  *
*                                                                              *
* Format - Tests for powerup and puts catalog on the disk if needed            *
* Inputs: Y = mslot X = devno                                                  *
********************************************************************************
<span id="Symsl_format">sl_format</span>       ldy     <a href="#Symsl_mslot">sl_mslot</a>
; lda power2,y ; Is power2 eor powerup = A5
; ero #$A5
; cmp powerup, y
; beq fmtdone
; sta powerup, y
                lda     #$a5              ;get power up value
                cmp     <a href="#Sympowerup">powerup</a>,y         ;is it = to the slinky power up byte?
                beq     <a href="#Symfmtdone">fmtdone</a>           ;skip if yes
                sta     <a href="#Sympowerup">powerup</a>,y         ;it's not, but it's set now
; 
; If all screen holes spaces, someone might have cleared
; the screen wrong so we won't reformat
                cmp     #$05              ;;Space eor $A5?
;                       ;Z = 1 if all spaces
<span id="Symfmnosp">fmnosp</span>          php
                jsr     <a href="#Symtestsize">testsize</a>
                plp
                beq     <a href="#Symfmtdone">fmtdone</a>
                lda     <a href="#Symproflag">proflag</a>           ;What type of catalog?
                beq     <a href="#Symfmpas">fmpas</a>
                cmp     #$4c              ;JMP if ProDOS
                bne     <a href="#Symfmdos">fmdos</a>
                ldy     #&lt;<a href="#Symcattbl">cattbl</a>+88       ;Do a ProDOS catalog
                jsr     <a href="#Symmakecat">makecat</a>           ;Put in all but bit map
                lda     #$01              ;Blocks 0-6 busy
<span id="Symfmpmap1">fmpmap1</span>         ldy     #32               ;32 FFs for each $100 blocks
<span id="Symfmpmap2">fmpmap2</span>         sta     <a href="#Symdata">data</a>,x
                ora     #$ff              ;Rest are FFs
                dey
                bne     <a href="#Symfmpmap2">fmpmap2</a>
                dec     <a href="#Symsizetemp">sizetemp</a>
                bne     <a href="#Symfmpmap1">fmpmap1</a>
<span id="Symfmtdone">fmtdone</span>         rts

; Do a pascal catalog
<span id="Symfmpas">fmpas</span>           ldy     #<a href="#Sympascat">pascat</a>
                jsr     <a href="#Symmakecat">makecat</a>
                rts

; Do a DOS catalog
<span id="Symfmdos">fmdos</span>           ldy     #<a href="#Symdoscat">doscat</a>
                jsr     <a href="#Symmakecat">makecat</a>
                lda     #$44              ;Point to track 3 bitmap
                sta     <a href="#Symaddrl">addrl</a>,x           ;Addrl = 0 from makecat
                lda     <a href="#Symsizetemp">sizetemp</a>          ;Check if at least 512K
                ldy     #114              ;Assume 256K
                cmp     #4                ;At leaste $400 blocks
                bcc     <a href="#Symfmddmap">fmddmap</a>
                ldy     #186              ;Make 400K volume
<span id="Symfmddmap">fmddmap</span>         lda     <a href="#Symaddrl">addrl</a>,x           ;Don't free catalog
                cmp     #$7c              ;Track $11?
                bne     <a href="#Symfmdok">fmdok</a>
                lda     #$7e              ;Skip first 16 sectors
                sta     <a href="#Symaddrl">addrl</a>,x           ;7C -&gt; 7E so no false carry
<span id="Symfmdok">fmdok</span>           lda     #$ff
                sta     <a href="#Symdata">data</a>,x
                dey
                bne     <a href="#Symfmddmap">fmddmap</a>
                rts

********************************************************************************
* MAKECAT - Creates a catalog                                                  *
*  Inputs: X = index into catalog tables                                       *
*                                                                              *
********************************************************************************
<span id="Symmakecat">makecat</span>         lda     #0                ;First bank is 0
                sta     <a href="#Symaddrl">addrl</a>,x           ;Start at 0
                sta     <a href="#Symaddrm">addrm</a>,x
                sta     <a href="#Symscmod">scmod</a>,x
<span id="Symmcboot">mcboot</span>          sta     <a href="#Symdata">data</a>,x            ;Zero out first 8 blocks
                lda     <a href="#Symaddrm">addrm</a>,x           ;Loop until $400
                and     #$f0              ;A = 0 if &lt; $1000
                beq     <a href="#Symmcboot">mcboot</a>            ;Leaves us pointing at $1000 (block 8)
                lda     #4                ;Point to $400 (block 2)
                sta     <a href="#Symaddrm">addrm</a>,x
<span id="Symmcbyte">mcbyte</span>          iny
                lda     <a href="#Symcattbl">cattbl</a>,y          ;Get next byte from the table
                cmp     #<a href="#Symzers">zers</a>             ;Zeros flag?
                beq     <a href="#Symmc0">mc0</a>
                cmp     #<a href="#Symskpfe">skpfe</a>            ;$FE zeros?
                beq     <a href="#Symmcfe">mcfe</a>
                cmp     #<a href="#Symsizeflg">sizeflg</a>          ;Block size?
                bne     <a href="#Symmcntsz">mcntsz</a>
                lda     <a href="#Symsizetemp">sizetemp</a>          ;Get &lt;# blocks
                bne     <a href="#Symmcntnm">mcntnm</a>            ;better not be 0
<span id="Symmcntsz">mcntsz</span>          cmp     #<a href="#Symnameflag">nameflag</a>         ;Slot # for name?
                bne     <a href="#Symmcntnm">mcntnm</a>
                lda     <a href="#Symsl_mslot">sl_mslot</a>          ;Get $Cn
                eor     #$f0              ;$Cn -&gt; $3n
<span id="Symmcntnm">mcntnm</span>          sta     <a href="#Symdata">data</a>,x            ;Stick byte in catalog
                jmp     <a href="#Symmcbyte">mcbyte</a>            ;Go to next byte

<span id="Symmc0">mc0</span>             iny
                lda     <a href="#Symcattbl">cattbl</a>,y          ;Get # zeros
                beq     <a href="#Symmcadd">mcadd</a>             ;If 0, it's an address
<span id="Symmcfe">mcfe</span>            pha                       ;Save count
                lda     #0
                sta     <a href="#Symdata">data</a>,x
                pla
                sec
                sbc     #1
                bne     <a href="#Symmcfe">mcfe</a>
                beq     <a href="#Symmcbyte">mcbyte</a>            ;Always taken

<span id="Symmcadd2">mcadd2</span>          sta     <a href="#Symdata">data</a>,x            ;Store a 0
<span id="Symmcadd">mcadd</span>           cmp     <a href="#Symaddrl">addrl</a>,x           ;Finish off current page
                bne     <a href="#Symmcadd2">mcadd2</a>
                iny
                lda     <a href="#Symcattbl">cattbl</a>,y          ;Get new address
                beq     <a href="#Symmcdone">mcdone</a>            ;If 0, all done
                sta     <a href="#Symaddrm">addrm</a>,x
                iny
                lda     <a href="#Symcattbl">cattbl</a>,y
                sta     <a href="#Symscmod">scmod</a>,x
                jmp     <a href="#Symmcbyte">mcbyte</a>

<span id="Symmcdone">mcdone</span>          rts

********************************************************************************
* The catalog tables                                                           *
* These tables contain the catalog info compacted                              *
* in a scheme so clever it probably doesn't save                               *
* me anything                                                                  *
* For each bank:                                                               *
*  The first byte is the bank #. 0 = done                                      *
*  zers,n = skip n 0s                                                          *
*  zers,0 = fill rest of page with 0s and get new address                      *
*  zers,0,0 = All done                                                         *
*  skpfe = fill $FE 0s                                                         *
*  nameflg = replace with ascii slot #                                         *
*  sizeflg = replace with &lt; block size                                         *
********************************************************************************
<span id="Symcattbl">cattbl</span>          .dd2    0                 ;Previous pointer
                .dd2    3                 ;Next block
                .dd1    $f4               ;Storage type
; daac, daad, daaf, form asc 'RAM'
                .str    “RAM”
                .dd1    <a href="#Symnameflag">nameflag</a>
                .dd1    <a href="#Symzers">zers</a>
                .dd1    $19
                .bulk   $c3,$27,$0d
                .dd2    0
                .dd2    6                 ;Bitmap pointer
                .dd1    0                 ;Number of blocks
                .dd1    <a href="#Symsizeflg">sizeflg</a>
                .dd1    <a href="#Symzers">zers</a>
                .dd1    $d7
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd2    2                 ;Block 3 $600
                .dd2    4
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd2    3                 ;Block 4 $800
                .dd2    5
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd2    4                 ;Block 5 $A00
                .dd1    $00               ;Get into second page
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    <a href="#Symzers">zers</a>              ;All done left at block 6
                .bulk   $00,$00,$00,$00,$00
; 
                .dd1    <a href="#Symzers">zers</a>              ;Trk $11 Sec 0 = $022000
                .bulk   $00,$20,$02
                .dd1    2                 ;Sec 0 = VTOC
                .bulk   $11,$0f           ;Pointer to catalog
                .dd1    $04               ;Dos release
                .bulk   $00,$00           ;Unused
                .dd1    $fb               ;Volume number
                .dd1    <a href="#Symzers">zers</a>
                .dd1    $20
                .dd1    $7a               ;TS pairs in TS list
                .dd1    <a href="#Symzers">zers</a>
                .dd1    8
                .bulk   $ff,$ff,$ff,$ff   ;Allocation mask
                .dd1    $32               ;# Tracks
                .dd1    $20               ;# Sectors
                .dd2    $0100             ;# Bytes per sector
                .dd1    <a href="#Symzers">zers</a>
                .dd1    $cb
                .dd1    <a href="#Symskpfe">skpfe</a>             ;Next cat sector pointer
                .dd1    $11
                .dd1    $01
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $02
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $03
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $04
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $05
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $06
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $07
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $08
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $09
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $0a
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $0b
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $0c
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $0d
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    $11
                .dd1    $0e
                .dd1    <a href="#Symskpfe">skpfe</a>
                .dd1    <a href="#Symzers">zers</a>              ;Leave pointing at VTOC
                .bulk   $00,$20,$02
                .dd1    <a href="#Symzers">zers</a>              ;All done
                .bulk   $00,$00
; 
                .bulk   $00,$00
                .dd1    $06
                .dd1    <a href="#Symzers">zers</a>
                .dd1    $03
                .dd1    $04
                .str    “RAM”
                .dd1    <a href="#Symnameflag">nameflag</a>
                .dd1    <a href="#Symzers">zers</a>
                .dd1    $04
                .dd1    <a href="#Symsizeflg">sizeflg</a>
                .dd1    <a href="#Symzers">zers</a>
                .bulk   $00,$00

********************************************************************************
* XDIAGZ - Moves the slinky diagnostic code from $DC00 - $DFFF to              *
* main ram starting at $2000 and jumps to $2000                                *
********************************************************************************
<span id="Symxdiagz">xdiagz</span>          ldx     #0
<span id="Symxdloop">xdloop</span>          lda     <a href="#Symdiagcode">diagcode</a>,x        ;move the code
                sta     <a href="#SymStartTest">StartTest</a>,x
                lda     <a href="#Symdiagcode">diagcode</a>+$100,x
                sta     <a href="#Symdiagdest">diagdest</a>+$100,x
                lda     <a href="#Symdiagcode">diagcode</a>+$200,x
                sta     <a href="#Symdiagdest">diagdest</a>+$200,x
                lda     <a href="#Symdiagcode">diagcode</a>+$300,x
                sta     <a href="#Symdiagdest">diagdest</a>+$300,x
                inx
                bne     <a href="#Symxdloop">xdloop</a>
                ldx     <a href="#Symsl_devno">sl_devno</a>          ;get device number
                lda     #&gt;<a href="#Symdiagstart">diagstart</a>       ;put start address on stack
                pha
                lda     #&lt;<a href="#Symdiagstart">diagstart</a>
                pha
********************************************************************************
* switch the main rom back in and go to the diagnostics via return             *
********************************************************************************
                jmp     <a href="#Symswrts2">swrts2</a>

                .fill   167,$00

                .addrs  $2000
• Empty variable table

<span id="SymStartTest">StartTest</span>       lda     #$00
                sta     <a href="#Symloopcount">loopcount</a>
                sta     <a href="#Symloopcount">loopcount</a>+1
                sta     <a href="#Sympowerup">powerup</a>-$280,y
                sta     <a href="#Sympower2">power2</a>,y
                lda     <a href="#Symnumbanks">numbanks</a>,y
                and     #$0f
                sta     <a href="#Symlimit">limit</a>
                jsr     <a href="#Symhome">home</a>
                lda     #8
; 
; "MEMORY CARD TEST&lt;CR&gt;ESC TO EXIT&lt;CR&gt;TEST WILL TAKE 
; 
                jsr     <a href="#SymPrint">Print</a>
                lda     <a href="#Symlimit">limit</a>
                lsr     A
                lsr     A
                pha
                ora     #4
                jsr     <a href="#SymPrint">Print</a>
                lda     #9
                jsr     <a href="#SymPrint">Print</a>
                pla
                jsr     <a href="#SymPrint">Print</a>
                jsr     <a href="#Symcrout">crout</a>
; 
; read &amp; write to address register
<span id="SymAddressTest">AddressTest</span>     lda     #5
                sta     <a href="#Symcv">cv</a>
                jsr     <a href="#Symcrout">crout</a>
                lda     #$10
                jsr     <a href="#SymPrint">Print</a>
                lda     <a href="#Symloopcount">loopcount</a>+1
                jsr     <a href="#Symprbyte">prbyte</a>
                lda     <a href="#Symloopcount">loopcount</a>
                jsr     <a href="#Symprbyte">prbyte</a>
                jsr     <a href="#SymNxtLine">NxtLine</a>
                lda     #1
                sta     <a href="#Symtestnum">testnum</a>
                ldy     #5
<span id="Symat1">at1</span>             lda     <a href="#SymPatterns">Patterns</a>,y
                jsr     <a href="#Symsetaddr">setaddr</a>
                cmp     <a href="#Symaddrl">addrl</a>,x
                bne     <a href="#Symatf">atf</a>
                cmp     <a href="#Symaddrm">addrm</a>,x
                bne     <a href="#Symatf">atf</a>
                ora     #$f0
                cmp     <a href="#Symaddrh">addrh</a>,x
                bne     <a href="#Symatf">atf</a>
                dey
                bpl     <a href="#Symat1">at1</a>
                bmi     <a href="#SymRollOverTest">RollOverTest</a>

<span id="Symatf">atf</span>             jmp     <a href="#SymFail">Fail</a>

<span id="SymRollOverTest">RollOverTest</span>    inc     <a href="#Symtestnum">testnum</a>
                dec     <a href="#Symaddrl">addrl</a>,x
                lda     <a href="#Symdata">data</a>,x
                sta     <a href="#Symdata">data</a>,x
                lda     <a href="#Symaddrh">addrh</a>,x
                and     #$0f
                ora     <a href="#Symaddrm">addrm</a>,x
                ora     <a href="#Symaddrl">addrl</a>,x
                beq     <a href="#SymAddBusTest">AddBusTest</a>
                jmp     <a href="#SymFail">Fail</a>

; *****************************************
; *
; * Walk a 1 through the address registers to test for bus shorts
; * assumes addresses = 0 from previous test
; *
; *****************************************
; 
; check for address buss shorts
<span id="SymAddBusTest">AddBusTest</span>      inc     <a href="#Symtestnum">testnum</a>           ;Test 3
                lda     #$01
                sta     <a href="#Symcompdata">compdata</a>
                txa                       ;Make pointer to addrl
                clc
                adc     #&lt;<a href="#Symaddrl">addrl</a>
                sta     <a href="#Symmptr">mptr</a>
                lda     #$c0
                sta     <a href="#Symmptr">mptr</a>+1
                lda     <a href="#Symlimit">limit</a>             ;How many bits used in high address?
                beq     <a href="#Symab1">ab1</a>               ;If 1M then test D3210
                cmp     #$0c              ;If 768K then test D3210
                bne     <a href="#Symab2">ab2</a>
<span id="Symab1">ab1</span>             lda     #$10
<span id="Symab2">ab2</span>             lsr     A                 ;If 512K then test D210 if 256K then D10
                pha                       ; Save it for later
                ldy     #2                ;Walk a one thru high med and low addresses
<span id="Symab3">ab3</span>             pha
                jsr     <a href="#Symclraddr">clraddr</a>           ;Clear address in case of false carries
                pla
                sta     (<a href="#Symmptr">mptr</a>),y          ;Store pattern in address
                pha
                lda     <a href="#Symcompdata">compdata</a>          ;get value to store
                sta     <a href="#Symdata">data</a>,x
                inc     <a href="#Symcompdata">compdata</a>          ;Each address gets a different value
                pla                       ; Get pattern back
                lsr     A                 ;Move the 1 over. $80 -&gt; $40 etc.
                bne     <a href="#Symab3">ab3</a>               ;Until all bits tested
                sta     (<a href="#Symmptr">mptr</a>),y          ;Zero out current byte
                ror     A                 ;0 -&gt; $80
                dey
                bpl     <a href="#Symab3">ab3</a>               ;Loop through all 3 address registers
                lda     #1                ;Now read em all back
                sta     <a href="#Symcompdata">compdata</a>
                pla                       ; Get start value for high byte
                ldy     #2
<span id="Symab4">ab4</span>             pha
                jsr     <a href="#Symclraddr">clraddr</a>           ;Clear address in case of false carry
                pla
                sta     (<a href="#Symmptr">mptr</a>),y          ;Set address
                sta     <a href="#Symvalue">value</a>             ;Don't pha since we might abort
                lda     <a href="#Symdata">data</a>,x
                cmp     <a href="#Symcompdata">compdata</a>          ;Right data?
                bne     <a href="#SymabFail">abFail</a>
                inc     <a href="#Symcompdata">compdata</a>
                lda     <a href="#Symvalue">value</a>
                lsr     A
                bne     <a href="#Symab4">ab4</a>
                sta     (<a href="#Symmptr">mptr</a>),y
                ror     A                 ;0 -&gt; $80
                dey
                bpl     <a href="#Symab4">ab4</a>
                bmi     <a href="#SymClearTest">ClearTest</a>

<span id="SymabFail">abFail</span>          jmp     <a href="#SymFail">Fail</a>

; ****************************************************************
; * 
; ****************************************************************
;                                           ;see if all locations clear to zero
<span id="SymClearTest">ClearTest</span>       jsr     <a href="#Symclraddr">clraddr</a>           ;Set address and A to 0
;                            ;Loop &amp; see if all locations fill to ones
<span id="SymFillTest">FillTest</span>        inc     <a href="#Symtestnum">testnum</a>           ;Test 4 = 00s.  Test 5 = FFs
                sta     <a href="#Symcompdata">compdata</a>          ;value to fill RAM with
<span id="Symf1">f1</span>              lda     <a href="#Symcompdata">compdata</a>
                sta     <a href="#Symdata">data</a>,x            ;write data out
                sta     <a href="#Symdata">data</a>,x
                sta     <a href="#Symdata">data</a>,x
                sta     <a href="#Symdata">data</a>,x
                lda     <a href="#Symaddrl">addrl</a>,x
                bne     <a href="#Symf1">f1</a>
                ora     <a href="#Symaddrm">addrm</a>,x           ;are addrl &amp; addrm both zero?
                bne     <a href="#Symf1">f1</a>                ;no, keep going
                jsr     <a href="#SymPrDot">PrDot</a>             ;Z = 1 if done
                bne     <a href="#Symf1">f1</a>                ;no, keep going
                jsr     <a href="#SymNxtLine">NxtLine</a>           ;Go to next line and clear address
<span id="Symcp1">cp1</span>             lda     <a href="#Symdata">data</a>,x            ;read data back
                cmp     <a href="#Symcompdata">compdata</a>
                bne     <a href="#SymabFail">abFail</a>            ;Failed if ne
                lda     <a href="#Symdata">data</a>,x            ;do 2 per loop for speed
                cmp     <a href="#Symcompdata">compdata</a>
                bne     <a href="#SymabFail">abFail</a>
                lda     <a href="#Symaddrl">addrl</a>,x
                bne     <a href="#Symcp1">cp1</a>
                ora     <a href="#Symaddrm">addrm</a>,x           ;are addrl &amp; addrm both zero?
                bne     <a href="#Symcp1">cp1</a>               ;no, keep going
                jsr     <a href="#SymPrDot">PrDot</a>             ;Z = 1 if done
                bne     <a href="#Symcp1">cp1</a>               ;no, keep going
                jsr     <a href="#SymNxtLine">NxtLine</a>           ;Go to next line and clear address
                lda     <a href="#Symcompdata">compdata</a>
                eor     #$ff              ;0 -&gt; FF
                bne     <a href="#SymFillTest">FillTest</a>
;                                           ;each byte gets computed value
<span id="SymComputed">Computed</span>        inc     <a href="#Symtestnum">testnum</a>           ;Test 6
                lda     #$55              ;Starting data pattern
                sta     <a href="#Symcompdata">compdata</a>          ;Address left at 0 from last test
<span id="Symc1">c1</span>              jsr     <a href="#Symgetvalue">getvalue</a>          ;Value = addrm + addrh + $55. A = 0
<span id="Symc2">c2</span>              clc
                adc     <a href="#Symvalue">value</a>
                adc     <a href="#Symcompdata">compdata</a>
                sta     <a href="#Symdata">data</a>,x
                sta     <a href="#Symcompdata">compdata</a>          ;Save for next add
                lda     <a href="#Symaddrl">addrl</a>,x
                bne     <a href="#Symc2">c2</a>
                lda     <a href="#Symaddrm">addrm</a>,x           ;Time to print a dot?
                bne     <a href="#Symc1">c1</a>
                jsr     <a href="#SymPrDot">PrDot</a>             ;Z = 1 if done
                bne     <a href="#Symc1">c1</a>
                jsr     <a href="#SymNxtLine">NxtLine</a>           ;Go to next line and clear address
                lda     #$55              ;starting data pattern
                sta     <a href="#Symcompdata">compdata</a>
<span id="Symc3">c3</span>              jsr     <a href="#Symgetvalue">getvalue</a>          ;Now read em back
<span id="Symc4">c4</span>              clc
                adc     <a href="#Symvalue">value</a>
                adc     <a href="#Symcompdata">compdata</a>
                sta     <a href="#Symcompdata">compdata</a>
                lda     <a href="#Symdata">data</a>,x
                cmp     <a href="#Symcompdata">compdata</a>          ;Is it right?
                bne     <a href="#SymFail">Fail</a>
                lda     <a href="#Symaddrl">addrl</a>,x
                bne     <a href="#Symc4">c4</a>
                lda     <a href="#Symaddrm">addrm</a>,x           ;Time to print a dot?
                bne     <a href="#Symc3">c3</a>
                jsr     <a href="#SymPrDot">PrDot</a>             ;Z = 1 if done
                bne     <a href="#Symc3">c3</a>
; 
; pased all the tests
<span id="SymPass">Pass</span>            lda     #$0b
                jsr     <a href="#SymPrint">Print</a>             ;"CARD OK"
                sed
                lda     <a href="#Symloopcount">loopcount</a>
                clc
                adc     #1
                sta     <a href="#Symloopcount">loopcount</a>
                lda     <a href="#Symloopcount">loopcount</a>+1
                adc     #0
                sta     <a href="#Symloopcount">loopcount</a>+1
                cld
                jmp     <a href="#SymAddressTest">AddressTest</a>       ;loop until first failure

; display failure message
<span id="SymFail">Fail</span>            pha                       ; save actual data
                jsr     <a href="#Symclreop">clreop</a>
                lda     #$0a
                jsr     <a href="#SymPrint">Print</a>             ;"CARD FAILED!&lt;CR&gt;"
                lda     <a href="#Symtestnum">testnum</a>
                cmp     #3
                bcs     <a href="#SymDataErr">DataErr</a>           ;not an addressing problem
                pla                       ; there is no failing data really
                lda     #$0c
                jsr     <a href="#SymPrint">Print</a>             ;"ADDRESS ERROR"
                jmp     <a href="#SymErrCommon">ErrCommon</a>

<span id="SymDataErr">DataErr</span>         lda     #$0d
                jsr     <a href="#SymPrint">Print</a>             ;"DATA ERROR "
                sec
                lda     <a href="#Symaddrl">addrl</a>,x
                sbc     #1                ;set back to actaul failing value
                pha
                lda     <a href="#Symaddrm">addrm</a>,x
                sbc     #0                ;propagate borrows (if any)
                pha
                lda     <a href="#Symscmod">scmod</a>,x
                and     #$0f              ;mask off high 4 bits
                sbc     #0
                jsr     <a href="#Symprbyte">prbyte</a>            ;print as two hex digits
                pla
                jsr     <a href="#Symprbyte">prbyte</a>            ;print addrm as two hex digits
                pla
                jsr     <a href="#Symprbyte">prbyte</a>            ;print addrl as two hex digits
                lda     #$0e
                jsr     <a href="#SymPrint">Print</a>             ;" - "
                pla                       ; actual data
                eor     <a href="#Symcompdata">compdata</a>
                jsr     <a href="#Symprbyte">prbyte</a>            ;print failing data as two hex digits
<span id="SymErrCommon">ErrCommon</span>       lda     #$0f
                jsr     <a href="#SymPrint">Print</a>             ;"&lt;CR&gt;SEE DEALER FOR SERVICE&lt;CR&gt;"
                rts

; 
; 
<span id="SymPrDot">PrDot</span>           lda     #<a href="#Symdot">dot</a>
                jsr     <a href="#Symcout">cout</a>
                lda     <a href="#SymKBD">KBD</a>               ;Is escaped pressed?
                cmp     #<a href="#Symesc">esc</a>+128
                bne     <a href="#Symnoesc">noesc</a>
                pla                       ;Pop current return address
                pla
                sta     <a href="#SymKBDSTRB">KBDSTRB</a>
; 
<span id="Symnoesc">noesc</span>           lda     <a href="#Symaddrh">addrh</a>,x           ;Test if last dot
                and     #$0f
                cmp     <a href="#Symlimit">limit</a>             ;Z = 1 if last dot
                rts

<span id="Symgetvalue">getvalue</span>        clc
                lda     <a href="#Symaddrm">addrm</a>,x
                adc     <a href="#Symscmod">scmod</a>,x
                adc     #$55
                sta     <a href="#Symvalue">value</a>
                lda     #0
                rts

;                       ;Go to next line and clear address
<span id="SymNxtLine">NxtLine</span>         jsr     <a href="#Symcrout">crout</a>
                jsr     <a href="#Symclreol">clreol</a>
; fall into clraddr
<span id="Symclraddr">clraddr</span>         lda     #0                ;Clears the address registers
;                                     ;Sets the address registers to A
<span id="Symsetaddr">setaddr</span>         sta     <a href="#Symaddrl">addrl</a>,x           ;Must do in this order
                sta     <a href="#Symaddrm">addrm</a>,x           ;to avoid false carry
                sta     <a href="#Symaddrh">addrh</a>,x
                rts

********************************************************************************
*                                                                              *
********************************************************************************
<span id="SymPrint">Print</span>           tay                       ;print message to the screen
                lda     <a href="#SymMessages">Messages</a>,y
                tay
<span id="Sympr1">pr1</span>             lda     <a href="#SymM0">M0</a>,y
                pha
                ora     #$80              ;all characters must have high bit set
                jsr     <a href="#Symcout">cout</a>
                iny                       ;index to next character
                pla
                bpl     <a href="#Sympr1">pr1</a>               ;last character had high bit set
                rts

; table of pointers to actual messages
<span id="SymMessages">Messages</span>        .dd1    $00               ;M0-M0
                .dd1    $05               ;M1-M0
                .dd1    $09               ;M2-M0
                .dd1    $0d               ;M3-M0
                .dd1    $11               ;M4-M0
                .dd1    $14               ;M5-M0
                .dd1    $16               ;M6-M0
                .dd1    $18               ;M7-M0
                .dd1    $1b               ;M8-M0
                .dd1    $47               ;M9-M0
                .dd1    $5c               ;M0A-M0
                .dd1    $6d               ;M0B-M0
                .dd1    $77               ;M0C-M0
                .dd1    $84               ;M0D-M0
                .dd1    $8f               ;M0E-M0
                .dd1    $92               ;M0F-M0
                .dd1    $aa               ;M10-M0
<span id="SymM0">M0</span>              .dstr   “1 MEG”
<span id="SymM1">M1</span>              .dstr   “256K”
<span id="SymM2">M2</span>              .dstr   “512K”
<span id="SymM3">M3</span>              .dstr   “768K”
<span id="SymM4">M4</span>              .dstr   “180”
<span id="SymM5">M5</span>              .dstr   “45”
<span id="SymM6">M6</span>              .dstr   “90”
<span id="SymM7">M7</span>              .dstr   “135”
<span id="SymM8">M8</span>              .str    “MEMORY CARD TEST”
                .dd1    $0d
                .str    “ESC TO EXIT”
                .dd1    $0d
                .dstr   “TEST WILL TAKE ”
                .str    “ SECONDS”        ;M9
                .dd1    $0d
                .dstr   “CARD SIZE = ”
<span id="SymM0A">M0A</span>             .dd1    $0d
                .dd1    $0d
                .str    “CARD FAILED”
                .dd1    $0d
                .dd1    $07
                .dd1    $07
                .dd1    $87
<span id="SymM0B">M0B</span>             .dd1    $0d
                .dd1    $0d
                .str    “CARD OK”
                .dd1    $8d
<span id="SymM0C">M0C</span>             .dstr   “ADDRESS ERROR”
<span id="SymM0D">M0D</span>             .dstr   “DATA ERROR ”
<span id="SymM0E">M0E</span>             .dstr   “ - ”
<span id="SymM0F">M0F</span>             .dd1    $0d
                .str    “SEE DEALER FOR SERVICE”
                .dd1    $8d
<span id="SymM10">M10</span>             .dstr   “PASSES = ”
<span id="SymPatterns">Patterns</span>        .bulk   $ff,$cc,$aa,$55,$33,$00 ;data buss patterns
                .str    “Rich Williams”
                .str    “copyright 1986 Apple Computer Inc.”
                .str    “all rights reserved”
<span id="Symzsld_end">zsld_end</span>        .ds     196               ;make sure not too big
                .adrend ↑ $2000

                .ds     8186
********************************************************************************
* VECTORS                                                                      *
********************************************************************************
                .dd2    <a href="#Symswreset2">swreset2</a>          ;NMI
                .dd2    <a href="#Symswreset2">swreset2</a>          ;RESET
                .dd2    <a href="#Symswirq2">swirq2</a>            ;INT
                .adrend ↑ $c000
</pre>


</div>

<!-- SymbolTable is optional; remove this entire section from the template if you don't want it -->
<div id="symbol-table">
    <h2>Symbol Table</h2>
<table>
  <tr><th>Label</th><th>Value</th></tr>  <tr><td><a href="#Symmouseint">mouseint</a></td><td><code>$c100</code></td></tr>
</table>

</div>

<div id="footer">
    <hr/>
    <p>HTML generated by <a href="https://6502bench.com/">6502bench SourceGen</a> v1.8.3
    on 2023/03/14 <!--21:40:48 -05:00--></p>
    <p>Expression style: Common</p>
    <!-- parameters: cols=16,8,18,100;extraCols=;byteSpc=True;commaBulk=True;nonuPfx='@';varPfx='';labelBrk=False;notes=False;gfx=True;opWrap=64 -->
</div>

</body>
</html>
