<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" href="SGStyle.css"/>

    <meta name="description" content="SourceGen-generated disassembly of Apple IIc bank2 of 03-342-0445 - A.bin"/>
    <title>Apple IIc bank2 of 03-342-0445 - A.bin Disassembly</title>
</head>

<body>

<p style="font-size:smaller;"><a href="./">(back to project page)</a></p>
<h1>Apple IIc bank2 of 03-342-0445 - A.bin Disassembly</h1>

<div id="code-lines">
    <!-- The CodeLines marker is not optional, and may only appear once -->
<pre>                   ********************************************************************************
                   * Apple IIc ROM3  - Bank 2                                                     *
                   * Re-created by James Lewis (@baldengineer)                                    *
                   * *****************************************************************            *
                   * ** Work In-Progress! ** Work In-Progress! ** Work In-Progress! **            *
                   * *****************************************************************            *
                   *                                                                              *
                   * For more information visit:                                                  *
                   * https://github.com/baldengineer/Apple-IIc-ROM-Disassembly                    *
                   *                                                                              *
                   * (Original attributions are in comments below, as shown in original ROM       *
                   * Listings.)                                                                   *
                   *                                                                              *
                   * Recreated work licensed as Attribution-NonCommercial-ShareAlike 4.0          *
                   * International.                                                               *
                   *                                                                              *
                   * Generated with 6502bench SourceGen v1.8.4                                    *
                   *                                                                              *
                   * *****                                                                        *
                   * pdf page 508 has the equates                                                 *
                   ********************************************************************************
                   <span id="SymMMUIDX">MMUIDX</span>          EQU     $01    {const}
                   <span id="Syminent">inent</span>           EQU     $05    {const}
                   <span id="SymIOUIDX">IOUIDX</span>          EQU     $09    {const}
                   <span id="SymGLUIDX">GLUIDX</span>          EQU     $11    {const}
                   <span id="Symlfeed">lfeed</span>           EQU     $8A    {const}    ;Linefeed
                   <span id="Symxon">xon</span>             EQU     $91    {const}    ;XON character
                   <span id="Symxoff">xoff</span>            EQU     $93    {const}    ;XOFF character
                   <span id="Symcmdcur">cmdcur</span>          EQU     191    {const}    ;'?' ;63_128 ;Cursor while in command mode
                   <span id="Symtermcur">termcur</span>         EQU     223    {const}    ;'_' ;95+128 ;Cursor while in terminal mode
                   <span id="Symsermode">sermode</span>         EQU     $03B8  {const}    ;D7=1 if in command D6=1 if terminal
                   <span id="Symdevno2">devno2</span>          EQU     $C142  {const}    ;$C203-sltdmy
                   <span id="Symsetv">setv</span>            EQU     $C82A  {const}
                   <span id="SymPowerReset">PowerReset</span>      EQU     $00
                   <span id="Symtestnum">testnum</span>         EQU     $00
                   <span id="Symucspace">ucspace</span>         EQU     $00
                   <span id="Symbadcmd">badcmd</span>          EQU     $01               ;bad command
                   <span id="SymBadCmd">BadCmd</span>          EQU     $01
                   <span id="Symnoanswer">noanswer</span>        EQU     $01
                   <span id="Symibdrvn">ibdrvn</span>          EQU     $02               ;drive 1 or 2
                   <span id="Symmovmode">movmode</span>         EQU     $02               ;D1 mask
                   <span id="SymWriteCmd">WriteCmd</span>        EQU     $02
                   <span id="Symbadpcnt">badpcnt</span>         EQU     $04               ;bad parameter count
                   <span id="SymBadPCnt">BadPCnt</span>         EQU     $04
                   <span id="Symbutmode">butmode</span>         EQU     $04               ;D2 mask
                   <span id="SymControlCmd">ControlCmd</span>      EQU     $04
                   <span id="Symibtrk">ibtrk</span>           EQU     $04               ;track number
                   <span id="SymInitCmd">InitCmd</span>         EQU     $05
                   <span id="SymRC2">RC2</span>             EQU     $05               ;Data Packs get tried only 5 times
                   <span id="SymBusErr">BusErr</span>          EQU     $06
                   <span id="Symiwmmode">iwmmode</span>         EQU     $07               ;No timer, asynch, latch
                   <span id="Symibbufp">ibbufp</span>          EQU     $08               ;buffer pointer
                   <span id="Symcmdlength">cmdlength</span>       EQU     $09               ;Command packet length
                   <span id="Symbsyto2">bsyto2</span>          EQU     $0A               ;(.12 ms) T/O on /BSY after send
                   <span id="Symibcmd">ibcmd</span>           EQU     $0C               ;command
                   <span id="Symvblmode">vblmode</span>         EQU     $0C
                   <span id="SymcharCR">charCR</span>          EQU     $0D
                   <span id="Symcsumerr">csumerr</span>         EQU     $10
                   <span id="SymBadUnit">BadUnit</span>         EQU     $11
                   <span id="SymZPSize">ZPSize</span>          EQU     $1C
                   <span id="Symstatmto">statmto</span>         EQU     $1E               ;30 bytes stat mark timeout
                   <span id="Symmovarm">movarm</span>          EQU     $20
                   <span id="Symnopackend">nopackend</span>       EQU     $20
                   <span id="Symbadctl">badctl</span>          EQU     $21               ;bad control / status code
                   <span id="SymBadCtl">BadCtl</span>          EQU     $21
                   <span id="Symch">ch</span>              EQU     $24
                   <span id="Symcv">cv</span>              EQU     $25
                   <span id="SymIOError">IOError</span>         EQU     $27
                   <span id="Symbasl">basl</span>            EQU     $28
                   <span id="SymNoDrive">NoDrive</span>         EQU     $28
                   <span id="SymWriteProt">WriteProt</span>       EQU     $2B
                   <span id="Symdoscat">doscat</span>          EQU     $2C               ;$DAD4-DAA7-7
                   <span id="Symbadblk">badblk</span>          EQU     $2D               ;bad block or address
                   <span id="SymOffline">Offline</span>         EQU     $2F
                   <span id="Symkswl">kswl</span>            EQU     $38
                   <span id="Symkswh">kswh</span>            EQU     $39
                   <span id="SymA1L">A1L</span>             EQU     $3C
                   <span id="SymA1H">A1H</span>             EQU     $3D
                   <span id="SymA2L">A2L</span>             EQU     $3E
                   <span id="SymA2H">A2H</span>             EQU     $3F
                   <span id="Symbushog">bushog</span>          EQU     $40
                   <span id="Symchecksum">checksum</span>        EQU     $40
                   <span id="Symzeropage">zeropage</span>        EQU     $40
                   <span id="Symtopbits">topbits</span>         EQU     $41
                   <span id="SymA4L">A4L</span>             EQU     $42
                   <span id="SymCMDCode">CMDCode</span>         EQU     $42
                   <span id="Symmptr">mptr</span>            EQU     $42               ;indirect pointer to messages
                   <span id="SymA4H">A4H</span>             EQU     $43
                   <span id="SymCMDPcount">CMDPcount</span>       EQU     $43
                   <span id="SymCMDUnit">CMDUnit</span>         EQU     $43
                   <span id="Symbuffer">buffer</span>          EQU     $44               ;pointer to 512 byte data buffer
                   <span id="SymCMDBuffer">CMDBuffer</span>       EQU     $44
                   <span id="SymCMDBufferl">CMDBufferl</span>      EQU     $44
                   <span id="SymCMDBufferh">CMDBufferh</span>      EQU     $45
                   <span id="Symcompdata">compdata</span>        EQU     $45
                   <span id="Sympbuff">pbuff</span>           EQU     $45               ;two byte buffer pointer
                   <span id="Symblock">block</span>           EQU     $46               ;block dumber
                   <span id="SymCMDBlockl">CMDBlockl</span>       EQU     $46
                   <span id="SymCMDSCode">CMDSCode</span>        EQU     $46
                   <span id="Symlimit">limit</span>           EQU     $46
                   <span id="SymCMDBlockh">CMDBlockh</span>       EQU     $47
                   <span id="Sympblock">pblock</span>          EQU     $47               ;block number
                   <span id="Sympcount">pcount</span>          EQU     $47               ;byte count
                   <span id="Sympstat">pstat</span>           EQU     $47               ;status / control code
                   <span id="Symvalue">value</span>           EQU     $47
                   <span id="SymCMDBlocks">CMDBlocks</span>       EQU     $48
                   <span id="Symiobpl">iobpl</span>           EQU     $48               ;pointer to IOB
                   <span id="Symloopcount">loopcount</span>       EQU     $49
                   <span id="Sympaddr">paddr</span>           EQU     $49               ;address for read
                   <span id="Symtempptr">tempptr</span>         EQU     $4A               ;pointer to params must be last 2 zp byte
                   <span id="Symgrp7ctr">grp7ctr</span>         EQU     $4B
                   <span id="Symrcvbuf">rcvbuf</span>          EQU     $4B
                   <span id="Symoddbytes">oddbytes</span>        EQU     $4C
                   <span id="Symbytecount">bytecount</span>       EQU     $4D
                   <span id="Symbytecountl">bytecountl</span>      EQU     $4D
                   <span id="Symnext">next</span>            EQU     $4D
                   <span id="Symstatbyte">statbyte</span>        EQU     $4D
                   <span id="SymAuxType">AuxType</span>         EQU     $4E
                   <span id="Symbytecounth">bytecounth</span>      EQU     $4E
                   <span id="Symnext3">next3</span>           EQU     $4F
                   <span id="SymDeviceID">DeviceID</span>        EQU     $50
                   <span id="SymHostID">HostID</span>          EQU     $51
                   <span id="Symnext6">next6</span>           EQU     $52
                   <span id="Symnext7">next7</span>           EQU     $53
                   <span id="Symauxptr">auxptr</span>          EQU     $56
                   <span id="Symbuffer2">buffer2</span>         EQU     $56
                   <span id="SymSlot">Slot</span>            EQU     $58
                   <span id="Symtbodd">tbodd</span>           EQU     $59
                   <span id="SymUnit">Unit</span>            EQU     $5A
                   <span id="SymWpacketType">WpacketType</span>     EQU     $5B
                   <span id="Sympascat">pascat</span>          EQU     $78               ;$DB20-cattbl-1
                   <span id="Symcmdmark">cmdmark</span>         EQU     $80               ;Command packet identifier
                   <span id="SymCommReset">CommReset</span>       EQU     $80
                   <span id="Symdatamark">datamark</span>        EQU     $82               ;Data packet identifier
                   <span id="Symnameflag">nameflag</span>        EQU     $AA               ;value unused in any catalog
                   <span id="Sympacketbeg">packetbeg</span>       EQU     $C3               ;Mark at beginning of packet
                   <span id="Sympacketend">packetend</span>       EQU     $C8               ;End of packet mark
                   <span id="Symsizeflg">sizeflg</span>         EQU     $FC               ;block size flag
                   <span id="Symzers">zers</span>            EQU     $FD               ;catalog skip flag
                   <span id="Symskpfe">skpfe</span>           EQU     $FE               ;skip FE bytes in catalog
                   <span id="Symrevnum">revnum</span>          EQU     $0101             ;revision 1.0.1
                   <span id="Syminbuf">inbuf</span>           EQU     $0200             ;Input buffer
                   <span id="Symnumbanks">numbanks</span>        EQU     $03B8             ;$478-$C0   ;sl.scrn1 ;number of 64K banks on card
                   <span id="Symsl_scrn2">sl_scrn2</span>        EQU     $0438             ;$4F8-$C0
                   <span id="SymProFLAG">ProFLAG</span>         EQU     $0473             ;scholes
                   <span id="Symminl">minl</span>            EQU     $0478
                   <span id="Symmoutemp">moutemp</span>         EQU     $0478             ; Temporary storage
                   <span id="Symsizetemp">sizetemp</span>        EQU     $0478             ;holds # blocks
                   <span id="Symminxl">minxl</span>           EQU     $047D
                   <span id="Symmouxl">mouxl</span>           EQU     $047F             ;X position low byte
                   <span id="Sympower2">power2</span>          EQU     $04B8
                   <span id="SymRetry">Retry</span>           EQU     $04F3             ;scholes+$80
                   <span id="SymSCRNHOLE1">SCRNHOLE1</span>       EQU     $04F8  {addr/8}   ;text page 1 screen holes
                   <span id="Symerror">error</span>           EQU     $04F8             ;error flag
                   <span id="Symmaxl">maxl</span>            EQU     $04F8
                   <span id="Symaciabuf">aciabuf</span>         EQU     $04FC             ;Owner of serial buffer
                   <span id="Symmouyl">mouyl</span>           EQU     $04FF             ;Y position low byte
                   <span id="Symsl_scrn4">sl_scrn4</span>        EQU     $0538             ;$5F8-$C0
                   <span id="SymRetry2">Retry2</span>          EQU     $0573             ;SHTemp1
                   <span id="SymSHTemp1">SHTemp1</span>         EQU     $0573             ;scholes+$100
                   <span id="SymSCRNHOLE2">SCRNHOLE2</span>       EQU     $0578  {addr/8}   ;text page 1 screen holes
                   <span id="Symminh">minh</span>            EQU     $0578
                   <span id="Symxval">xval</span>            EQU     $0578             ;value to be returned in X
                   <span id="Symtwser">twser</span>           EQU     $057C             ;Storage pointer for serial buffer
                   <span id="Symminxh">minxh</span>           EQU     $057D
                   <span id="Symmouxh">mouxh</span>           EQU     $057F             ;X position high byte
                   <span id="SymSCREEN">SCREEN</span>          EQU     $05B8
                   <span id="SymSHTempX">SHTempX</span>         EQU     $05F3             ;scholes+$180
                   <span id="SymSCRNHOLE3">SCRNHOLE3</span>       EQU     $05F8  {addr/8}   ;text page 1 screen holes
                   <span id="Symmaxh">maxh</span>            EQU     $05F8
                   <span id="Symyval">yval</span>            EQU     $05F8             ;value to be returned in Y
                   <span id="Symtwkey">twkey</span>           EQU     $05FC             ;Storage pointer for type ahead buffer
                   <span id="Symcharbuf">charbuf</span>         EQU     $05FE             ;5FE, 67E are one byte character buffers
                   <span id="Symmouyh">mouyh</span>           EQU     $05FF             ;Y position high byte
                   <span id="Symeschar">eschar</span>          EQU     $0638             ;Current escape character 6F9 &amp; 6FA
                   <span id="Symsl_scrn6">sl_scrn6</span>        EQU     $0638             ;$6F8-$C0
                   <span id="SymSHTempY">SHTempY</span>         EQU     $0673             ;scholes+$200
                   <span id="SymSCRNHOLE4">SCRNHOLE4</span>       EQU     $0678  {addr/8}   ;text page 1 screen holes
                   <span id="Symsl_lcstate">sl_lcstate</span>      EQU     $0678             ;language card state
                   <span id="Symvfactv">vfactv</span>          EQU     $067B
                   <span id="Symtrser">trser</span>           EQU     $067C             ;Retrieve pointer for serial buffer
                   <span id="Symmaxxl">maxxl</span>           EQU     $067D
                   <span id="Symmouarm">mouarm</span>          EQU     $067F             ;Arm interrupts from movement or button
                   <span id="Sympowerup">powerup</span>         EQU     $06B8             ;$778-$C0 	;sl.scrn7 ;powerup byte 	
                   <span id="SymSCRNHOLE5">SCRNHOLE5</span>       EQU     $06F8  {addr/8}   ;text page 1 screen holes
                   <span id="Symtemp">temp</span>            EQU     $06F8             ;Temp storage
                   <span id="Symtrkey">trkey</span>           EQU     $06FF             ;Retrieve buffer for type ahead buffer
                   <span id="Symsl_scrn8">sl_scrn8</span>        EQU     $0738             ;$7F8-$C0
                   <span id="SymSCRNHOLE6">SCRNHOLE6</span>       EQU     $0778  {addr/8}   ;text page 1 screen holes
                   <span id="Symsl_devno">sl_devno</span>        EQU     $0778             ;slot * 16 ($n0) + $88
                   <span id="Symmaxxh">maxxh</span>           EQU     $077D
                   <span id="Symmoustat">moustat</span>         EQU     $077F             ;Mouse status
                   <span id="Symsl_mslot">sl_mslot</span>        EQU     $07F8             ;$C0 + slot ($Cn)
                   <span id="Symcursor">cursor</span>          EQU     $07FB
                   <span id="Symmoumode">moumode</span>         EQU     $07FF             ;Mouse mode
                   <span id="Symbootbuf">bootbuf</span>         EQU     $0800             ;into $800
                   <span id="Symthbuf">thbuf</span>           EQU     $0800             ;Buffer in alt ram space
                   <span id="SymRC1">RC1</span>             EQU     $0BB8             ;Send a command pack 3000 times (3 sec)
                   <span id="Symdiagstart">diagstart</span>       EQU     $1FFF             ;diagtest-1 ;start location of diagnostics
                   <span id="Symdiagdest">diagdest</span>        EQU     $2000             ;location of diagnostics in ram
                   <span id="Symdosinit">dosinit</span>         EQU     $9D1E             ;DOS init vector use addr-1
                   <span id="Symrwts">rwts</span>            EQU     $BD00             ;RWTS entry point
                   <span id="Symproflag">proflag</span>         EQU     $BF00             ;0 = Pascal, $4C = ProDOS, other = DOS
                   <span id="Symaddrl">addrl</span>           EQU     $BFF8             ;address pointer
                   <span id="Symsdata">sdata</span>           EQU     $BFF8             ;+$N0+$90 is output port
                   <span id="Symaddrm">addrm</span>           EQU     $BFF9             ;auto incs after every data access
                   <span id="Symsstat">sstat</span>           EQU     $BFF9             ;ACIA status register
                   <span id="Symaddrh">addrh</span>           EQU     $BFFA
                   <span id="Symscmod">scmod</span>           EQU     $BFFA
                   <span id="Symscomd">scomd</span>           EQU     $BFFA             ;ACIA command register
                   <span id="Symdata">data</span>            EQU     $BFFB             ;data pointed to
                   <span id="SymCLR80COL">CLR80COL</span>        EQU     $C000             ;W use $C002-C005 for aux mem (80STOREOFF)
                   <span id="Symioadr">ioadr</span>           EQU     $C000
                   <span id="SymKBD">KBD</span>             EQU     $C000             ;R last key pressed + 128
                   <span id="SymSET80COL">SET80COL</span>        EQU     $C001             ;W use PAGE2 for aux mem (80STOREON)
                   <span id="SymRDMAINRAM">RDMAINRAM</span>       EQU     $C002             ;W if 80STORE off: read main mem $0200-BFFF
                   <span id="SymRDCARDRAM">RDCARDRAM</span>       EQU     $C003             ;W if 80STORE off: read aux mem $0200-BFFF
                   <span id="SymWRMAINRAM">WRMAINRAM</span>       EQU     $C004             ;W if 80STORE off: write main mem $0200-BFFF
                   <span id="SymWRCARDRAM">WRCARDRAM</span>       EQU     $C005             ;W if 80STORE off: write aux mem $0200-BFFF
                   <span id="SymSETSTDZP">SETSTDZP</span>        EQU     $C008             ;W use main stack and zero page
                   <span id="SymSETALTZP">SETALTZP</span>        EQU     $C009             ;W use aux stack and zero page
                   <span id="SymKBDSTRB">KBDSTRB</span>         EQU     $C010             ;RW keyboard strobe
                   <span id="SymRDLCBNK2">RDLCBNK2</span>        EQU     $C011             ;R bit 7: reading from LC bank 2 ($Dx)?
                   <span id="SymRDLCRAM">RDLCRAM</span>         EQU     $C012             ;R bit 7: reading from LC RAM?
                   <span id="SymRDRAMRD">RDRAMRD</span>         EQU     $C013             ;R bit 7: reading from aux/alt 48K?
                   <span id="SymRDRAMWRT">RDRAMWRT</span>        EQU     $C014             ;R bit 7: writing to aux/alt 48K?
                   <span id="Symmouxint">mouxint</span>         EQU     $C015             ;D7 = x interrupt
                   <span id="Symmouyint">mouyint</span>         EQU     $C017             ;D7 = y interrupt
                   <span id="SymRD80COL">RD80COL</span>         EQU     $C018             ;R bit 7: 80STORE is on?
                   <span id="Symrdvblbar">rdvblbar</span>        EQU     $C019
                   <span id="SymRDVBLBAR">RDVBLBAR</span>        EQU     $C019             ;R bit 7: not VBL (VBL signal is low)?
                   <span id="SymROMBANK">ROMBANK</span>         EQU     $C028             ;RW ROM bank select (IIc Plus)
                   <span id="SymSPKR">SPKR</span>            EQU     $C030             ;RW toggle speaker
                   <span id="Symmouclr">mouclr</span>          EQU     $C048             ;Clear mouse interrupt
                   <span id="SymTXTCLR">TXTCLR</span>          EQU     $C050             ;RW display graphics
                   <span id="SymTXTSET">TXTSET</span>          EQU     $C051             ;RW display text
                   <span id="SymTXTPAGE1">TXTPAGE1</span>        EQU     $C054             ;RW display page 1
                   <span id="Symiou">iou</span>             EQU     $C058             ;IOU interrupt switches
                   <span id="SymSETAN3">SETAN3</span>          EQU     $C05E             ;RW annunciator 3 off
                   <span id="SymBUTN0">BUTN0</span>           EQU     $C061             ;R switch input 0 / open-apple
                   <span id="SymBUTN1">BUTN1</span>           EQU     $C062             ;R switch input 1 / closed-apple
                   <span id="Symioudsbl">ioudsbl</span>         EQU     $C078             ;Disable iou access
                   <span id="Symiouenbl">iouenbl</span>         EQU     $C079             ;Enable iou access
                   <span id="SymROMIN">ROMIN</span>           EQU     $C081             ;RWx2 read ROM, write RAM bank 2
                   <span id="SymLCBANK2">LCBANK2</span>         EQU     $C083             ;RWx2 read/write RAM bank 2
                   <span id="SymLCBANK1">LCBANK1</span>         EQU     $C08B             ;RWx2 read/write RAM bank 1
                   <span id="Symcomslot">comslot</span>         EQU     $C200
                   <span id="Symswreset2">swreset2</span>        EQU     $C788             ;NMI and RESET
                   <span id="Symswirq2">swirq2</span>          EQU     $C78E             ;INT
                   <span id="Symcmdcr">cmdcr</span>           EQU     $D12F             ;same as cmdn
                   <span id="Symcmdn">cmdn</span>            EQU     $D12F             ;same as cmdcr
                   <span id="Symcmdk">cmdk</span>            EQU     $D139             ;same as cmdi and cmdl
                   <span id="Symcmdl">cmdl</span>            EQU     $D139             ;same as cmdi and cmdk
                   <span id="Symdiagcode">diagcode</span>        EQU     $DC00             ;location of diagnostic code
                   <span id="Symhome">home</span>            EQU     $FC58
                   <span id="Symcrout">crout</span>           EQU     $FD8E
                   <span id="Symprbyte">prbyte</span>          EQU     $FDDA
                   <span id="Symcout">cout</span>            EQU     $FDED

                                   ORG     $C000
C000: 00 00 00 00+ <span id="SymLC000">LC000</span>           DS      25
C019: 00 00 00 00+ <span id="Symvblint">vblint</span>          DS      65
C05A: 00 00 00 00+ <span id="Symiou_p_2">iou_p_2</span>         DS      9
C063: 00 00 00 00+ <span id="Symmoubut">moubut</span>          DS      29
C080: 00           <span id="Symreqclr">reqclr</span>          DS      1
C081: 00           <span id="Symreqset">reqset</span>          DS      1
C082: 00           <span id="Symca1clr">ca1clr</span>          DS      1
C083: 00           <span id="Symcalset">calset</span>          DS      1
C084: 00           <span id="Symca2clr">ca2clr</span>          DS      1
C085: 00           <span id="Symca2set">ca2set</span>          DS      1
C086: 00           <span id="Symlstrbclr">lstrbclr</span>        DS      1
C087: 00           <span id="Symlstrbset">lstrbset</span>        DS      1
C088: 00           <span id="Symmonclr">monclr</span>          DS      1
C089: 00           <span id="Symmonset">monset</span>          DS      1
C08A: 00           <span id="Symenable1">enable1</span>         DS      1
C08B: 00           <span id="Symenable2">enable2</span>         DS      1
C08C: 00           <span id="Syml6clr">l6clr</span>           DS      1
C08D: 00           <span id="Syml6set">l6set</span>           DS      1
C08E: 00           <span id="Syml7clr">l7clr</span>           DS      1
C08F: 00 00 00 00+ <span id="Syml7set">l7set</span>           DS      113
                   ********************************************************************************
                   *                                                                              *
                   * Mouse interrupt handler                                                      *
                   *                                                                              *
                   * MOUSERINT - Montior's interrupt handler                                      *
                   *                                                                              *
                   * Returns C = 0 if interrupt handled                                           *
                   * If not mouse interrupt, goes to aciaint                                      *
                   * New in this rom:                                                             *
                   * If D7 of moumode = 1, mouse X and Y interrupts are not processed             *
                   * and are passed on to the user.                                               *
                   *                                                                              *
                   *                                                                              *
                   ********************************************************************************
C100:              mouse_ser_ints
                                   ORG     *+$0000
C100: A9 0E        <span id="Symmouseint">mouseint</span>        lda     #$0E              ;Entry point if X &amp; Y set up
C102: 1C 7F 07                     trb     <a href="#Symmoustat">moustat</a>           ;Clear status bits
                   ; 
C105: 38                           sec                       ;Assume interrupt not handled
                   ; Check for vertical blanking interrupt
C106: AD 19 C0                     lda     <a href="#Symvblint">vblint</a>            ;VBL interrupt?
C109: 10 2B                        bpl     <a href="#Symchkmou">chkmou</a>
C10B: 8D 79 C0                     sta     <a href="#Symiouenbl">iouenbl</a>           ;Enable iou access &amp; clear VBL interrupt
C10E: A9 0C                        lda     #<a href="#Symvblmode">vblmode</a>          ;Should we leave vbl active?
C110: 2C FF 07                     bit     <a href="#Symmoumode">moumode</a>
C113: D0 03                        bne     <a href="#Symcvnovbl">cvnovbl</a>
C115: 8D 5A C0                     sta     <a href="#Symiou_p_2">iou_p_2</a>           ;Disable VBL
C118: 09 02        <span id="Symcvnovbl">cvnovbl</span>         ora     #<a href="#Symmovmode">movmode</a>
C11A: 8D 78 C0                     sta     <a href="#Symioudsbl">ioudsbl</a>
C11D: 2C 7F 06                     bit     <a href="#Symmouarm">mouarm</a>            ;VBL bit in arm isn't used
C120: D0 02                        bne     <a href="#Symcvmoved">cvmoved</a>
C122: A9 0C                        lda     #<a href="#Symvblmode">vblmode</a>          ;Didn't move
C124: 2C 63 C0     <span id="Symcvmoved">cvmoved</span>         bit     <a href="#Symmoubut">moubut</a>            ;Button pressed?
C127: 10 02                        bpl     <a href="#Symcvbut">cvbut</a>
C129: 49 04                        eor     #<a href="#Symbutmode">butmode</a>          ;Clear the button bit
C12B: 2D FF 07     <span id="Symcvbut">cvbut</span>           and     <a href="#Symmoumode">moumode</a>           ;Which bits were set in the mode
C12E: 0C 7F 07                     tsb     <a href="#Symmoustat">moustat</a>
C131: 1C 7F 06                     trb     <a href="#Symmouarm">mouarm</a>
C134: 69 FE                        adc     #$FE              ;C=1 if int passes to user
                   ; Check &amp; update mouse movement
C136: AD FF 07     <span id="Symchkmou">chkmou</span>          lda     <a href="#Symmoumode">moumode</a>           ;If D7 = 1, user better handle it
C139: 30 72                        bmi     <a href="#Symxmdone">xmdone</a>
C13B: AD 15 C0                     lda     <a href="#Symmouxint">mouxint</a>           ;Mouser interrupt?
C13E: 0D 17 C0                     ora     <a href="#Symmouyint">mouyint</a>
C141: 10 6A                        bpl     <a href="#Symxmdone">xmdone</a>            ;If not return with C from vbl
C143: 8A                           txa                       ;Get X1 in A
C144: A2 00                        ldx     #0
C146: 2C 15 C0                     bit     <a href="#Symmouxint">mouxint</a>           ;X movement?
C149: 30 0A                        bmi     <a href="#Symcmxmov">cmxmov</a>
C14B: 98           <span id="Symcmloop">cmloop</span>          tya                       ;Get Y1 into A
C14C: 49 80                        eor     #$80              ;Complement direction
C14E: A2 80                        ldx     #$80
C150: 2C 17 C0                     bit     <a href="#Symmouyint">mouyint</a>
C153: 10 39                        bpl     <a href="#Symcmnoy">cmnoy</a>
C155: 0A           <span id="Symcmxmov">cmxmov</span>          asl     A
C156: BD 7F 04                     lda     <a href="#Symmouxl">mouxl</a>,X           ;A = current low byte
C159: B0 1A                        bcs     <a href="#Symcmrght">cmrght</a>            ;which way?
C15B: DD 7D 04                     cmp     <a href="#Symminxl">minxl</a>,X           ;Move left
C15E: D0 08                        bne     <a href="#Symcmlok">cmlok</a>
C160: BD 7F 05                     lda     <a href="#Symmouxh">mouxh</a>,X
C163: DD 7D 05                     cmp     <a href="#Symminxh">minxh</a>,X
C166: F0 22                        beq     <a href="#Symcmnoint">cmnoint</a>
C168: BD 7F 04     <span id="Symcmlok">cmlok</span>           lda     <a href="#Symmouxl">mouxl</a>,X
C16B: D0 03                        bne     <a href="#Symcmnt0">cmnt0</a>             ;Borrow from high byte?
C16D: DE 7F 05                     dec     <a href="#Symmouxh">mouxh</a>,X
C170: DE 7F 04     <span id="Symcmnt0">cmnt0</span>           dec     <a href="#Symmouxl">mouxl</a>,X
C173: 80 15                        bra     <a href="#Symcmnoint">cmnoint</a>

C175: DD 7D 06     <span id="Symcmrght">cmrght</span>          cmp     <a href="#Symmaxxl">maxxl</a>,X           ;At high bound?
C178: D0 08                        bne     <a href="#Symcmrok">cmrok</a>
C17A: BD 7F 05                     lda     <a href="#Symmouxh">mouxh</a>,X
C17D: DD 7D 07                     cmp     <a href="#Symmaxxh">maxxh</a>,X
C180: F0 08                        beq     <a href="#Symcmnoint">cmnoint</a>
C182: FE 7F 04     <span id="Symcmrok">cmrok</span>           inc     <a href="#Symmouxl">mouxl</a>,X           ;Move right
C185: D0 03                        bne     <a href="#Symcmnoint">cmnoint</a>
C187: FE 7F 05                     inc     <a href="#Symmouxh">mouxh</a>,X
C18A: E0 00        <span id="Symcmnoint">cmnoint</span>         cpx     #0
C18C: F0 BD                        beq     <a href="#Symcmloop">cmloop</a>
C18E: 8D 48 C0     <span id="Symcmnoy">cmnoy</span>           sta     <a href="#Symmouclr">mouclr</a>
C191: A9 02                        lda     #<a href="#Symmovmode">movmode</a>          ;Should we enable VBL?
C193: 2D FF 07                     and     <a href="#Symmoumode">moumode</a>
C196: F0 09                        beq     <a href="#Symcmnovbl">cmnovbl</a>           ;Branch if not
C198: 8D 79 C0                     sta     <a href="#Symiouenbl">iouenbl</a>
                   ;                       ;iou+3
C19B: 8D 5B C0                     sta     <a href="#Symiou_p_2">iou_p_2</a>+1         ;Enable VBL int
C19E: 8D 78 C0                     sta     <a href="#Symioudsbl">ioudsbl</a>
C1A1: 09 20        <span id="Symcmnovbl">cmnovbl</span>         ora     #<a href="#Symmovarm">movarm</a>           ;Mark that we moved
C1A3: 0C 7F 06                     tsb     <a href="#Symmouarm">mouarm</a>
C1A6: A9 0E                        lda     #$0E
C1A8: 2D 7F 07                     and     <a href="#Symmoustat">moustat</a>
C1AB: 69 FE                        adc     #$FE              ;C=1 iff any bits were 1
C1AD: B0 05        <span id="Symxmdone">xmdone</span>          bcs     <a href="#Symaciaint">aciaint</a>           ;If not handled, try acia
C1AF: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>            ;Back we go

                   ;   This routine will determine if the source of
                   ; is either of the built in ACIAs.  If neither port
                   ; generated the interrupt, or the interrupt was due
                   ; to a transmit buffer empty, protocol converter, or
                   ; 'unbuffered' receiver full, the carry is set indi-
                   ; cating an externally serviced interrupt.
                   ;   If the interrupt source was keyboard, 'buffer'
                   ; serial input, or the DCD, the interrupt is serviced
                   ; and the carry is cleared indicating interrupt was
                   ; serviced.  (DCD handshake replaces CTS.)
                   ;   Location "ACIABUF" specifies which (if either) re-
                   ; receiver data is buffered.  For port 1 it must contain
                   ; $C1, for port 2 a $C2.  Any other values are cause
                   ; interrupts to pass to external (RAM based) routines.
                   ;   Location "TYEHED" specifies whether Keyboard in-
                   ; put should be buffered, ignored, or processed by 
                   ; RAM based rountines.  If bit 7=1 and bit 6=0, key-
                   ; board data is placed in the type-ahead buffer.  If
                   ; bit 6 is set the interrupt is cleared, but must
                   ; be recognized and serviced by a RAM routine.  If
                   ; both bits = 0, the interrupt is serviced, but the
                   ; keyboard data is ignored.
                   ;   While used type-ahead, Open-Apple CTRL-X will
                   ; flush the buffer.  No other code is recognized.
                   ;   If the source was an ACIA that has the transmit
                   ; interrupt enabled, the original value of the ACIAs
                   ; status registers is preserved. Automatic serial input
                   ; buffering is not serviced from a port so configured.
                   ; Interrupts originating from the protocol converter or
                   ; keyboard (RAM serviced) do not inhibit serial buffering
                   ; and are passed true.  The RAM service routine can rec-
                   ; ognize the interrupt source by a 1 state in bit 6 of
                   ; the ACIAs status register.  The RAM service routine must
                   ; cause the clearing of DSR (bit 6) AND make a second ac-
                   ; cess to the status register before returning.
                   ; 
                   ; 
C1B2: 38           <span id="Symnotacia">notacia</span>         sec                       ;Not acia int
C1B3: 60           <span id="Symacdone">acdone</span>          rts

C1B4: 20 BA C1     <span id="Symaciaint">aciaint</span>         jsr     <a href="#Symaciaint2">aciaint2</a>          ;Extra jsr since rest needs RTS
C1B7: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

C1BA: A2 C2        <span id="Symaciaint2">aciaint2</span>        ldx     #&gt;<a href="#Symcomslot">comslot</a>         ;Test port 2 first
C1BC: 20 C2 C1                     jsr     <a href="#Symaciatst">aciatst</a>           ;Check for interrupt
C1BF: 90 F2                        bcc     <a href="#Symacdone">acdone</a>            ;Return if interrupt done
C1C1: CA                           dex                       ;Try port 1
C1C2: BC 42 C1     <span id="Symaciatst">aciatst</span>         ldy     <a href="#Symdevno2">devno2</a>,X          ;Get index for acia
C1C5: A9 04                        lda     #4                ;If xmit ints enabled pass to user
C1C7: 59 FA BF                     eor     <a href="#Symscomd">scomd</a>,Y           ;Check if D&lt;3&gt;, D&lt;2&gt; = 01
C1CA: 29 0C                        and     #$0C              ; 
C1CC: F0 E4                        beq     <a href="#Symnotacia">notacia</a>           ;User better take it!
C1CE: B9 F9 BF                     lda     <a href="#Symsstat">sstat</a>,Y           ;Get status
C1D1: 9D 38 04                     sta     <a href="#Symsl_scrn2">sl_scrn2</a>,X        ;Save it away
C1D4: 10 DC                        bpl     <a href="#Symnotacia">notacia</a>           ;No interrupt
C1D6: E0 C2        <span id="Symaitst2">aitst2</span>          cpx     #&gt;<a href="#Symcomslot">comslot</a>         ;C=1 if com port. Called from serout3
C1D8: B0 02                        bcs     <a href="#Symaiport2">aiport2</a>           ;Invert DSR if port1
C1DA: 49 40                        eor     #$40
C1DC: 3C 38 05     <span id="Symaiport2">aiport2</span>         bit     <a href="#Symsl_scrn4">sl_scrn4</a>,X        ;Is DSR enabled?
C1DF: 70 29                        bvs     <a href="#Symaipass">aipass</a>            ;Yes, user wants it
C1E1: 10 25                        bpl     <a href="#Symaieatit">aieatit</a>           ;No, eat it
C1E3: 90 23                        bcc     <a href="#Symaieatit">aieatit</a>           ;Yes, but I don't want it for port 1
C1E5: 89 40                        bit     #$40              ;Is DSR 1?
C1E7: F0 21                        beq     <a href="#Symaipass">aipass</a>            ;If not, skip it
                   ; It's a keyboard interrupt
C1E9: AD 00 C0                     lda     <a href="#SymKBD">KBD</a>               ;Get the key
C1EC: A0 80                        ldy     #$80
C1EE: 20 28 C2                     jsr     <a href="#Symputbuf">putbuf</a>            ;Put it in the buffer
C1F1: C9 98                        cmp     #$98              ;Is it a ^x?
C1F3: D0 0B                        bne     <a href="#Symainoflsh">ainoflsh</a>
C1F5: AD 62 C0                     lda     <a href="#SymBUTN1">BUTN1</a>             ;And the closed apple?
C1F8: 10 06                        bpl     <a href="#Symainoflsh">ainoflsh</a>
C1FA: 8E FC 05                     stx     <a href="#Symtwkey">twkey</a>             ;Flush the type ahead buffer
C1FD: 8E FF 06                     stx     <a href="#Symtrkey">trkey</a>
C200: AD 10 C0     <span id="Symainoflsh">ainoflsh</span>        lda     <a href="#SymKBDSTRB">KBDSTRB</a>           ;Clear the keyboard
                   ; * $A0 $B0 table needed by serial firmware
C203: A0 B0                        ldy     #$B0              ;Restore y
C205: B9 F9 BF                     lda     <a href="#Symsstat">sstat</a>,Y           ;Read status to clear int
C208: 29 BF        <span id="Symaieatit">aieatit</span>         and     #$BF              ;Clear the DSR bit
C20A: 0A           <span id="Symaipass">aipass</span>          asl     A                 ;Shift DSR into C
C20B: 0A                           asl     A
C20C: 29 20                        and     #$20              ;Is the receiver full?
C20E: F0 3E                        beq     <a href="#Symaciadone">aciadone</a>          ;If not, we're done
C210: B9 FA BF                     lda     <a href="#Symscmod">scmod</a>,Y           ;Are received interrupts, enabled?
C213: 49 01                        eor     #1                ;Check for D&lt;1&gt;,D&lt;0&gt; = 01
C215: 29 03                        and     #3
C217: D0 35                        bne     <a href="#Symaciadone">aciadone</a>          ;If not, were done
C219: 8A                           txa                       ; Is this acia buffered?
C21A: 4D FC 04                     eor     <a href="#Symaciabuf">aciabuf</a>
C21D: D0 93                        bne     <a href="#Symnotacia">notacia</a>           ;The user better handle it!
C21F: 08                           php                       ; Save DSR status
C220: 20 22 C3                     jsr     <a href="#Symgetdata">getdata</a>           ;Get char &amp; check xon, etc
C223: 90 28                        bcc     <a href="#Symaieat">aieat</a>             ;Don't put in buffer if eaten
C225: A0 00                        ldy     #0
C227: D0                           DFB     $D0               ;BNE opcode to skip PHP
C228: 08           <span id="Symputbuf">putbuf</span>          php
C229: DA                           phx
C22A: 48                           pha
C22B: B9 7C 05                     lda     <a href="#Symtwser">twser</a>,Y           ;Get buffer pointer
C22E: AA                           tax                       ; Save it for later
C22F: 1A                           inc     A                 ;Bump it to next free byte
C230: 89 7F                        bit     #$7F              ;Overflow?
C232: D0 01                        bne     <a href="#Sympbok">pbok</a>
C234: 98           <span id="SymLC234">LC234</span>           tya                       ; Wrap pointer
C235: D9 7C 06     <span id="Sympbok">pbok</span>            cmp     <a href="#Symtrser">trser</a>,Y           ;Buffer full?
C238: F0 03                        beq     <a href="#Sympbfull">pbfull</a>
C23A: 99 7C 05                     sta     <a href="#Symtwser">twser</a>,Y           ;Save the new pointer
C23D: 68           <span id="Sympbfull">pbfull</span>          pla                       ; Get the data
C23E: 2C 14 C0                     bit     <a href="#SymRDRAMWRT">RDRAMWRT</a>
C241: 8D 05 C0                     sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ;It goes to aux ram
C244: 9D 00 08                     sta     <a href="#Symthbuf">thbuf</a>,X
C247: 30 03                        bmi     <a href="#Symaiaux">aiaux</a>             ;Branch if we want aux
C249: 8D 04 C0                     sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>
C24C: FA           <span id="Symaiaux">aiaux</span>           plx
C24D: 28           <span id="Symaieat">aieat</span>           plp                       ;Get DSR status back
C24E: 60           <span id="Symaciadone">aciadone</span>        rts

                   ********************************************************************************
                   *                                                                              *
                   * SEROUT3 - Outputs a character to a acia                                      *
                   * Inputs: A = char, X = Cn                                                     *
                   *                                                                              *
                   ********************************************************************************
C24F: 20 55 C2     <span id="Symserout3">serout3</span>         jsr     <a href="#Symserout4">serout4</a>
C252: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

                   ;                                       ;Entry point with rts
C255: 48           <span id="Symserout4">serout4</span>         pha                       ; Save the char
C256: 2C AB C2                     bit     <a href="#Symsorts">sorts</a>             ;Control char?
C259: F0 03                        beq     <a href="#Symsordy">sordy</a>             ;Don't inc column if so
C25B: FE 38 07                     inc     <a href="#Symsl_scrn8">sl_scrn8</a>,X
C25E: 20 B2 C2     <span id="Symsordy">sordy</span>           jsr     <a href="#Symgetstat2">getstat2</a>          ;Get acia status
C261: 29 30                        and     #$30              ;Y set by getstat
C263: C9 10                        cmp     #$10
C265: D0 F7                        bne     <a href="#Symsordy">sordy</a>
C267: BD B8 06                     lda     <a href="#Sympowerup">powerup</a>,X         ;Is XON/XOFF enabled?
C26A: 89 20                        bit     #$20
C26C: F0 1F                        beq     <a href="#Symsook">sook</a>              ;Branch if not
C26E: EC FC 04                     cpx     <a href="#Symaciabuf">aciabuf</a>           ;Is port interrupt driven?
C271: F0 13                        beq     <a href="#Symsotst">sotst</a>
C273: 20 E9 C2                     jsr     <a href="#Symxrdnobuf">xrdnobuf</a>          ;Get a char from the acia
C276: 90 0E                        bcc     <a href="#Symsotst">sotst</a>             ;Branch if no char
C278: BC 34 C2                     ldy     <a href="#SymLC234">LC234</a>,X           ;Get pointer to charbuf
C27B: 99 FE 05                     sta     <a href="#Symcharbuf">charbuf</a>,Y         ;Save the character
C27E: BD B8 06                     lda     <a href="#Sympowerup">powerup</a>,X         ;Set bit for char in buffer
C281: 09 04                        ora     #$04
C283: 9D B8 06                     sta     <a href="#Sympowerup">powerup</a>,X
C286: BD B8 06     <span id="Symsotst">sotst</span>           lda     <a href="#Sympowerup">powerup</a>,X         ;Check if in xoff
C289: 29 02                        and     #$02
C28B: D0 D1                        bne     <a href="#Symsordy">sordy</a>             ;Loop if not ready
C28D: BC 42 C1     <span id="Symsook">sook</span>            ldy     <a href="#Symdevno2">devno2</a>,X
C290: 68                           pla
C291: 48                           pha                       ; Get char to XMIT
C292: 99 F8 BF                     sta     <a href="#Symsdata">sdata</a>,Y           ;Out it goes
C295: 3C B8 06                     bit     <a href="#Sympowerup">powerup</a>,X         ;V=1 if LF after CR
C298: 49 0D                        eor     #$0D              ;check for CR.
C29A: 0A                           asl     A                 ;preserve bit 7
C29B: D0 0D                        bne     <a href="#Symsodone">sodone</a>            ;branch if not CR.
C29D: 50 06                        bvc     <a href="#Symclrcol">clrcol</a>            ;branch if no LF after CR
C29F: A9 14                        lda     #$14              ;Get LF*2
C2A1: 6A                           ror     A                 ;no shift in high bit
C2A2: 20 55 C2                     jsr     <a href="#Symserout4">serout4</a>           ;Output the LF but don't echo it
C2A5: 64 24        <span id="Symclrcol">clrcol</span>          stz     <a href="#Symch">ch</a>                ;0 position &amp; column
C2A7: 9E 38 07                     stz     <a href="#Symsl_scrn8">sl_scrn8</a>,X
C2AA: 68           <span id="Symsodone">sodone</span>          pla                       ;Get the char back
C2AB: 60           <span id="Symsorts">sorts</span>           rts

                   ********************************************************************************
                   *                                                                              *
                   * GETSTAT - Gets the status from a acia                                        *
                   * GETSTAT2 - Call from this side                                               *
                   * If interrupt, aciatst is called                                              *
                   * note: external interrupts are lost                                           *
                   * inputs: X = Cn                                                               *
                   * outputs: A = status, X = Cn, Y = devno                                       *
                   *                                                                              *
                   ********************************************************************************
C2AC: 20 B2 C2     <span id="Symgetstat">getstat</span>         jsr     <a href="#Symgetstat2">getstat2</a>
C2AF: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>            ;Return to other side

C2B2: 08           <span id="Symgetstat2">getstat2</span>        php                       ; Save interrupt status
C2B3: 78                           sei
C2B4: BC 42 C1     <span id="Symgsttst">gsttst</span>          ldy     <a href="#Symdevno2">devno2</a>,X          ;Get index into hardware
C2B7: B9 F9 BF                     lda     <a href="#Symsstat">sstat</a>,Y           ;Get the status
C2BA: 10 05                        bpl     <a href="#Symgstnoint">gstnoint</a>          ;D7 = 1 if interrupt
C2BC: 20 D6 C1                     jsr     <a href="#Symaitst2">aitst2</a>            ;Go service the interrupt
C2BF: 80 F3                        bra     <a href="#Symgsttst">gsttst</a>            ;Interrupt may have changed status

C2C1: 28           <span id="Symgstnoint">gstnoint</span>        plp                       ; Restore interrupt status
C2C2: 60                           rts

                   ********************************************************************************
                   * This is the serial input routine. Carry                                      *
                   * flag set indicates that returned data is                                     *
                   * valid.                                                                       *
                   *                                                                              *
                   ********************************************************************************
C2C3: 20 C9 C2     <span id="Symxrdser">xrdser</span>          jsr     <a href="#Symxrdser2">xrdser2</a>
C2C6: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

C2C9: EC FC 04     <span id="Symxrdser2">xrdser2</span>         cpx     <a href="#Symaciabuf">aciabuf</a>           ;is serial input buffered?
C2CC: D0 07                        bne     <a href="#Symxnosbuf">xnosbuf</a>           ;(in english "NO SERIAL BUFFER")
C2CE: A0 00                        ldy     #0                ;Y=0 for serial buffer
C2D0: 20 FD C2                     jsr     <a href="#Symgetbuf2">getbuf2</a>           ;Any data in buffer?
C2D3: B0 1F                        bcs     <a href="#Symxrddone">xrddone</a>
                   ; 
C2D5: BD B8 06     <span id="Symxnosbuf">xnosbuf</span>         lda     <a href="#Sympowerup">powerup</a>,X         ;Is there a char in the onr byte buffer?
C2D8: 89 04                        bit     #$04
C2DA: F0 0D                        beq     <a href="#Symxrdnobuf">xrdnobuf</a>          ;Branch if not
C2DC: 29 FB                        and     #$FB              ;Clear the bit
C2DE: 9D B8 06                     sta     <a href="#Sympowerup">powerup</a>,X
C2E1: BC 34 C2                     ldy     <a href="#SymLC234">LC234</a>,X
C2E4: B9 FE 05                     lda     <a href="#Symcharbuf">charbuf</a>,Y
C2E7: 38                           sec
C2E8: 60                           rts

C2E9: 20 B2 C2     <span id="Symxrdnobuf">xrdnobuf</span>        jsr     <a href="#Symgetstat2">getstat2</a>          ;Get ACIA status
C2EC: 29 08                        and     #$08
C2EE: 18                           clc                       ;indicate no data
C2EF: F0 03                        beq     <a href="#Symxrddone">xrddone</a>           ;Branch if no data!
C2F1: 20 22 C3                     jsr     <a href="#Symgetdata">getdata</a>           ;Get data and check xon, etc.
C2F4: 60           <span id="Symxrddone">xrddone</span>         rts

C2F5: 00 80                        HEX     $00,$80

                   ********************************************************************************
                   *                                                                              *
                   * GETBUF - Gets a byte from the input buffer                                   *
                   * Inputs: Y=0 for Serial buffer 80 for Keyboard buffer                         *
                   * C = 0 if no data C = 1 if data valid A = Data                                *
                   *                                                                              *
                   ********************************************************************************
C2F7: 20 FD C2     <span id="Symgetbuf">getbuf</span>          jsr     <a href="#Symgetbuf2">getbuf2</a>
C2FA: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

C2FD: B9 7C 06     <span id="Symgetbuf2">getbuf2</span>         lda     <a href="#Symtrser">trser</a>,Y           ;Test for data in buffer
C300: D9 7C 05                     cmp     <a href="#Symtwser">twser</a>,Y           ;If = then no data
C303: 18                           clc
C304: F0 1B                        beq     <a href="#Symgbdone">gbdone</a>            ;Branch if empty
C306: 48                           pha                       ;Save current value
C307: 1A                           inc     A                 ;Update the pointer
C308: 89 7F                        bit     #$7F              ;Overflow
C30A: D0 01                        bne     <a href="#Symgbnoovr">gbnoovr</a>
C30C: 98                           tya
C30D: 99 7C 06     <span id="Symgbnoovr">gbnoovr</span>         sta     <a href="#Symtrser">trser</a>,Y           ;Store the updated pointer
C310: 7A                           ply                       ;Get the old value of the pointer
C311: AD 13 C0                     lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;Are we in main ram
C314: 0A                           asl     A                 ;C=1 for Aux ram
C315: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;Force Aux ram
C318: B9 00 08                     lda     <a href="#Symthbuf">thbuf</a>,Y           ;Get byte from buffer
C31B: B0 04                        bcs     <a href="#Symgbdone">gbdone</a>            ;Branch if we were in aux bank
C31D: 8D 02 C0                     sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;Set back to main
C320: 38                           sec                       ;Mark data there
C321: 60           <span id="Symgbdone">gbdone</span>          rts

                   ********************************************************************************
                   *                                                                              *
                   * GETDATA - Gets data from serial port                                         *
                   * and checks for LF, XON, XOFF                                                 *
                   * inputs: Y = index to acia                                                    *
                   * outputs: A = data, Y dest, C = 1 if data ok = 0 if eaten                     *
                   *                                                                              *
                   ********************************************************************************
C322: B9 F8 BF     <span id="Symgetdata">getdata</span>         lda     <a href="#Symsdata">sdata</a>,Y
C325: 48                           pha                       ;Save the data
C326: 09 80                        ora     #$80              ;Set D7 for compares
C328: A8                           tay
C329: BD B8 06                     lda     <a href="#Sympowerup">powerup</a>,X         ;Get options byte
C32C: 89 08                        bit     #$08              ;Eat linefeeds?
C32E: D0 04                        bne     <a href="#Symgdnolf">gdnolf</a>
C330: C0 8A                        cpy     #<a href="#Symlfeed">lfeed</a>            ;Is it a LF?
C332: F0 12                        beq     <a href="#Symgdeat">gdeat</a>             ;Eat it if it is
C334: 89 20        <span id="Symgdnolf">gdnolf</span>          bit     #$20              ;Xon/XOFF enabled?
C336: F0 10                        beq     <a href="#Symgdok">gdok</a>
C338: C0 91                        cpy     #<a href="#Symxon">xon</a>              ;Is it an XON?
C33A: D0 04                        bne     <a href="#Symgdnxon">gdnxon</a>
C33C: 29 FD                        and     #$FD              ;Clear xoff bit
C33E: 80 06                        bra     <a href="#Symgdeat">gdeat</a>             ;And eat it

C340: C0 93        <span id="Symgdnxon">gdnxon</span>          cpy     #<a href="#Symxoff">xoff</a>
C342: D0 04                        bne     <a href="#Symgdok">gdok</a>
C344: 09 02                        ora     #$02              ;Set xoff bit
C346: 18           <span id="Symgdeat">gdeat</span>           clc
C347: B0                           DFB     $B0               ;BCS opcode
C348: 38           <span id="Symgdok">gdok</span>            sec
C349: 9D B8 06                     sta     <a href="#Sympowerup">powerup</a>,X
C34C: 68                           pla
C34D: 60                           rts
                                   ADREND   $C100

                   ********************************************************************************
                   * Name    : MOVEAUX                                                            *
                   * Function: Perform crossbank memory move                                      *
                   * Input   : A1 = Source Address                                                *
                   *         : A2 = Source End                                                    *
                   *         : A4 = Destination Start                                             *
                   *         : Carry SET = Main --&gt; Card                                          *
                   *                 CLR = Card --&gt; Main                                          *
                   *                                                                              *
                   * Output  : None                                                               *
                   * Volatile: Nothing                                                            *
                   * Calls   : Nothing                                                            *
                   ********************************************************************************
C34E:              aux_ram_support
                                   ORG     *+$0000
C34E: 48           <span id="Symmoveaux">moveaux</span>         pha                       ;SAVE AC
C34F: AD 13 C0                     lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;SAVE STATE OF
C352: 48                           pha                       ; MEMORY FLAGS
C353: AD 14 C0                     lda     <a href="#SymRDRAMWRT">RDRAMWRT</a>
C356: 48                           pha
                   ; 
                   ; Set Flags for Crossbank Move:
                   ; 
C357: 90 08                        bcc     <a href="#Symmovec2m">movec2m</a>           ;=&gt;CARD--&gt;MAIN
C359: 8D 02 C0                     sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;SET FOR MAIN
C35C: 8D 05 C0                     sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ; TO CARD
C35F: B0 06                        bcs     <a href="#Symmoveloop">moveloop</a>          ;=&gt; (ALWAYS TAKEN)

C361: 8D 04 C0     <span id="Symmovec2m">movec2m</span>         sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>         ;SET FOR CARD
C364: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ; TO MAIN
                   ; MOVESTRT
C367: B2 3C        <span id="Symmoveloop">moveloop</span>        lda     (<a href="#SymA1L">A1L</a>)             ;get a byte
C369: 92 42                        sta     (<a href="#SymA4L">A4L</a>)             ;move it
C36B: E6 42                        inc     <a href="#SymA4L">A4L</a>
C36D: D0 02                        bne     <a href="#Symnexta1">nexta1</a>
C36F: E6 43                        inc     <a href="#SymA4H">A4H</a>
C371: A5 3C        <span id="Symnexta1">nexta1</span>          lda     <a href="#SymA1L">A1L</a>
C373: C5 3E                        cmp     <a href="#SymA2L">A2L</a>
C375: A5 3D                        lda     <a href="#SymA1H">A1H</a>
C377: E5 3F                        sbc     <a href="#SymA2H">A2H</a>
C379: E6 3C                        inc     <a href="#SymA1L">A1L</a>
C37B: D0 02                        bne     <a href="#Symco1">co1</a>
C37D: E6 3D                        inc     <a href="#SymA1H">A1H</a>
C37F: 90 E6        <span id="Symco1">co1</span>             bcc     <a href="#Symmoveloop">moveloop</a>          ;=&gt;more to move
                   ; 
C381: 8D 04 C0                     sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>         ;CLEAR FLAG2
C384: 68                           pla                       ;GET ORIGINAL STATE
C385: 10 03                        bpl     <a href="#Symco3">co3</a>               ;=&gt;IT WAS OFF
C387: 8D 05 C0                     sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>
C38A: 8D 02 C0     <span id="Symco3">co3</span>             sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;CLEAR FLAG1
C38D: 68                           pla                       ;GET ORIGINAL STATE
C38E: 10 03                        bpl     <a href="#Symmoveret">moveret</a>           ;=&gt;IT WAS OFF
C390: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>
C393: 68           <span id="Symmoveret">moveret</span>         pla                       ;Restore AC
C394: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

                   ********************************************************************************
                   * NAME    : XFER                                                               *
                   * FUNCTION: TRANSFER CONTROL CROSSBANK                                         *
                   * INPUT   : $03ED=TRANSFER ADDR                                                *
                   *         : CARRY SET=XFER TO CARD                                             *
                   *                 CLR=XFER TO MAIN                                             *
                   *         : VFLAG CLR=USE STD ZP/STK                                           *
                   *         :       SET=USE ALT ZP/STK                                           *
                   * OUTPUT  : NONE                                                               *
                   * VOLATILE: $03ED/03EE IN DEST BANK                                            *
                   * CALLS   : NOTHING                                                            *
                   * NOTE    : ENTERED VIA JMP, NOT JSR                                           *
                   ********************************************************************************
C397: 48           <span id="SymXFER">XFER</span>            pha                       ;SAVE AC ON CURRENT STACK
                   ; 
                   ; COPY DESTINATION ADDRESS TO THE
                   ;  OTHER BANK SO THAT WE HAVE IT
                   ;  IN CASE WE DO A SWAP:
                   ; 
C398: AD ED 03                     lda     $03ED             ;GET XFERADDR LO
C39B: 48                           pha                       ;SAVE ON CURRENT STACK
C39C: AD EE 03                     lda     $03EE             ;GET XFERADDR HI
C39F: 48                           pha                       ;SAVE IT TOO
                   ; 
                   ; SWITCH TO APPROPRIATE BANK:
                   ; 
C3A0: 90 08                        bcc     <a href="#SymXFERC2M">XFERC2M</a>           ;=&gt;CARD--&gt;MAIN
C3A2: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;SET FOR RUNNING
C3A5: 8D 05 C0                     sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ; IN CARD RAM
C3A8: B0 06                        bcs     <a href="#SymXFERZP">XFERZP</a>            ;=&gt; always taken

C3AA: 8D 02 C0     <span id="SymXFERC2M">XFERC2M</span>         sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;SET FOR RUNNING
C3AD: 8D 04 C0                     sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>         ; IN MAIN RAM
                   ; 
                   ;                                       ;SWITCH TO ALT ZP/STK
C3B0: 68           <span id="SymXFERZP">XFERZP</span>          pla                       ;STUFF XFERADDR
C3B1: 8D EE 03                     sta     $03EE             ; HI AND
C3B4: 68                           pla
C3B5: 8D ED 03                     sta     $03ED             ;   LO
C3B8: 68                           pla                       ;RESTORE AC
C3B9: 70 05                        bvs     <a href="#SymXFERAZP">XFERAZP</a>           ;=&gt;switch in alternate zp
C3BB: 8D 08 C0                     sta     <a href="#SymSETSTDZP">SETSTDZP</a>          ;else force standard zp
C3BE: 50 03                        bvc     <a href="#SymJMPDEST">JMPDEST</a>           ;=&gt;always perform transfer

C3C0: 8D 09 C0     <span id="SymXFERAZP">XFERAZP</span>         sta     <a href="#SymSETALTZP">SETALTZP</a>          ;switch in alternate zp
C3C3: 4C EB C7     <span id="SymJMPDEST">JMPDEST</span>         jmp     <a href="#SymSWXFGO2">SWXFGO2</a>           ;Back we go
                                   ADREND   $C34E

                   ********************************************************************************
                   * banger                                                                       *
                   *                                                                              *
                   * Here is the rest of the diagnostic stuff                                     *
                   * the first part has been moved into the $D000 space                           *
                   * to make desperately needed room                                              *
                   *                                                                              *
                   ********************************************************************************
C3C6:              banger_diags
                                   ORG     *+$0000
C3C6: 86 01        <span id="SymTSTMEM">TSTMEM</span>          stx     $01
C3C8: 86 02                        stx     $02
C3CA: 86 03                        stx     $03
C3CC: A2 04                        ldx     #4                ;do RAM $100-$FFFF five times
C3CE: 86 04                        stx     $04
C3D0: 85 05        <span id="SymMEM1">MEM1</span>            sta     $05               ;keep acc in a safe place
C3D2: A2 04                        ldx     #4
C3D4: 64 01                        stz     $01
C3D6: E6 01                        inc     1                 ;point to page 1 first
C3D8: A8           <span id="Symmem2">mem2</span>            tay                       ;save ACC in Y for now
C3D9: 8D 83 C0                     sta     <a href="#SymLCBANK2">LCBANK2</a>           ;anticipate not $C000 range...
C3DC: 8D 83 C0                     sta     <a href="#SymLCBANK2">LCBANK2</a>
C3DF: A5 01                        lda     $01               ;get page address
C3E1: 29 F0                        and     #$F0              ;test for $C0-$CF range
C3E3: C9 C0                        cmp     #$C0
C3E5: D0 0C                        bne     <a href="#Symmem3">mem3</a>              ;branch if not...
C3E7: AD 8B C0                     lda     <a href="#SymLCBANK1">LCBANK1</a>
C3EA: AD 8B C0                     lda     <a href="#SymLCBANK1">LCBANK1</a>           ;select primary $D000 space
C3ED: A5 01                        lda     $01
C3EF: 69 0F                        adc     #$0F              ;Plus carry =+$10
C3F1: D0 02                        bne     <a href="#Symmem4">mem4</a>              ;branch always taken
C3F3: A5 01        <span id="Symmem3">mem3</span>            lda     $01
C3F5: 85 03        <span id="Symmem4">mem4</span>            sta     $03
C3F7: 98                           tya                       ;restore pattern to ACC
C3F8: A0 00                        ldy     #$00              ;fill this page with the pattern
C3FA: 18           <span id="Symmem5">mem5</span>            clc
C3FB: 7D 2A C8                     adc     <a href="#Symntbl">ntbl</a>,X
C3FE: 91 02                        sta     ($02),Y
C400: CA                           dex                       ;keep x in the range 0-4
C401: 10 02                        bpl     <a href="#Symmem6">mem6</a>
C403: A2 04                        ldx     #4
C405: C8           <span id="Symmem6">mem6</span>            iny                       ;all 256 filled yet?
C406: D0 F2                        bne     <a href="#Symmem5">mem5</a>              ;branch if not
C408: E6 01                        inc     1                 ;bump page #
C40A: D0 CC                        bne     <a href="#Symmem2">mem2</a>              ;loop through $0100 to $FF00
                   ; 
C40C: E6 01                        inc     $01               ;point to page 1 again
C40E: A2 04                        ldx     #4
C410: A5 05                        lda     $05
C412: A8           <span id="Symmem7">mem7</span>            tay                       ;save ACC in Y for now
C413: AD 83 C0                     lda     <a href="#SymLCBANK2">LCBANK2</a>           ;anticipate not $C000 range...
C416: AD 83 C0                     lda     <a href="#SymLCBANK2">LCBANK2</a>
C419: A5 01                        lda     $01               ;get page address
C41B: 29 F0                        and     #$F0              ;test for $C0-$CF range
C41D: C9 C0                        cmp     #$C0
C41F: D0 09                        bne     <a href="#Symmem8">mem8</a>              ;branch if not...
C421: AD 8B C0                     lda     <a href="#SymLCBANK1">LCBANK1</a>           ;select primary $D000 space
C424: A5 01                        lda     $01
C426: 69 0F                        adc     #$0F              ;Plus carry =+$10
C428: D0 02                        bne     <a href="#Symmem9">mem9</a>              ;branch always taken
C42A: A5 01        <span id="Symmem8">mem8</span>            lda     $01
C42C: 85 03        <span id="Symmem9">mem9</span>            sta     $03
C42E: 98                           tya                       ;restore pattern to ACC
C42F: A0 00                        ldy     #$00              ;fill this page with the pattern
C431: 18           <span id="SymmemA">memA</span>            clc
C432: 7D 2A C8                     adc     <a href="#Symntbl">ntbl</a>,X
C435: 51 02                        eor     ($02),Y
C437: D0 39                        bne     <a href="#SymMEMERROR">MEMERROR</a>          ;if any bits are different, give up!!!
C439: B1 02                        lda     ($02),Y           ;restore correct pattern
C43B: CA                           dex                       ;keep x in range 0-4
C43C: 10 02                        bpl     <a href="#SymmemB">memB</a>
C43E: A2 04                        ldx     #4
C440: C8           <span id="SymmemB">memB</span>            iny                       ;all 256 filled yet?
C441: D0 EE                        bne     <a href="#SymmemA">memA</a>              ;branch if not
C443: E6 01                        inc     1                 ;bump page #
C445: D0 CB                        bne     <a href="#Symmem7">mem7</a>              ;loop through $0100 to $FF00
C447: 6A                           ror     A                 ;change ACC for next pass
C448: 2C 19 C0                     bit     <a href="#SymRDVBLBAR">RDVBLBAR</a>          ; use RDVBL for a little randomness...
C44B: 10 02                        bpl     <a href="#SymmemC">memC</a>
C44D: 49 A5                        eor     #$A5
C44F: C6 04        <span id="SymmemC">memC</span>            dec     $04               ;have 5 passes been done yet?
C451: 30 03                        bmi     <a href="#SymmemD">memD</a>              ;skip if yes
C453: 4C D0 C3                     jmp     <a href="#SymMEM1">MEM1</a>              ;start next pass

C456: AA           <span id="SymmemD">memD</span>            tax                       ;save acc
C457: 2C 13 C0                     bit     <a href="#SymRDRAMRD">RDRAMRD</a>           ;main or aux ram ?
C45A: 30 10                        bmi     <a href="#SymMEMF">MEMF</a>              ;skip if aux ram
C45C: 8A                           txa
C45D: 8D 05 C0                     sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>         ;enable aux mem write
C460: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;enable aux mem read
C463: 8D 09 C0                     sta     <a href="#SymSETALTZP">SETALTZP</a>          ;swap in alt zero page
C466: 8D 81 C0                     sta     <a href="#SymROMIN">ROMIN</a>             ;Force rom enable
C469: 4C 97 D4                     jmp     <a href="#SymTSTZPG">TSTZPG</a>            ; and test it!

C46C: 8D 08 C0     <span id="SymMEMF">MEMF</span>            sta     <a href="#SymSETSTDZP">SETSTDZP</a>          ;swap in main zero page
C46F: 4C EF C4                     jmp     <a href="#SymSWCHTST">SWCHTST</a>

C472: 38           <span id="SymMEMERROR">MEMERROR</span>        sec                       ;indicate main ram failure
C473: AA           <span id="SymBADBITS">BADBITS</span>         tax                       ;save bit battern in x for now
C474: AD 13 C0                     lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;main or aux mem?
C477: B8                           clv                       ;with V-FLG
C478: 10 03                        bpl     <a href="#Symbbits1">bbits1</a>            ;branch if primary bank
C47A: 2C 2A C8                     bit     <a href="#Symsetv">setv</a>
C47D: A9 A0        <span id="Symbbits1">bbits1</span>          lda     #$A0              ;try to clear video screen
C47F: A0 06                        ldy     #$06
C481: 99 FE BF     <span id="Symclrsts">clrsts</span>          sta     <a href="#Symioadr">ioadr</a>-2,Y
C484: 99 06 C0                     sta     <a href="#Symioadr">ioadr</a>+6,Y
C487: 88                           dey
C488: 88                           dey
C489: D0 F6                        bne     <a href="#Symclrsts">clrsts</a>
C48B: 8D 51 C0                     sta     <a href="#SymTXTSET">TXTSET</a>
C48E: 8D 54 C0                     sta     <a href="#SymTXTPAGE1">TXTPAGE1</a>
C491: 99 00 04     <span id="Symclrs">clrs</span>            sta     $0400,Y
C494: 99 00 05                     sta     $0500,Y
C497: 99 00 06                     sta     $0600,Y
C49A: 99 00 07                     sta     $0700,Y
C49D: C8                           iny
C49E: D0 F1                        bne     <a href="#Symclrs">clrs</a>
C4A0: 8A                           txa                       ;test for switch test failure
C4A1: F0 27                        beq     <a href="#SymBADSWTCH">BADSWTCH</a>          ;branch if it was a switch
C4A3: A0 03                        ldy     #3
C4A5: B0 02                        bcs     <a href="#Symbadmain">badmain</a>           ;branch if ZP ok
C4A7: A0 05                        ldy     #5
C4A9: A9 AA        <span id="Symbadmain">badmain</span>         lda     #$AA              ;mark aux report with an asterisks
C4AB: 50 03                        bvc     <a href="#Symbadprim">badprim</a>
C4AD: 8D B0 05                     sta     <a href="#SymSCREEN">SCREEN</a>-8
C4B0: B9 66 C8     <span id="Symbadprim">badprim</span>         lda     <a href="#Symrmess">rmess</a>,Y
C4B3: 99 B1 05                     sta     <a href="#SymSCREEN">SCREEN</a>-7,Y
C4B6: 88                           dey
C4B7: 10 F7                        bpl     <a href="#Symbadprim">badprim</a>           ;message is either "RAM" or "RAM ZP"
C4B9: A0 10                        ldy     #$10              ;print bits
C4BB: 8A           <span id="Symbbits2">bbits2</span>          txa
C4BC: 4A                           lsr     A
C4BD: AA                           tax
C4BE: A9 58                        lda     #$58              ;bits are printed as ascii 0 or 1
C4C0: 2A                           rol     A
C4C1: 99 B6 05                     sta     <a href="#SymSCREEN">SCREEN</a>-2,Y
C4C4: 88                           dey
C4C5: 88                           dey
C4C6: D0 F3                        bne     <a href="#Symbbits2">bbits2</a>
C4C8: F0 FE        <span id="Symhangx">hangx</span>           beq     <a href="#Symhangx">hangx</a>             ;hang forever and ever

C4CA: A2 02        <span id="SymBADSWTCH">BADSWTCH</span>        ldx     #2
C4CC: 7A                           ply
C4CD: 08                           php
C4CE: BD 6C C8     <span id="Symbswtch1">bswtch1</span>         lda     <a href="#Symsmess">smess</a>,X           ;anticipate MMU error
C4D1: 28                           plp
C4D2: 08                           php
C4D3: 90 03                        bcc     <a href="#Symbswtch2">bswtch2</a>           ;branch if not IOU error
C4D5: BD 6F C8                     lda     <a href="#Symsmess">smess</a>+3,X         ;anticipate IOU error
C4D8: C0 06        <span id="Symbswtch2">bswtch2</span>         cpy     #6                ;compare with where we left off
C4DA: 90 0B                        bcc     <a href="#Symbswtch3">bswtch3</a>           ;skip if MMU
C4DC: C0 08                        cpy     #8
C4DE: 90 04                        bcc     <a href="#Symbswtch2a">bswtch2a</a>          ;skip if GLU (ioudis or dhires failure)
C4E0: C0 11                        cpy     #$11
C4E2: 90 03                        bcc     <a href="#Symbswtch3">bswtch3</a>           ;skip if IOU
C4E4: BD 72 C8     <span id="Symbswtch2a">bswtch2a</span>        lda     <a href="#Symsmess">smess</a>+6,X         ;GLU error (ioudis failure)
C4E7: 9D B8 05     <span id="Symbswtch3">bswtch3</span>         sta     <a href="#SymSCREEN">SCREEN</a>,X
C4EA: CA                           dex
C4EB: 10 E1                        bpl     <a href="#Symbswtch1">bswtch1</a>           ;print "MMU","IOU" or "GLU"
C4ED: 30 FE        <span id="Symhangy">hangy</span>           bmi     <a href="#Symhangy">hangy</a>             ;branch forever

C4EF: A0 01        <span id="SymSWCHTST">SWCHTST</span>         ldy     #<a href="#SymMMUIDX">MMUIDX</a>           ;MMUIDX
C4F1: A9 7F        <span id="Symswtst1">swtst1</span>          lda     #$7F
C4F3: 6A           <span id="Symswtst2">swtst2</span>          ror     A                 ;set IOU/MMU switches to match A
C4F4: BE 2F C8                     ldx     <a href="#SymSWTBL0">SWTBL0</a>,Y
C4F7: F0 0F                        beq     <a href="#Symswtst4">swtst4</a>            ;branch if done setting switches
C4F9: 90 03                        bcc     <a href="#Symswtst3">swtst3</a>            ;branch if setting switch to 0-state
C4FB: BE 41 C8                     ldx     <a href="#SymSWTBL1">SWTBL1</a>,Y          ;else get index to set switch to 1
C4FE: 9D FF BF     <span id="Symswtst3">swtst3</span>          sta     <a href="#Symioadr">ioadr</a>-1,X         ;set switch
C501: C8                           iny
C502: D0 EF                        bne     <a href="#Symswtst2">swtst2</a>            ;branch always taken...
                   ; 
C504: AE 30 C0     <span id="Symclick">click</span>           ldx     <a href="#SymSPKR">SPKR</a>
C507: 2A                           rol     A
C508: 88           <span id="Symswtst4">swtst4</span>          dey
C509: BE 53 C8                     ldx     <a href="#SymRSWTBL">RSWTBL</a>,Y          ;now verify the settings just made
C50C: F0 13                        beq     <a href="#Symswtst6">swtst6</a>            ;branch if done this pass
C50E: 30 F4                        bmi     <a href="#Symclick">click</a>             ;branch if this switch no to be verified.
C510: 2A                           rol     A
C511: 90 07                        bcc     <a href="#Symswtst5">swtst5</a>
C513: 1E 00 C0                     asl     <a href="#Symioadr">ioadr</a>,X
C516: 90 1F                        bcc     <a href="#Symswerr">swerr</a>
C518: B0 EE                        bcs     <a href="#Symswtst4">swtst4</a>            ;branch always

C51A: 1E 00 C0     <span id="Symswtst5">swtst5</span>          asl     <a href="#Symioadr">ioadr</a>,X
C51D: B0 18                        bcs     <a href="#Symswerr">swerr</a>
C51F: 90 E7                        bcc     <a href="#Symswtst4">swtst4</a>            ;branch always

C521: 2A           <span id="Symswtst6">swtst6</span>          rol     A                 ;restore original value
C522: C8                           iny                       ; and IOU/MMU index
C523: 38           <span id="SymLC523">LC523</span>           sec
C524: E9 01                        sbc     #1                ;try next pattern
C526: B0 CB                        bcs     <a href="#Symswtst2">swtst2</a>
C528: 88                           dey                       ;was MMU just tested?
C529: F0 08                        beq     <a href="#Symswtst7">swtst7</a>            ;yes, go to IOU
C52B: C0 08                        cpy     #<a href="#SymIOUIDX">IOUIDX</a>-1         ;was IOU just tested?
C52D: D0 10                        bne     <a href="#SymBIGLOOP">BIGLOOP</a>           ;no, go loop again
C52F: A0 11                        ldy     #<a href="#SymGLUIDX">GLUIDX</a>           ;yes, go test IOUDIS switch
C531: D0 BE                        bne     <a href="#Symswtst1">swtst1</a>            ;branch always

C533: A0 09        <span id="Symswtst7">swtst7</span>          ldy     #<a href="#SymIOUIDX">IOUIDX</a>
C535: D0 BA                        bne     <a href="#Symswtst1">swtst1</a>            ;branch always

C537: 5A           <span id="Symswerr">swerr</span>           phy                       ;save y to distinguish from MMU or GLU
                   ;                                       ;failure
C538: A2 00                        ldx     #0                ;indicate switch error
C53A: C0 0A                        cpy     #<a href="#SymIOUIDX">IOUIDX</a>+1         ;set carry if IOU was cause
C53C: 4C 7D C4                     jmp     <a href="#Symbbits1">bbits1</a>

C53F: 46 80        <span id="SymBIGLOOP">BIGLOOP</span>         lsr     $80
C541: D0 AC                        bne     <a href="#SymSWCHTST">SWCHTST</a>
C543: A9 A0        <span id="Symblp2">blp2</span>            lda     #$A0
C545: A0 00                        ldy     #0
C547: 99 00 04     <span id="Symblp3">blp3</span>            sta     $0400,Y           ;clear screen for susccess message
C54A: 99 00 05                     sta     $0500,Y
C54D: 99 00 06                     sta     $0600,Y
C550: 99 00 07                     sta     $0700,Y
C553: C8                           iny
C554: D0 F1                        bne     <a href="#Symblp3">blp3</a>
C556: AD 61 C0     <span id="Symblp4">blp4</span>            lda     <a href="#SymBUTN0">BUTN0</a>             ;test for both Open and Closed Apple
C559: 2D 62 C0                     and     <a href="#SymBUTN1">BUTN1</a>             ; pressed
C55C: 0A                           asl     A                 ;put result in carry
C55D: E6 FF                        inc     $FF
C55F: A5 FF                        lda     $FF
C561: 90 03                        bcc     <a href="#Symdquit">dquit</a>
C563: 4C 8E D4                     jmp     <a href="#Symdiags">diags</a>

C566: AD 51 C0     <span id="Symdquit">dquit</span>           lda     <a href="#SymTXTSET">TXTSET</a>            ;put success message on the screen
C569: A0 08                        ldy     #8
C56B: B9 75 C8     <span id="Symsuc2">suc2</span>            lda     <a href="#Symsuccess">success</a>,Y
C56E: 99 B8 05                     sta     <a href="#SymSCREEN">SCREEN</a>,Y
C571: 88                           dey
C572: 10 F7                        bpl     <a href="#Symsuc2">suc2</a>
C574: 30 E0                        bmi     <a href="#Symblp4">blp4</a>              ;loop forever

C576: 00 00 00 00+                 DS      10,$00

                   ********************************************************************************
                   * PREAD - Reads bytes from card into the Apple                                 *
                   * D7 of the address = 1 if aux ram                                             *
                   ********************************************************************************
C580: DA           <span id="Symsl_pread">sl_pread</span>        phx
C581: AE 78 06                     ldx     <a href="#Symsl_lcstate">sl_lcstate</a>
C584: FE 00 C0                     inc     $C000,X
C587: FA                           plx
C588: A5 49                        lda     <a href="#Sympaddr">paddr</a>
C58A: 9D F8 BF                     sta     <a href="#Symaddrl">addrl</a>,X
C58D: A5 4A                        lda     <a href="#Sympaddr">paddr</a>+1
C58F: 9D F9 BF                     sta     <a href="#Symaddrm">addrm</a>,X
C592: A5 4B                        lda     <a href="#Sympaddr">paddr</a>+2
C594: 29 7F                        and     #$7F
C596: D9 B8 03                     cmp     <a href="#Symnumbanks">numbanks</a>,Y
C599: B0 53                        bcs     <a href="#Symprbad">prbad</a>
C59B: 9D FA BF                     sta     <a href="#Symaddrh">addrh</a>,X
C59E: 2C 14 C0                     bit     <a href="#SymRDRAMWRT">RDRAMWRT</a>
C5A1: 08                           php
C5A2: 8D 04 C0                     sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>
C5A5: 24 4B                        bit     <a href="#Sympaddr">paddr</a>+2
C5A7: 10 03                        bpl     <a href="#Symprmain">prmain</a>
C5A9: 8D 05 C0                     sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>
C5AC: A0 00        <span id="Symprmain">prmain</span>          ldy     #0
C5AE: A5 48                        lda     <a href="#Sympcount">pcount</a>+1
C5B0: 8D F8 05                     sta     <a href="#Symyval">yval</a>
C5B3: F0 14                        beq     <a href="#Symprlast">prlast</a>
C5B5: BD FB BF     <span id="Symprloop">prloop</span>          lda     <a href="#Symdata">data</a>,X
C5B8: 91 45                        sta     (<a href="#Symcompdata">compdata</a>),Y
C5BA: C8                           iny
C5BB: BD FB BF                     lda     <a href="#Symdata">data</a>,X
C5BE: 91 45                        sta     (<a href="#Symcompdata">compdata</a>),Y
C5C0: C8                           iny
C5C1: D0 F2                        bne     <a href="#Symprloop">prloop</a>
C5C3: E6 46                        inc     <a href="#Sympbuff">pbuff</a>+1
C5C5: C6 48                        dec     <a href="#Sympcount">pcount</a>+1
C5C7: D0 EC                        bne     <a href="#Symprloop">prloop</a>
C5C9: A5 47        <span id="Symprlast">prlast</span>          lda     <a href="#Sympcount">pcount</a>
C5CB: F0 16                        beq     <a href="#Symprdone">prdone</a>
C5CD: 8D 78 05                     sta     <a href="#Symxval">xval</a>
C5D0: 4A                           lsr     A
C5D1: B0 06                        bcs     <a href="#Symprodd">prodd</a>
C5D3: BD FB BF     <span id="Symprloop2">prloop2</span>         lda     <a href="#Symdata">data</a>,X
C5D6: 91 45                        sta     (<a href="#Symcompdata">compdata</a>),Y
C5D8: C8                           iny
C5D9: BD FB BF     <span id="Symprodd">prodd</span>           lda     <a href="#Symdata">data</a>,X
C5DC: 91 45                        sta     (<a href="#Symcompdata">compdata</a>),Y
C5DE: C8                           iny
C5DF: C4 47                        cpy     <a href="#Sympcount">pcount</a>
C5E1: D0 F0                        bne     <a href="#Symprloop2">prloop2</a>
C5E3: 8D 04 C0     <span id="Symprdone">prdone</span>          sta     <a href="#SymWRMAINRAM">WRMAINRAM</a>
C5E6: 28                           plp
C5E7: 10 03                        bpl     <a href="#Symprmain2">prmain2</a>
C5E9: 8D 05 C0                     sta     <a href="#SymWRCARDRAM">WRCARDRAM</a>
C5EC: 80 05        <span id="Symprmain2">prmain2</span>         bra     <a href="#Symprbadz">prbadz</a>

C5EE: A9 2D        <span id="Symprbad">prbad</span>           lda     #<a href="#Symbadblk">badblk</a>           ;Invalid address
C5F0: 8D F8 04                     sta     <a href="#Symerror">error</a>
C5F3: 8D 81 C0     <span id="Symprbadz">prbadz</span>          sta     <a href="#SymROMIN">ROMIN</a>             ;put the rom back in
C5F6: 60                           rts

                   ********************************************************************************
                   * PWRITE - Writes bytes from Apple to card                                     *
                   * D7 of the address = 1 if aux ram                                             *
                   ********************************************************************************
C5F7: DA           <span id="Symsl_pwrite">sl_pwrite</span>       phx                       ;save x
C5F8: AE 78 06                     ldx     <a href="#Symsl_lcstate">sl_lcstate</a>        ;get language card state
C5FB: FE 00 C0                     inc     $C000,X           ;restore it, the rom is ayway
C5FE: FA                           plx                       ;restore x
                   ; 
C5FF: A5 49                        lda     <a href="#Sympaddr">paddr</a>             ;Move the address
C601: 9D F8 BF                     sta     <a href="#Symaddrl">addrl</a>,X
C604: A5 4A                        lda     <a href="#Sympaddr">paddr</a>+1
C606: 9D F9 BF                     sta     <a href="#Symaddrm">addrm</a>,X
C609: A5 4B                        lda     <a href="#Sympaddr">paddr</a>+2
C60B: 29 7F                        and     #$7F              ;Mask off high bit
C60D: D9 B8 03                     cmp     <a href="#Symnumbanks">numbanks</a>,Y        ;Valid address
C610: B0 DC                        bcs     <a href="#Symprbad">prbad</a>
C612: 9D FA BF                     sta     <a href="#Symaddrh">addrh</a>,X
C615: 2C 13 C0                     bit     <a href="#SymRDRAMRD">RDRAMRD</a>           ;Save current back
C618: 08                           php
C619: 8D 02 C0                     sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;Assume main
C61C: 24 4B                        bit     <a href="#Sympaddr">paddr</a>+2           ;If D7 = 1 then aux
C61E: 10 03                        bpl     <a href="#Sympwmain">pwmain</a>
C620: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;Its the card ram
C623: A0 00        <span id="Sympwmain">pwmain</span>          ldy     #0
C625: A5 48                        lda     <a href="#Sympcount">pcount</a>+1          ;More than a page to move?
C627: 8D F8 05                     sta     <a href="#Symyval">yval</a>
C62A: F0 14                        beq     <a href="#Sympwlast">pwlast</a>
C62C: B1 45        <span id="Sympwloop">pwloop</span>          lda     (<a href="#Symcompdata">compdata</a>),Y      ;Get a byte
C62E: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
C631: C8                           iny
C632: B1 45                        lda     (<a href="#Symcompdata">compdata</a>),Y
C634: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
C637: C8                           iny
C638: D0 F2                        bne     <a href="#Sympwloop">pwloop</a>
C63A: E6 46                        inc     <a href="#Sympbuff">pbuff</a>+1           ;Bump buffer pointer to next page
C63C: C6 48                        dec     <a href="#Sympcount">pcount</a>+1          ;Dec page count
C63E: D0 EC                        bne     <a href="#Sympwloop">pwloop</a>
C640: A5 47        <span id="Sympwlast">pwlast</span>          lda     <a href="#Sympcount">pcount</a>            ;Any bytes left to do?
C642: 8D 78 05                     sta     <a href="#Symxval">xval</a>
C645: F0 13                        beq     <a href="#Sympwdone">pwdone</a>
C647: 4A                           lsr     A                 ;C = 1 if odd # of bytes
C648: B0 06                        bcs     <a href="#Sympwodd">pwodd</a>
C64A: B1 45        <span id="Sympwloop2">pwloop2</span>         lda     (<a href="#Symcompdata">compdata</a>),Y
C64C: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
C64F: C8                           iny
C650: B1 45        <span id="Sympwodd">pwodd</span>           lda     (<a href="#Symcompdata">compdata</a>),Y
C652: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
C655: C8                           iny
C656: C4 47                        cpy     <a href="#Sympcount">pcount</a>
C658: D0 F0                        bne     <a href="#Sympwloop2">pwloop2</a>
C65A: 8D 02 C0     <span id="Sympwdone">pwdone</span>          sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>         ;Fix main / aux ram
C65D: 28                           plp
C65E: 10 03                        bpl     <a href="#Sympwmain2">pwmain2</a>
C660: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>
C663: 8D 81 C0     <span id="Sympwmain2">pwmain2</span>         sta     <a href="#SymROMIN">ROMIN</a>             ;put the rom back in
C666: 60                           rts

                   ; ****************************************
                   ; * Various data tables
                   ; ****************************************
                   ; 
                   ; Status info table
C667: F8           <span id="Symstattbl">stattbl</span>         DFB     $F8               ;Status byte
C668: 00 00 00                     HEX     $00,$00,$00       ;Size
C66B: 07                           DFB     7                 ;Name length
C66C: 52 41 4D 43+                 ASC     RAMCARD
C673: 20 20 20 20+                 ASC              
C67C: 00 00                        DW      0                 ;Type subtype
C67E: 01 01                        DW      <a href="#Symrevnum">revnum</a>            ;Version
                   ; 
C680: 03 03 03     <span id="Symparmtbl">parmtbl</span>         HEX     $03,$03,$03       ;Table of parameters
C683: 03 03 03                     HEX     $03,$03,$03
C686: 01 01 03                     HEX     $01,$01,$03
C689: 03 01 01                     HEX     $03,$01,$01
C68C: 01 01 01                     HEX     $01,$01,$01
C68F: 01 04 04                     HEX     $01,$04,$04
C692: 04 04 FF                     HEX     $04,$04,$FF
C695: FF FF FF                     HEX     $FF,$FF,$FF
C698: FF FF                        HEX     $FF,$FF
                   ; 
                   ;                        ;Table of command addresses
C69A: 52           <span id="Symcmdtbl">cmdtbl</span>          DFB     &lt;<a href="#Sympstat0">pstat0</a>-1         ;Status unit 0
C69B: 73                           DFB     &lt;<a href="#Symsl_pstatus">sl_pstatus</a>-1     ;Status
C69C: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Read block unit 0
C69D: B8                           DFB     &lt;<a href="#Symprdblk">prdblk</a>-1         ;Read block
C69E: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Write block unit 0
C69F: BC                           DFB     &lt;<a href="#Sympwrblk">pwrblk</a>-1         ;Write block
C6A0: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Format unit 0
C6A1: 38                           DFB     &lt;<a href="#Symiorts">iorts</a>-1          ;Format
C6A2: 69                           DFB     &lt;<a href="#Sympcntl">pcntl</a>-1          ;Control Unit 0
C6A3: 69                           DFB     &lt;<a href="#Sympcntl">pcntl</a>-1          ;Control
C6A4: 38                           DFB     &lt;<a href="#Symiorts">iorts</a>-1          ;Init unit 0
C6A5: 38                           DFB     &lt;<a href="#Symiorts">iorts</a>-1          ;Init
C6A6: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Open unit 0
C6A7: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Open
C6A8: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Close until 0
C6A9: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Close
C6AA: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Read until 0
C6AB: 39                           DFB     &lt;<a href="#Sympread2_z">pread2_z</a>-1       ;Read
C6AC: 2F                           DFB     &lt;<a href="#Sympzcmd">pzcmd</a>-1          ;Write unit 0
C6AD: 3C                           DFB     &lt;<a href="#Sympwrite2">pwrite2</a>-1        ;Write
C6AE: 45                           DFB     &lt;<a href="#Symxstatus">xstatus</a>-1        ;ProDOS status call
C6AF: 9D                           DFB     &lt;<a href="#Symxread">xread</a>-1          ;ProDOS read call
C6B0: A1                           DFB     &lt;<a href="#Symxwrite">xwrite</a>-1         ;ProDOS write call
C6B1: 38                           DFB     &lt;<a href="#Symiorts">iorts</a>-1          ;ProDOS format call
C6B2: 3F                           DFB     &lt;<a href="#Symdosconv2">dosconv2</a>-1       ;Dos Command
C6B3: 42                           DFB     &lt;<a href="#Symxdiag">xdiag</a>-1          ;Diagnostics !

C6B4: DA           <span id="SymswsL_bt">swsL_bt</span>         phx                       ;save x
C6B5: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language state
C6B8: 5A                           phy                       ;save it
C6B9: 8C 78 06                     sty     <a href="#Symsl_lcstate">sl_lcstate</a>        ;save it here too
C6BC: 20 EF D8                     jsr     <a href="#Symbool_sl">bool_sl</a>           ;do the boot
C6BF: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C6C2: DA           <span id="Symsw_setmou">sw_setmou</span>       phx                       ;save x
C6C3: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C6C6: 5A                           phy                       ;save it
C6C7: 20 21 D6                     jsr     <a href="#Symx_setmou">x_setmou</a>          ;set the mouse mode to a
C6CA: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C6CD: DA           <span id="Symsw_mtstint">sw_mtstint</span>      phx                       ;save x
C6CE: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C6D1: 5A                           phy                       ;save it
C6D2: 20 C2 D6                     jsr     <a href="#Symx_mtstint">x_mtstint</a>         ;check mouse status bits
C6D5: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C6D8: DA           <span id="Symsw_mread">sw_mread</span>        phx                       ;save x
C6D9: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C6DC: 5A                           phy                       ;save it
C6DD: 20 79 D6                     jsr     <a href="#Symx_mread">x_mread</a>           ;updates the mouse screen holes
C6E0: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C6E3: DA           <span id="Symsw_mclear">sw_mclear</span>       phx                       ;save x
C6E4: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C6E7: 5A                           phy                       ;save it
C6E8: 20 68 D6                     jsr     <a href="#Symx_mclear">x_mclear</a>          ;sets the mouse to 0,0
C6EB: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C6EE: DA           <span id="Symsw_mclamp">sw_mclamp</span>       phx                       ;save x
C6EF: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C6F2: 5A                           phy                       ;save it
C6F3: 20 A3 D6                     jsr     <a href="#Symx_mclamp">x_mclamp</a>          ;store new mouse bounds
C6F6: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C6F9: DA           <span id="Symsw_mhome">sw_mhome</span>        phx                       ;save x
C6FA: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C6FD: 5A                           phy                       ;save it
C6FE: 20 51 D6                     jsr     <a href="#Symx_mhome">x_mhome</a>           ;clear mouse position and status
C701: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C704: DA           <span id="Symsw_initmouse">sw_initmouse</span>    phx                       ;save x
C705: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C708: 5A                           phy                       ;save it
C709: 20 00 D6                     jsr     <a href="#Symi_nitmouse">i_nitmouse</a>        ;reset the mouse
C70C: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C70F: 00 00 00 00+                 DS      13,$00

                   ********************************************************************************
                   * the following code had better start at $C71C or else                         *
                   ********************************************************************************
C71C: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C71F: 4C C2 C6                     jmp     <a href="#Symsw_setmou">sw_setmou</a>         ;do the real thing

C722: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C725: 4C CD C6                     jmp     <a href="#Symsw_mtstint">sw_mtstint</a>        ;do the real thing

C728: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C72B: 4C D8 C6                     jmp     <a href="#Symsw_mread">sw_mread</a>          ;do the real thing

C72E: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C731: 4C E3 C6                     jmp     <a href="#Symsw_mclear">sw_mclear</a>         ;do the real thing

C734: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C737: 4C EE C6                     jmp     <a href="#Symsw_mclamp">sw_mclamp</a>         ;do the real thing

C73A: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C73D: 4C F9 C6                     jmp     <a href="#Symsw_mhome">sw_mhome</a>          ;do the real thing

C740: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C743: 4C 04 C7                     jmp     <a href="#Symsw_initmouse">sw_initmouse</a>      ;do the real thing

C746: 8D 28 C0     <span id="Symm__oveirq">m__oveirq</span>       sta     <a href="#SymROMBANK">ROMBANK</a>
C749: 4C 9A CF                     jmp     <a href="#Symm_oveirq">m_oveirq</a>

C74C: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C74F: 4C B4 C6                     jmp     <a href="#SymswsL_bt">swsL_bt</a>

C752: 8D 28 C0                     sta     <a href="#SymROMBANK">ROMBANK</a>
C755: DA                           phx                       ;save x
C756: 20 16 C8                     jsr     <a href="#Symgetlc">getlc</a>             ;get language card state
C759: 5A                           phy                       ;save it
C75A: 8C 78 06                     sty     <a href="#Symsl_lcstate">sl_lcstate</a>        ;save it here too
C75D: 20 00 D8                     jsr     <a href="#Symexecute">execute</a>           ;do something with slinky
C760: 4C 0E C8                     jmp     <a href="#Symfixlc">fixlc</a>             ;restore language card state and return

C763: 00 00 00 00+                 DS      29,$00
                   ********************************************************************************
                   *                                                                              *
                   * Switching Routines                                                           *
                   *                                                                              *
                   * jl notes: This section is left undecoded because it jumps to places in Main  *
                   * Bank, which is not in this list. See separate decode project for the jump    *
                   * tables of the Main and Aux ROM.                                              *
                   *                                                                              *
                   ********************************************************************************
C780:              bank_swp_table
                                   ORG     *+$0000
C780: 8D 28 C0 40                  HEX     $8D,$28,$C0,$40
C784: 8D 28 C0 60+ <span id="Symswrts2">swrts2</span>          HEX     $8D,$28,$C0,$60,$8D,$28,$C0,$4C
                                    +      $62,$FA,$8D,$28,$C0,$2C,$87,$C7
C794: 4C 04 C8                     HEX     $4C,$04,$C8
C797: 8D 28 C0 4C+ <span id="Symswsthk2">swsthk2</span>         HEX     $8D,$28,$C0,$4C,$80,$C8
C79D: 8D 28 C0 4C+ <span id="Symswzzqt2">swzzqt2</span>         HEX     $8D,$28,$C0,$4C,$00,$D4,$8D,$28
                                    +      $C0,$4C,$F1,$C7,$8D,$28,$C0,$4C
C7AD: 06 C8 8D 28+                 HEX     $06,$C8,$8D,$28,$C0,$4C,$4E,$C3
                                    +      $8D,$28,$C0,$4C,$97,$C3,$8D,$28
C7BD: C0 4C 00 C1+                 HEX     $C0,$4C,$00,$C1,$8D,$28,$C0,$4C
                                    +      $8E,$D4,$8D,$28,$C0,$4C,$80,$C5
C7CD: 8D 28 C0 4C+                 HEX     $8D,$28,$C0,$4C,$4F,$C2,$8D,$28
                                    +      $C0,$4C,$AC,$C2,$8D,$28,$C0,$4C
C7DD: C3 C2 8D 28+                 HEX     $C3,$C2,$8D,$28,$C0,$4C,$F7,$C2
                                    +      $8D,$28,$C0,$4C,$C5,$D4
C7EB: 8D 28 C0 6C+ <span id="SymSWXFGO2">SWXFGO2</span>         HEX     $8D,$28,$C0,$6C,$ED,$03,$DA,$20
                                    +      $16,$C8,$5A,$20,$A0,$D1,$80,$13
                                   ADREND   $C780

C7FB: 00 00 00 00+                 DS      8,$00
C803: 4C                           DFB     $4C
C804: 8E                           DFB     $8E
C805: C7                           DFB     $C7
C806: DA                           DFB     $DA
C807: 20                           DFB     $20
C808: 16                           DFB     $16
C809: C8                           DFB     $C8
C80A: 5A                           DFB     $5A
C80B: 20                           DFB     $20
C80C: 00                           DFB     $00
C80D: D0                           DFB     $D0

C80E: FA           <span id="Symfixlc">fixlc</span>           plx
C80F: FE 00 C0                     inc     <a href="#SymLC000">LC000</a>,X
C812: FA                           plx
C813: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

                   ********************************************************************************
                   * GETLC - Gets language card state in Y                                        *
                   ********************************************************************************
C816: A0 81        <span id="Symgetlc">getlc</span>           ldy     #$81
C818: 2C 12 C0                     bit     <a href="#SymRDLCRAM">RDLCRAM</a>           ;Language card enabled?
C81B: 10 0C                        bpl     <a href="#Symglcdone">glcdone</a>
C81D: A0 8B                        ldy     #$8B
C81F: 2C 11 C0                     bit     <a href="#SymRDLCBNK2">RDLCBNK2</a>          ;Bank 2?
C822: 10 02                        bpl     <a href="#Symglcbnk1">glcbnk1</a>
C824: A0 83                        ldy     #$83              ;Bank 1!
C826: 8D 81 C0     <span id="Symglcbnk1">glcbnk1</span>         sta     <a href="#SymROMIN">ROMIN</a>
C829: 60           <span id="Symglcdone">glcdone</span>         rts

C82A: 53 43 2B 29+ <span id="Symntbl">ntbl</span>            HEX     $53,$43,$2B,$29,$07 ;83,67,43,41,7
C82F: 00 89 03 05+ <span id="SymSWTBL0">SWTBL0</span>          HEX     $00,$89,$03,$05,$09,$01,$7F,$5F
C837: 00 83 51 53+                 HEX     $00,$83,$51,$53,$55,$57,$0F,$0D
                                    +      $00,$80
C841: 00 81 04 06+ <span id="SymSWTBL1">SWTBL1</span>          HEX     $00,$81,$04,$06,$0A,$02,$7F,$60
C849: 00 84 52 54+                 HEX     $00,$84,$52,$54,$56,$58,$10,$0E
                                    +      $00,$7F
C853: 00 11 13 14+ <span id="SymRSWTBL">RSWTBL</span>          HEX     $00,$11,$13,$14,$16,$18,$FF,$7F
C85B: 00 12 1A 1B+                 HEX     $00,$12,$1A,$1B,$1C,$1D,$1E,$1F
                                    +      $00,$7E,$00
C866: D2 C1 CD A0+ <span id="Symrmess">rmess</span>           ASC     RAM ZP
C86C: CD CD D5 C9+ <span id="Symsmess">smess</span>           ASC     MMUIOUGLU
                   ; 
                   ; 
C875: D3 F9 F3 F4+ <span id="Symsuccess">success</span>         ASC     System OK
C87E: 00 00                        DW      $0000
                   NOTE: pdf page 510
                   ********************************************************************************
                   * The //c bank switch jumps here for pcnv (protocol converter)                 *
                   ********************************************************************************
C880: 4C           <span id="Sympcnv">pcnv</span>            DFB     $4C
C881: 4C                           DFB     $4C
C882: CD                           DFB     $CD

                   ****************************************************************
                   *                                                              *
                   * SendOnePack                   Send a CBUS Packet             *
                   *                                                              *
                   *   This routine sends a packet of data across the             *
                   * bus.  The protocol is as follows:                            *
                   *              ___________________________                     *
                   *  REQ _______|2                         5|___________         *
                   *         _______________________________                      *
                   * /BSY___|1              3              4|____________         *
                   *                                                              *
                   *    1)  Device signals ready for data                         *
                   *    2)  Host signals data iminent                             *
                   *    3)  Packet is transmitted (sync, command mark,            *
                   *         ids, contents, checksum [msb=1])                     *
                   *    4)  Device signals packet received                        *
                   *    5)  Host finishes send data cycle                         *
                   *                                                              *
                   *    The bytes are sent in slow mode (32 cycles/byte)          *
                   *  and the timing is critical.  Branches which should          *
                   *  not cross page boundaries are marked.                       *
                   *                                                              *
                   *                                                              *
                   *   Input:  buffer (2 bytes) &lt;- ptr to data to send            *
                   *           bytecount (2)    &lt;- length (bytes) of data         *
                   *           packettype (1)   &lt;- command or data packet         *
                   *           CMDUnit (1)      &lt;- # of device to receive         *
                   *                                                              *
                   *  Output: carry set- handshake error                          *
                   *                clr- bytes sent                               *
                   *                                                              *
                   ****************************************************************
C883: 20 61 CB     <span id="SymSendOnePack">SendOnePack</span>     jsr     <a href="#SymWritePrep">WritePrep</a>         ;Does a bunch of stuff
                   ; 
                   ; Enable PC chain.
                   ; 
C886: 20 7D CA                     jsr     <a href="#Symenablechain">enablechain</a>       ;This set X reg
C889: A0 07                        ldy     #<a href="#Symiwmmode">iwmmode</a>          ;This is the mode value
C88B: 20 20 CC                     jsr     <a href="#SymSetIWMode">SetIWMode</a>         ;Don't mess unless we gotta
                   ; 
                   ; Turn on the IWM
                   ; 
C88E: BD 8B C0                     lda     <a href="#Symenable2">enable2</a>,X         ;Don't disturb //c internal drive
C891: BD 89 C0                     lda     <a href="#Symmonset">monset</a>,X
                   ; 
                   ; Loop until the chain becomes unbusy
                   ; 
C894: A0 32                        ldy     #$32              ;Each loop is 11 microseconds
C896: BD 8E C0     <span id="Symubsy1">ubsy1</span>           lda     <a href="#Syml7clr">l7clr</a>,X           ;Test if /BSY is hi or low
C899: 30 07                        bmi     <a href="#Symchainunbsy">chainunbsy</a>        ;If hi, busy is not busy
C89B: 88                           dey
C89C: D0 F8                        bne     <a href="#Symubsy1">ubsy1</a>             ;Keep trying
C89E: 38                           sec
C89F: 4C CC C9                     jmp     <a href="#Symsd10">sd10</a>

                   ; 
                   ; Tell the bus that data is coming and send the sync bytes
                   ;   Sync is groups of eight 2's separated by a 6 (micS cell)
                   ;   (111111110011111111001111111100 ...)
                   ; 
C8A2: BD 81 C0     <span id="Symchainunbsy">chainunbsy</span>      lda     <a href="#Symreqset">reqset</a>,X          ;Raise REQ
                   ; 
C8A5: A0 05                        ldy     #$05              ;Sync plus packet begin
                   ; 
C8A7: A9 FF                        lda     #$FF              ;Send out the 1st byte sync
C8A9: 9D 8F C0                     sta     <a href="#Syml7set">l7set</a>,X
                   ; 
C8AC: B9 D3 C9     <span id="Symssb">ssb</span>             lda     <a href="#Sympreamble">preamble</a>,Y
                   ; 
                   ; 
C8AF: 1E 8C C0     <span id="Symssd">ssd</span>             asl     <a href="#Syml6clr">l6clr</a>,X           ;Wait 'til buffer empty
C8B2: 90 FB                        bcc     <a href="#Symssd">ssd</a>
                   ; 
C8B4: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X
C8B7: 88                           dey
C8B8: 10 F2                        bpl     <a href="#Symssb">ssb</a>               ;Back for more bytes
                   ; 
                   ; Send over the desination ID
                   ; 
C8BA: A5 5A                        lda     <a href="#SymUnit">Unit</a>
C8BC: 09 80                        ora     #$80              ;Make the device ID
C8BE: 20 50 CA                     jsr     <a href="#Symsendbyte">sendbyte</a>
                   ; 
                   ; Send the source ID (that's us... we're an $80)
                   ; 
C8C1: 20 4E CA                     jsr     <a href="#Symsend80">send80</a>
                   ; 
                   ; Send over the packet type (command or data)
                   ; 
C8C4: A5 5B                        lda     <a href="#SymWpacketType">WpacketType</a>
C8C6: 20 50 CA                     jsr     <a href="#Symsendbyte">sendbyte</a>
                   ; 
                   ; Send the Auxilliary Type byte (an $80 from this rev PC)
                   ; 
C8C9: 20 4E CA                     jsr     <a href="#Symsend80">send80</a>
                   ; 
                   ; Send the status byte (null for us), and length bytes
                   ; 
C8CC: 20 4E CA                     jsr     <a href="#Symsend80">send80</a>
C8CF: A5 4C                        lda     <a href="#Symoddbytes">oddbytes</a>
C8D1: 09 80                        ora     #$80
C8D3: 20 50 CA                     jsr     <a href="#Symsendbyte">sendbyte</a>
C8D6: A5 4B                        lda     <a href="#Symgrp7ctr">grp7ctr</a>
C8D8: 09 80                        ora     #$80
C8DA: 20 50 CA                     jsr     <a href="#Symsendbyte">sendbyte</a>
                   ; 
                   ; Now send the "oddbytes" part of the packet contents
                   ; 
C8DD: A5 4C                        lda     <a href="#Symoddbytes">oddbytes</a>          ;Get # of "odd" bytes
C8DF: F0 15                        beq     <a href="#Symsob2">sob2</a>              ;Skip if no odd bytes
                   ; 
C8E1: A0 FF                        ldy     #$FF
C8E3: A5 59                        lda     <a href="#Symtbodd">tbodd</a>             ;Get the odd bytes msb's (A[7]=1)
                   ; 
C8E5: 1E 8C C0     <span id="Symsob1">sob1</span>            asl     <a href="#Syml6clr">l6clr</a>,X           ;Do a write handshake
C8E8: 90 FB                        bcc     <a href="#Symsob1">sob1</a>
C8EA: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X
C8ED: C8                           iny
C8EE: B1 54                        lda     ($54),Y           ;Get the data byte
C8F0: 09 80                        ora     #$80              ;Flip on the hi bit
C8F2: C4 4C                        cpy     <a href="#Symoddbytes">oddbytes</a>          ;Are we done?
C8F4: 90 EF                        bcc     <a href="#Symsob1">sob1</a>
                   ; 
                   ; Now send over the groups of seven contents
                   ; Currently assume there must be at least one group of 'em
                   ; 
C8F6: A5 4B        <span id="Symsob2">sob2</span>            lda     <a href="#Symgrp7ctr">grp7ctr</a>           ;Check if there are groups to send
C8F8: D0 03                        bne     <a href="#Symsob3">sob3</a>              ;=&gt; At least one group
C8FA: 4C 96 C9                     jmp     <a href="#Symdatdone">datdone</a>           ;Skip to send checksum

C8FD: EA           <span id="Symsob3">sob3</span>            nop                       ;Waste 2 cycles
C8FE: A0 00                        ldy     #$00
C900: A5 41        <span id="Symstart">start</span>           lda     <a href="#Symtopbits">topbits</a>
C902: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X
                   ; 
                   ; Send first byte
                   ; 
C905: A5 4D                        lda     <a href="#Symbytecount">bytecount</a>
C907: 09 80                        ora     #$80
C909: 84 59                        sty     &lt;<a href="#Symtemp">temp</a>+97          ;Swap Y for short handshake
C90B: BC 8C C0     <span id="Symachel">achel</span>           ldy     <a href="#Syml6clr">l6clr</a>,X           ;Wait 'til buffer ready
C90E: 10 FB                        bpl     <a href="#Symachel">achel</a>
C910: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Send the byte
C913: A4 59                        ldy     &lt;<a href="#Symtemp">temp</a>+97          ;Get back Y
                   ; 
                   ; Prep the next "1st" byte for next time
                   ; 
C915: B1 56                        lda     (<a href="#Symauxptr">auxptr</a>),Y
C917: 85 4D                        sta     <a href="#Symbytecount">bytecount</a>
C919: 0A                           asl     A
C91A: 26 41                        rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
C91C: C8                           iny                       ;Next Byte
                   ; 
                   ; It's possible that we're at a page boundary now. If so, bump the
                   ;  hi order part of the pointer.
                   ; 
C91D: D0 05                        bne     <a href="#Symskip1">skip1</a>
C91F: E6 57                        inc     <a href="#Symbuffer2">buffer2</a>+1
C921: 4C 26 C9                     jmp     <a href="#Symskip2">skip2</a>

C924: 48           <span id="Symskip1">skip1</span>           pha                       ;Equalize the cases
C925: 68                           pla
                   ; 
                   ; Push us ahead by an additional 8 cycles for margin reasons
                   ;  Plus I gotta get the topbits MSB set somehow...
                   ; 
C926: A9 02        <span id="Symskip2">skip2</span>           lda     #%00000010        ;Flip what will be MSB
C928: 05 41                        ora     <a href="#Symtopbits">topbits</a>
C92A: 85 41                        sta     <a href="#Symtopbits">topbits</a>
                   ; 
                   ; Send the second byte
                   ; 
C92C: A5 4E                        lda     <a href="#SymAuxType">AuxType</a>
C92E: 09 80                        ora     #$80
C930: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Send the byte
C933: B1 56                        lda     (<a href="#Symauxptr">auxptr</a>),Y
C935: 85 4E                        sta     <a href="#SymAuxType">AuxType</a>
C937: 0A                           asl     A
C938: 26 41                        rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
C93A: C8                           iny                       ;Next byte
                   ; 
                   ; Send the third byte
                   ; 
C93B: A5 4F                        lda     <a href="#Symnext3">next3</a>
C93D: 09 80                        ora     #$80
C93F: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Send the byte
C942: B1 56                        lda     (<a href="#Symauxptr">auxptr</a>),Y
C944: 85 4F                        sta     <a href="#Symnext3">next3</a>
C946: 0A                           asl     A
C947: 26 41                        rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
C949: C8                           iny                       ;Next byte
                   ; 
                   ; Send the fourth byte
                   ; 
C94A: A5 50                        lda     <a href="#SymDeviceID">DeviceID</a>
C94C: 09 80                        ora     #$80
C94E: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Send the byte
C951: B1 56                        lda     (<a href="#Symauxptr">auxptr</a>),Y
C953: 85 50                        sta     <a href="#SymDeviceID">DeviceID</a>
C955: 0A                           asl     A
C956: 26 41                        rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
C958: C8                           iny                       ;next byte
                   ; 
                   ; After the first 256 bytes, we will cross pages here.  If we did
                   ;  cross, bump the buffer pointer. If not, equalize the cases with
                   ;  seven cycles of time wasting.
                   ; 
C959: D0 05                        bne     <a href="#Symskip3">skip3</a>
C95B: E6 57                        inc     <a href="#Symbuffer2">buffer2</a>+1
C95D: 4C 62 C9                     jmp     <a href="#Symskip4">skip4</a>

C960: 48           <span id="Symskip3">skip3</span>           pha
C961: 68                           pla
                   ; 
                   ; Send the fifth byte
                   ; 
C962: A5 51        <span id="Symskip4">skip4</span>           lda     <a href="#SymHostID">HostID</a>
C964: 09 80                        ora     #$80
C966: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Send the byte
C969: B1 56                        lda     (<a href="#Symauxptr">auxptr</a>),Y
C96B: 85 51                        sta     <a href="#SymHostID">HostID</a>
C96D: 0A                           asl     A
C96E: 26 41                        rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
C970: C8                           iny                       ;Next byte
                   ; 
                   ; Send the sixth byte
                   ; 
C971: A5 52                        lda     <a href="#Symnext6">next6</a>
C973: 09 80                        ora     #$80
C975: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Send the byte
C978: B1 56                        lda     (<a href="#Symauxptr">auxptr</a>),Y
C97A: 85 52                        sta     <a href="#Symnext6">next6</a>
C97C: 0A                           asl     A
C97D: 26 41                        rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
C97F: C8                           iny                       ;Next byte
                   ; 
                   ; Send the last byte of the group
                   ; 
C980: A5 53                        lda     <a href="#Symnext7">next7</a>
C982: 09 80                        ora     #$80
C984: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Send the byte
C987: B1 56                        lda     (<a href="#Symauxptr">auxptr</a>),Y
C989: 85 53                        sta     <a href="#Symnext7">next7</a>
C98B: 0A                           asl     A
C98C: 26 41                        rol     <a href="#Symtopbits">topbits</a>           ;Store the top bit
C98E: C8                           iny                       ;Next byte
                   ; 
                   ; Now see if we have sent enough groups of seven
                   ; 
C98F: C6 4B                        dec     <a href="#Symgrp7ctr">grp7ctr</a>
C991: F0 03                        beq     <a href="#Symdatdone">datdone</a>
                   ; 
                   ; Otherwise, back to do more.  Note it's too far for a branch.
                   ; 
C993: 4C 00 C9                     jmp     <a href="#Symstart">start</a>

                   ; 
                   ; Whew! Now send the dman checksum as two FM bytes
                   ; 
C996: A5 40        <span id="Symdatdone">datdone</span>         lda     <a href="#Symchecksum">checksum</a>          ;c7 c6 c5 c4 c3 c2 c1 c0
C998: 09 AA                        ora     #$AA              ; 1 c6  1 c4  1 c2  1 c0
C99A: BC 8C C0     <span id="Symscm1">scm1</span>            ldy     <a href="#Syml6clr">l6clr</a>,X
C99D: 10 FB                        bpl     <a href="#Symscm1">scm1</a>              ;Handshake this byte
C99F: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;These are even bits
C9A2: A5 40                        lda     <a href="#Symbushog">bushog</a>            ;c7 c6 c5 c4 c3 c2 c1 c0
C9A4: 4A                           lsr     A                 ; 0 c7 c6 c5 c4 c3 c2 c1
C9A5: 09 AA                        ora     #$AA              ; 1 c7  1 c5  1 c3  1 c1
C9A7: 20 50 CA                     jsr     <a href="#Symsendbyte">sendbyte</a>
                   ; 
                   ; Send the end of packet mark
                   ; 
C9AA: A9 C8                        lda     #<a href="#Sympacketend">packetend</a>
C9AC: 20 50 CA                     jsr     <a href="#Symsendbyte">sendbyte</a>
                   ; 
                   ; Wait until write underflow
                   ; 
C9AF: BD 8C C0     <span id="Symsd7">sd7</span>             lda     <a href="#Syml6clr">l6clr</a>,X
C9B2: 29 40                        and     #$40
C9B4: D0 F9                        bne     <a href="#Symsd7">sd7</a>               ;Still writing data
                   ; 
C9B6: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X           ;Back to sense mode (dummy write)
                   ; 
                   ; Now wait until the drive acknowledges reciept of the
                   ;  string or until timeout
                   ; 
                   ; 
C9B9: A0 0A                        ldy     #<a href="#Symbsyto2">bsyto2</a>           ;Load timeout to see bsy low
C9BB: 88           <span id="Sympatch1">patch1</span>          dey                       ;A little closer to an error
C9BC: D0 08                        bne     <a href="#Symsd9">sd9</a>               ;There's still time
                   ; 
                   ; Too much time has elapsed.  Drive didn't get string.
                   ; 
C9BE: A9 01                        lda     #<a href="#Symnoanswer">noanswer</a>         ;Report error in comm error byte
C9C0: 20 97 CA     <span id="Symdberror">dberror</span>         jsr     <a href="#SymSetXN0">SetXN0</a>            ;For dberror entry
C9C3: 38                           sec                       ;Signal a problem
C9C4: B0 06                        bcs     <a href="#Symsd10">sd10</a>

                   ; 
                   ; See if drive has acknowledged the bytes yet
                   ; 
C9C6: BD 8E C0     <span id="Symsd9">sd9</span>             lda     <a href="#Syml7clr">l7clr</a>,X           ;Wait 'til /BSY lo
C9C9: 30 F0                        bmi     <a href="#Sympatch1">patch1</a>
                   ; 
                   ; Finish the sequence
                   ; 
C9CB: 18                           clc                       ;This is a normal exit
C9CC: BD 80 C0     <span id="Symsd10">sd10</span>            lda     <a href="#Symreqclr">reqclr</a>,X          ;Set REQ lo
C9CF: BD 8C C0                     lda     <a href="#Syml6clr">l6clr</a>,X           ;Back into read me
                   ; 
                   ; Pull back the bytecount in all cases
                   ; 
C9D2: 60                           rts

                   ; 
                   ; 
                   ; This table, when went in reverse order, provides a
                   ;   sync pattern used to synchronize the drive IWM with
                   ;   the data stream.  The firstr byte (last sent) is the 
                   ;   packet begin mark.
                   ; 
C9D3: C3           <span id="Sympreamble">preamble</span>        DFB     $C3
C9D4: FF           <span id="Symsynctab">synctab</span>         DFB     $FF
C9D5: FC                           DFB     $FC
C9D6: F3                           DFB     $F3
C9D7: CF                           DFB     $CF
C9D8: 3F                           DFB     $3F

                   ; 
                   ; 
                   ; 
                   ; These routines are for wasting specific amounts of time
                   ;  This code segment should not cross page boundaries.
                   ; 
C9D9: 20 DE C9     <span id="Symwaste32">waste32</span>         jsr     <a href="#Symwaste14">waste14</a>
C9DC: EA           <span id="Symwaste18">waste18</span>         nop
C9DD: EA           <span id="Symwaste16">waste16</span>         nop
C9DE: EA           <span id="Symwaste14">waste14</span>         nop
C9DF: 60           <span id="Symwaste12">waste12</span>         rts

C9E0: 4C C0 C9     <span id="Symmarkerr">markerr</span>         jmp     <a href="#Symdberror">dberror</a>

                   ********************************************************************************
                   *                                                                              *
                   * ReceivePack          Get a packet from bus resident                          *
                   *                                                                              *
                   *              ___________________________                                     *
                   *  REQ _______|2                         5|___________                         *
                   *         _______________________________                                      *
                   * /BSY___|1              3              4|____________                         *
                   *                                                                              *
                   *    1)  Drive signals ready to send packet                                    *
                   *    2)  Host signals ready to receive data                                    *
                   *    3)  Packet is transmitted (sync, mark, IDs, data,                         *
                   *         checksum [msb=1])                                                    *
                   *    4)  Drive signals packet dispatched                                       *
                   *    5)  Host acknowledges reciept of packet                                   *
                   *                                                                              *
                   *     The bytes are sent in slow mode (32 cycles/byte)                         *
                   *   and the timing is critical.  Branches which should                         *
                   *   not cross page boundaries are marked.                                      *
                   *                                                                              *
                   *   Input:  buffer &lt;- address where packet guts left                           *
                   *                                                                              *
                   *  Output: carry set- handshake error                                          *
                   *                clr- bytes sent                                               *
                   *          A &lt;- error0 if carry set                                            *
                   *                                                                              *
                   ********************************************************************************
C9E3: A9 00        <span id="SymReceivePack">ReceivePack</span>     lda     #$00              ;Init the checksum
C9E5: 85 40                        sta     <a href="#Symbushog">bushog</a>
                   ; 
                   ; Copy over buffer -&gt; buffer2
                   ; 
C9E7: A5 54                        lda     $54
C9E9: 85 56                        sta     <a href="#Symauxptr">auxptr</a>
C9EB: A5 55                        lda     <a href="#Symbuffer">buffer</a>+17
C9ED: 85 57                        sta     <a href="#Symbuffer2">buffer2</a>+1
                   ; 
                   ; Set up the indirect pointer for jump to 2nd part of code
                   ; 
C9EF: 20 7D CA                     jsr     <a href="#Symenablechain">enablechain</a>       ;SetX register to $N0
                   ; 
C9F2: BD 8D C0                     lda     <a href="#Syml6set">l6set</a>,X           ;Prep for sense mode
                   ; 
                   ; Now wait for BSY to go hi, signalling 'ready w/ status'
                   ; 
C9F5: BD 8E C0     <span id="Symrdh1">rdh1</span>            lda     <a href="#Syml7clr">l7clr</a>,X           ;Read sense
C9F8: 10 FB                        bpl     <a href="#Symrdh1">rdh1</a>              ;Wait til a high
                   ; 
                   ; Signal Liron we're ready to receive
                   ; 
C9FA: BD 81 C0                     lda     <a href="#Symreqset">reqset</a>,X          ;Raise /REQ
                   ; 
                   ; Wait for a byte from Liorn or timeout
                   ; 
C9FD: A0 1E                        ldy     #<a href="#Symstatmto">statmto</a>          ;Max bytes 'til stat mark
C9FF: BD 8C C0     <span id="Symrdh2">rdh2</span>            lda     <a href="#Syml6clr">l6clr</a>,X
CA02: 10 FB                        bpl     <a href="#Symrdh2">rdh2</a>              ;*** No Page Cros ***
CA04: 88                           dey
CA05: 30 D9                        bmi     <a href="#Symmarkerr">markerr</a>           ;Didn't find a packet in time
                   ; 
                   ; Is it the beginning of the packeT?
                   ; 
CA07: C9 C3                        cmp     #<a href="#Sympacketbeg">packetbeg</a>        ;Find the packet begin mark
CA09: D0 F4                        bne     <a href="#Symrdh2">rdh2</a>              ;Back again - no timeout for now
                   ; 
                   ; Okay load up the table with this stuff
                   ; 
CA0B: A0 06        <span id="Symrdh5">rdh5</span>            ldy     #6                ;Seven bytes of overhead
CA0D: BD 8C C0     <span id="Symrdh3">rdh3</span>            lda     <a href="#Syml6clr">l6clr</a>,X           ;If byte ready, grab it
CA10: 10 FB                        bpl     <a href="#Symrdh3">rdh3</a>              ;*** No Page Cross ***
CA12: 29 7F                        and     #%01111111        ;Strip start bit
CA14: 99 4B 00                     sta     <a href="#Symrcvbuf">rcvbuf</a>,Y
CA17: 49 80                        eor     #$80              ;Pop MSB back on for checksum
CA19: 45 40                        eor     <a href="#Symbushog">bushog</a>
CA1B: 85 40                        sta     <a href="#Symbushog">bushog</a>
CA1D: 88                           dey
CA1E: 10 ED                        bpl     <a href="#Symrdh3">rdh3</a>
                   ; 
                   ; Set groups of seven buffer pointer buffer2
                   ; 
CA20: A5 4C                        lda     <a href="#Symoddbytes">oddbytes</a>
CA22: F0 27                        beq     <a href="#Symstart2">start2</a>            ;Skip alteration if no oddbytes
CA24: 18                           clc
CA25: 65 54                        adc     $54
CA27: 85 56                        sta     <a href="#Symbuffer2">buffer2</a>
CA29: A5 55                        lda     <a href="#Symbuffer">buffer</a>+17
CA2B: 69 00                        adc     #0
CA2D: 85 57                        sta     <a href="#Symbuffer2">buffer2</a>+1
                   ; 
CA2F: A0 00                        ldy     #0
                   ; 
                   ; Now receive the odd bytes
                   ; 
CA31: BD 8C C0     <span id="Symstart0">start0</span>          lda     <a href="#Syml6clr">l6clr</a>,X           ;Read in the odd bytes topbits
CA34: 10 FB                        bpl     <a href="#Symstart0">start0</a>
CA36: 0A                           asl     A                 ;Pop off the start bit
CA37: 85 41                        sta     <a href="#Symtopbits">topbits</a>
                   ; 
CA39: BD 8C C0     <span id="Symstart1">start1</span>          lda     <a href="#Syml6clr">l6clr</a>,X           ;Get an odd byte
CA3C: 10 FB                        bpl     <a href="#Symstart1">start1</a>
CA3E: 06 41                        asl     <a href="#Symtopbits">topbits</a>           ;Get an MSB
CA40: B0 02                        bcs     <a href="#Symgob1">gob1</a>              ;If MSB set, leave start bit
CA42: 49 80                        eor     #$80              ;MSB Clear- flip start bit
CA44: 91 54        <span id="Symgob1">gob1</span>            sta     ($54),Y           ;Squirrel it away
CA46: C8                           iny                       ;Next spot
CA47: C4 4C                        cpy     <a href="#Symoddbytes">oddbytes</a>          ;Are we done?
CA49: 90 EE                        bcc     <a href="#Symstart1">start1</a>            ;If more, branch
CA4B: 4C 73 CC     <span id="Symstart2">start2</span>          jmp     <a href="#SymSlotDepRd">SlotDepRd</a>

CA4E: A9 80        <span id="Symsend80">send80</span>          lda     #$80
CA50: BC 8C C0     <span id="Symsendbyte">sendbyte</span>        ldy     <a href="#Syml6clr">l6clr</a>,X
CA53: 10 FB                        bpl     <a href="#Symsendbyte">sendbyte</a>
CA55: 9D 8D C0                     sta     <a href="#Syml6set">l6set</a>,X
CA58: 45 40                        eor     <a href="#Symbushog">bushog</a>
CA5A: 85 40                        sta     <a href="#Symbushog">bushog</a>
CA5C: 60                           rts

                   ; 
                   ; 
                   ; 
                   ; 
CA5D: 20 87 CA     <span id="Symresetchain">resetchain</span>      jsr     <a href="#SymClrPhases">ClrPhases</a>
CA60: BD 81 C0                     lda     <a href="#Symreqset">reqset</a>,X
CA63: BD 85 C0                     lda     <a href="#Symca2set">ca2set</a>,X
CA66: A0 50                        ldy     #80               ;Hard reset for 80 ms
CA68: 20 70 CA                     jsr     <a href="#SymYMSWait">YMSWait</a>
                   ; 
CA6B: 20 87 CA                     jsr     <a href="#SymClrPhases">ClrPhases</a>
                   ; 
CA6E: A0 0A                        ldy     #10               ;About 10 mS reset time!
                   ; 
CA70: 20 77 CA     <span id="SymYMSWait">YMSWait</span>         jsr     <a href="#SymOneMS">OneMS</a>
CA73: 88                           dey
CA74: D0 FA                        bne     <a href="#SymYMSWait">YMSWait</a>
CA76: 60                           rts

CA77: A2 C8        <span id="SymOneMS">OneMS</span>           ldx     #200
CA79: CA           <span id="Symonems1">onems1</span>          dex
CA7A: D0 FD                        bne     <a href="#Symonems1">onems1</a>
CA7C: 60                           rts

                   ; 
CA7D: 20 97 CA     <span id="Symenablechain">enablechain</span>     jsr     <a href="#SymSetXN0">SetXN0</a>
CA80: BD 83 C0                     lda     <a href="#Symcalset">calset</a>,X
CA83: BD 87 C0                     lda     <a href="#Symlstrbset">lstrbset</a>,X
CA86: 60                           rts

                   ; 
CA87: 20 97 CA     <span id="SymClrPhases">ClrPhases</span>       jsr     <a href="#SymSetXN0">SetXN0</a>
CA8A: BD 80 C0                     lda     <a href="#Symreqclr">reqclr</a>,X
CA8D: BD 82 C0                     lda     <a href="#Symca1clr">ca1clr</a>,X
CA90: BD 84 C0                     lda     <a href="#Symca2clr">ca2clr</a>,X
CA93: BD 86 C0                     lda     <a href="#Symlstrbclr">lstrbclr</a>,X
CA96: 60                           rts

                   ; 
CA97: A2 60        <span id="SymSetXN0">SetXN0</span>          ldx     #$60
CA99: 60                           rts

                   ; 
                   ; Shgift tables for use when reading.  Each table should not
                   ;  straddle pages.
                   ; 
CA9A: 80 80 80 80+ <span id="Symshift1">shift1</span>          HEX     $80,$80,$80,$80,$80,$80,$80,$80
CAA2: 00 00 00 00+                 HEX     $00,$00,$00,$00,$00,$00,$00,$00
CAAA: 80 80 80 80+ <span id="Symshift2">shift2</span>          HEX     $80,$80,$80,$80,$00,$00,$00,$00
CAB2: 80 80 80 80+                 HEX     $80,$80,$80,$80,$00,$00,$00,$00
CABA: 80 80 00 00+ <span id="Symshift3">shift3</span>          HEX     $80,$80,$00,$00,$80,$80,$00,$00
CAC2: 80 80 00 00+                 HEX     $80,$80,$00,$00,$80,$80,$00,$00
CACA: 80 00 80 00+ <span id="Symshift4">shift4</span>          HEX     $80,$00,$80,$00,$80,$00,$80,$00
CAD2: 80 00 80 00+                 HEX     $80,$00,$80,$00,$80,$00,$80,$00

                   ; 
CADA: A9 05        <span id="SymSendData">SendData</span>        lda     #&gt;<a href="#SymRC2">RC2</a>+$500
CADC: A0 00                        ldy     #<a href="#SymRC2">RC2</a>-5
CADE: 20 FD CA                     jsr     <a href="#SymSendPile">SendPile</a>
CAE1: 90 05                        bcc     <a href="#Symsdoubt">sdoubt</a>
CAE3: A9 80                        lda     #<a href="#SymCommReset">CommReset</a>
CAE5: 20 98 CF                     jsr     <a href="#SymAssignID">AssignID</a>
CAE8: 60           <span id="Symsdoubt">sdoubt</span>          rts

                   ; 
CAE9: 20 FD CA     <span id="SymSendPack">SendPack</span>        jsr     <a href="#SymSendPile">SendPile</a>          ;Try to send a pack
CAEC: 90 FA                        bcc     <a href="#Symsdoubt">sdoubt</a>
CAEE: A9 80                        lda     #<a href="#SymCommReset">CommReset</a>        ;This is a communications failure
CAF0: 20 98 CF                     jsr     <a href="#SymAssignID">AssignID</a>
                   ; 
CAF3: AD F8 06                     lda     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;Get back the packetlength
CAF6: 85 4D                        sta     <a href="#Symbytecountl">bytecountl</a>
CAF8: AD 78 07                     lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>
CAFB: 85 4E                        sta     <a href="#Symbytecounth">bytecounth</a>
                   ; 
CAFD: A9 B8        <span id="SymSendPile">SendPile</span>        lda     #&gt;<a href="#SymRC1">RC1</a>-$5300       ;Return count (big!)
CAFF: A0 0B                        ldy     #&lt;<a href="#SymRC1">RC1</a>+83
                   ; 
CB01: A6 58        <span id="SymAltSendPile">AltSendPile</span>     ldx     <a href="#SymSlot">Slot</a>
CB03: 9D F3 04                     sta     <a href="#SymRetry">Retry</a>,X
CB06: 98                           tya
CB07: 9D 73 05                     sta     <a href="#SymRetry2">Retry2</a>,X
                   ; 
                   ; SendPack destroys the bytecount
                   ; 
CB0A: A5 4D        <span id="Symspile1">spile1</span>          lda     <a href="#Symbytecountl">bytecountl</a>
CB0C: 8D F8 06                     sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>
CB0F: A5 4E                        lda     <a href="#Symbytecounth">bytecounth</a>
CB11: 8D 78 07                     sta     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>
                   ; 
CB14: 20 83 C8                     jsr     <a href="#SymSendOnePack">SendOnePack</a>       ;Send the packet
                   ; 
CB17: AD F8 06                     lda     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>
CB1A: 85 4D                        sta     <a href="#Symbytecountl">bytecountl</a>
CB1C: AD 78 07                     lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>
CB1F: 85 4E                        sta     <a href="#Symbytecounth">bytecounth</a>
                   ; 
CB21: 90 0C                        bcc     <a href="#Symspilout">spilout</a>
CB23: A6 58                        ldx     <a href="#SymSlot">Slot</a>
CB25: DE F3 04                     dec     <a href="#SymRetry">Retry</a>,X
CB28: D0 E0                        bne     <a href="#Symspile1">spile1</a>
CB2A: DE 73 05                     dec     <a href="#SymRetry2">Retry2</a>,X
CB2D: 10 DB                        bpl     <a href="#Symspile1">spile1</a>            ;If all fails, carry is set
CB2F: 60           <span id="Symspilout">spilout</span>         rts

CB30: A4 58        <span id="SymRecPack">RecPack</span>         ldy     <a href="#SymSlot">Slot</a>
CB32: A9 05                        lda     #&gt;<a href="#SymRC2">RC2</a>+$500
CB34: 99 F3 04                     sta     <a href="#SymRetry">Retry</a>,Y
                   ; 
CB37: 20 E3 C9     <span id="Symrpk1">rpk1</span>            jsr     <a href="#SymReceivePack">ReceivePack</a>
CB3A: 90 0F                        bcc     <a href="#Symrpout">rpout</a>
CB3C: A0 01                        ldy     #1
CB3E: 20 70 CA                     jsr     <a href="#SymYMSWait">YMSWait</a>
CB41: 20 C0 C9                     jsr     <a href="#Symdberror">dberror</a>           ;Recycle handshake and set carry
CB44: A6 58                        ldx     <a href="#SymSlot">Slot</a>
CB46: DE F3 04                     dec     <a href="#SymRetry">Retry</a>,X
CB49: D0 EC                        bne     <a href="#Symrpk1">rpk1</a>              ;Carry set still
CB4B: 60           <span id="Symrpout">rpout</span>           rts

                   ********************************************************************************
                   *                                                                              *
                   * Divide7               Do DIV and MOD 7 and set auxptr                        *
                   *  This routine divides the bytecount by seven.  The                           *
                   *   quotient gives the number of groups of seven bytes to                      *
                   *   be sent, and the remainder gives the number of "odd"                       *
                   *   bytes.                                                                     *
                   *                                                                              *
                   *   Input:  bytecountl,h &lt;- # of bytes to write                                *
                   *           buffer       &lt;- pointer to data                                    *
                   *   Output: auxptr       &lt;- pointer to speed up csumming                       *
                   *           oddbytes     &lt;- bytecount MOD 7                                    *
                   *           grp7ctr      &lt;- bytecount DIV 7                                    *
                   *                                                                              *
                   ********************************************************************************
CB4C: 00 24 49     <span id="Sympdiv7tab">pdiv7tab</span>        HEX     $00,$24,$49
CB4F: 00 04 01     <span id="Sympmod7tab">pmod7tab</span>        HEX     $00,$04,$01
CB52: 00 01 02 04+ <span id="Symdiv7tab">div7tab</span>         HEX     $00,$01,$02,$04,$09,$12
CB58: 00 01 02 04+ <span id="Symmod7tab">mod7tab</span>         HEX     $00,$01,$02,$04,$01,$02
                   ; 
CB5E: 00 7F FF     <span id="Symauxptrinc">auxptrinc</span>       HEX     $00,$7F,$FF

                   ; 
                   ; Set up auxptr &lt;- buffer+$80   if $0FF &lt; bytecount &lt; $200
                   ;     or auxptr &lt;- buffer+$100  if $1FF &lt; bytecount
                   ; 
                   ; aka Divide7
CB61: A6 4E        <span id="SymWritePrep">WritePrep</span>       ldx     <a href="#Symbytecounth">bytecounth</a>        ;0, 1 or 2
CB63: F0 17                        beq     <a href="#Symnoauxptr">noauxptr</a>          ;Auxptr used only for full pages
                   ; 
CB65: A5 55                        lda     <a href="#Symbuffer">buffer</a>+17
CB67: 85 57                        sta     <a href="#Symauxptr">auxptr</a>+1          ;Copy over hi order part
                   ; 
CB69: A9 80                        lda     #$80              ;Anticipate smaller bytecount
CB6B: E0 01                        cpx     #1                ;Check bytecount
CB6D: F0 04                        beq     <a href="#Symsap1">sap1</a>              ;=&gt; $0FF &lt; bytecount &lt; $200
                   ; 
CB6F: E6 57                        inc     <a href="#Symauxptr">auxptr</a>+1          ;Add $100 to bytecount instead
CB71: A9 00                        lda     #0                ;Make sure lo order unaltered
CB73: 18           <span id="Symsap1">sap1</span>            clc
CB74: 65 54                        adc     $54
CB76: 85 56                        sta     <a href="#Symauxptr">auxptr</a>
CB78: 90 02                        bcc     <a href="#Symnoauxptr">noauxptr</a>          ;skip if no carry
CB7A: E6 57                        inc     <a href="#Symauxptr">auxptr</a>+1          ;don't forget me
                   ; 
                   ; Now look up the first order guess for DIV and MOD.  X still has
                   ;  bytecount DIV 256.
                   ; 
CB7C: BD 4C CB     <span id="Symnoauxptr">noauxptr</span>        lda     <a href="#Sympdiv7tab">pdiv7tab</a>,X
CB7F: 85 4B                        sta     <a href="#Symgrp7ctr">grp7ctr</a>
CB81: BD 4F CB                     lda     <a href="#Sympmod7tab">pmod7tab</a>,X
CB84: 85 4C                        sta     <a href="#Symoddbytes">oddbytes</a>
                   ; 
                   ; Now add in the mods and divs for each of the five hi order
                   ;  bits in the lo order bytecount, correcting each time MOD becomes
                   ;  bigger than 6.
                   ; 
CB86: A2 05                        ldx     #5                ;Do for five bits
CB88: A5 4D                        lda     <a href="#Symbytecountl">bytecountl</a>
CB8A: 85 59                        sta     &lt;<a href="#Symtemp">temp</a>+97          ;Store lo order for shifting
CB8C: 29 07                        and     #%00000111        ;Save lo three for later
CB8E: A8                           tay
                   ; 
CB8F: 06 59        <span id="Symdivide3">divide3</span>         asl     &lt;<a href="#Symtemp">temp</a>+97          ;C &lt;- next from bytecountl
CB91: 90 15                        bcc     <a href="#Symdivide2">divide2</a>           ;If clear, no effect on DIV,MOD
CB93: BD 58 CB                     lda     <a href="#Symmod7tab">mod7tab</a>,X         ;Get MOD7 for 2^n
                   ; 
CB96: 18           <span id="Symdivide4">divide4</span>         clc
CB97: 65 4C                        adc     <a href="#Symoddbytes">oddbytes</a>          ;Got new MOD value
CB99: C9 07                        cmp     #7                ;Is it too big?
CB9B: 90 02                        bcc     <a href="#Symdivide1">divide1</a>
CB9D: E9 07                        sbc     #7                ;Bring MOD under 7 - C still set
                   ; 
CB9F: 85 4C        <span id="Symdivide1">divide1</span>         sta     <a href="#Symoddbytes">oddbytes</a>
CBA1: BD 52 CB                     lda     <a href="#Symdiv7tab">div7tab</a>,X         ;Get DIV for this 2^n
CBA4: 65 4B                        adc     <a href="#Symgrp7ctr">grp7ctr</a>           ;Add to DIV along with correction (C)
CBA6: 85 4B                        sta     <a href="#Symgrp7ctr">grp7ctr</a>           ;Update the DIV
                   ; 
CBA8: CA           <span id="Symdivide2">divide2</span>         dex                       ;One less bit to deal with
CBA9: 30 06                        bmi     <a href="#Symdivide5">divide5</a>           ;Escape after 6 times through loop
CBAB: D0 E2                        bne     <a href="#Symdivide3">divide3</a>           ;Take brnch 1st 5 loops
                   ; 
CBAD: 98                           tya                       ;Get back the last three bits
CBAE: 4C 96 CB                     jmp     <a href="#Symdivide4">divide4</a>           ;Sixth pass add in remains

                   ********************************************************************************
                   *                                                                              *
                   *  PreCheck                    Does the checksumming prepass                   *
                   *                                                                              *
                   *    Input:  bytecount   &lt;- bytes in buffer                                    *
                   *            buffer      &lt;- pointer to data to send                            *
                   *            auxptr      &lt;- extra pointer to speed process                     *
                   *   Output:  checksum    &lt;- 8 bit XOR of data to be sent                       *
                   *                                                                              *
                   ********************************************************************************
CBB1: A5 55        <span id="Symdivide5">divide5</span>         lda     <a href="#Symbuffer">buffer</a>+17         ;Checksum any full pages
CBB3: 48                           pha                       ;Preserve buffer pointer
CBB4: A9 00                        lda     #0
CBB6: A6 4E                        ldx     <a href="#Symbytecounth">bytecounth</a>
CBB8: F0 16                        beq     <a href="#Symlastpass">lastpass</a>          ;If no complete pages, skip this
                   ; 
CBBA: BC 5E CB     <span id="Symxor2">xor2</span>            ldy     <a href="#Symauxptrinc">auxptrinc</a>,X       ;Get number of bytes each ptr
                   ; 
CBBD: 51 54        <span id="Symxor1">xor1</span>            eor     ($54),Y
CBBF: 51 56                        eor     (<a href="#Symauxptr">auxptr</a>),Y
CBC1: 88                           dey                       ;One less
CBC2: D0 F9                        bne     <a href="#Symxor1">xor1</a>
CBC4: 51 54                        eor     ($54),Y
CBC6: 51 56                        eor     (<a href="#Symauxptr">auxptr</a>),Y        ;Have to deal with 0 case
                   ; 
                   ; Now move the buffer up for next section
                   ; 
CBC8: E0 01                        cpx     #1
CBCA: F0 02                        beq     <a href="#Symxor5">xor5</a>              ;If 256 and up bytes, bump x1
CBCC: E6 55                        inc     <a href="#Symbuffer">buffer</a>+17         ; otherwise x2
CBCE: E6 55        <span id="Symxor5">xor5</span>            inc     <a href="#Symbuffer">buffer</a>+17
                   ; 
                   ; Do the remaining less than a page with a single pointer
                   ; 
CBD0: A4 4D        <span id="Symlastpass">lastpass</span>        ldy     <a href="#Symbytecount">bytecount</a>
CBD2: F0 09                        beq     <a href="#Symxor4">xor4</a>
CBD4: 51 54                        eor     ($54),Y           ;Compensate for nth byte
CBD6: 51 54        <span id="Symxor3">xor3</span>            eor     ($54),Y
CBD8: 88                           dey
CBD9: D0 FB                        bne     <a href="#Symxor3">xor3</a>
CBDB: 51 54                        eor     ($54),Y           ;Last damn (0th) byte
                   ; 
                   ; Store result away.  Retrieve old buffer value.
                   ; 
CBDD: 85 40        <span id="Symxor4">xor4</span>            sta     <a href="#Symbushog">bushog</a>
CBDF: 68                           pla
CBE0: 85 55                        sta     <a href="#Symbuffer">buffer</a>+17
                   ********************************************************************************
                   *                                                                              *
                   *  DetTopBits                    Get topbits for odd bytes                     *
                   *                                                                              *
                   *    Also sets buffer2 pointer to pointer at groups of                         *
                   * seven bytes.                                                                 *
                   *                                                                              *
                   *    Input:  oddbytes &lt;- # of "odd" bytes                                      *
                   *            buffer   &lt;- pointer to data                                       *
                   *   Output:  tbodd    &lt;- topbits for odd bytes                                 *
                   *            buffer2  &lt;- buffer+oddbytes                                       *
                   *                                                                              *
                   ********************************************************************************
CBE2: A4 4C        <span id="SymDecTopBits">DecTopBits</span>      ldy     <a href="#Symoddbytes">oddbytes</a>
CBE4: 88                           dey
CBE5: A9 00                        lda     #0
                   ; 
CBE7: 85 59                        sta     <a href="#Symtbodd">tbodd</a>
CBE9: B1 54        <span id="Symgtbob">gtbob</span>           lda     ($54),Y
CBEB: 0A                           asl     A
CBEC: 66 59                        ror     <a href="#Symtbodd">tbodd</a>
CBEE: 88                           dey
CBEF: 10 F8                        bpl     <a href="#Symgtbob">gtbob</a>
CBF1: 38                           sec
CBF2: 66 59                        ror     <a href="#Symtbodd">tbodd</a>
                   ; 
CBF4: A5 4C                        lda     <a href="#Symoddbytes">oddbytes</a>
CBF6: 18                           clc
CBF7: 65 54                        adc     $54
CBF9: 85 56                        sta     <a href="#Symbuffer2">buffer2</a>
CBFB: A5 55                        lda     <a href="#Symbuffer">buffer</a>+17
CBFD: 69 00                        adc     #0
CBFF: 85 57                        sta     <a href="#Symbuffer2">buffer2</a>+1
                   ********************************************************************************
                   *                                                                              *
                   *  Sun                    Set up next buffer and topbits                       *
                   *                                                                              *
                   *    Primes the pip for the group of seven bytes routine                       *
                   *  setting the topbits byte and the "next" buffer.                             *
                   *  The routine also advances the buffer pointer by 7 to                        *
                   *  prepare for the groups of seven transfer.                                   *
                   *                                                                              *
                   *    Input:  buffer2   &lt;- points to groups of 7 data                           *
                   *   Output:  next1,7   &lt;- first 7 bytes in buffer                              *
                   *            topbits   &lt;- MSBs of first 7 bytes                                *
                   *                                                                              *
                   ********************************************************************************
CC01: A0 06        <span id="SymSun">Sun</span>             ldy     #6
CC03: 38           <span id="Symsun2">sun2</span>            sec
CC04: B1 56                        lda     (<a href="#Symbuffer2">buffer2</a>),Y
CC06: 99 4D 00                     sta     <a href="#Symnext">next</a>,Y
CC09: 30 01                        bmi     <a href="#Symsun1">sun1</a>
CC0B: 18                           clc
CC0C: 66 41        <span id="Symsun1">sun1</span>            ror     <a href="#Symtopbits">topbits</a>
CC0E: 88                           dey
CC0F: 10 F2                        bpl     <a href="#Symsun2">sun2</a>
CC11: 38                           sec
CC12: 66 41                        ror     <a href="#Symtopbits">topbits</a>
                   ; 
                   ; Advance the pointer
                   ; 
CC14: A5 56                        lda     <a href="#Symbuffer2">buffer2</a>
CC16: 18                           clc
CC17: 69 07                        adc     #7
CC19: 85 56                        sta     <a href="#Symbuffer2">buffer2</a>
CC1B: 90 02                        bcc     <a href="#Symsun3">sun3</a>
CC1D: E6 57                        inc     <a href="#Symbuffer2">buffer2</a>+1
CC1F: 60           <span id="Symsun3">sun3</span>            rts

                   ; 
                   ; 
                   ;  X is slot &amp; 16, Y is the desired mode
                   ; 
                   ;  Set up the IWM mode register.  Extreme care should be taken
                   ;   here. Setting the mode byte with indexed stores causes a 
                   ;   false byte to be written a cycle before the real value is
                   ;   written.  This false value, if it enables the timer, causes
                   ;   the IWM Rev A to pop the motor on, inhibiting the setting
                   ;   of the mode until the motor times out! We avoid this by
                   ;   setting the mode byte only when it is not what we want, and if
                   ;   it's not we stay here until we see that it is what we want.
                   ; 
CC20: BD 88 C0     <span id="SymSetIWMode">SetIWMode</span>       lda     <a href="#Symmonclr">monclr</a>,X          ;Motor must be off
CC23: BD 8D C0                     lda     <a href="#Syml6set">l6set</a>,X           ;Set up to access mode register
CC26: 4C 2D CC                     jmp     <a href="#Symcareful">careful</a>           ;Don't mess unless we gotta

CC29: 98           <span id="Symbiz">biz</span>             tya
CC2A: 9D 8F C0                     sta     <a href="#Syml7set">l7set</a>,X           ;Try storing the mode value
                   ; 
CC2D: 98           <span id="Symcareful">careful</span>         tya                       ;Get back the target value
CC2E: 5D 8E C0                     eor     <a href="#Syml7clr">l7clr</a>,X           ;Compare with observed value
CC31: 29 1F                        and     #$1F              ;Can only read low 5 bits
CC33: D0 F4                        bne     <a href="#Symbiz">biz</a>               ;If not right, back to try again
CC35: 60                           rts

                   ; 
                   ; Make sure you're in read mode and wait 'til Disk // motor is off
                   ; 
CC36: 20 97 CA     <span id="SymWaitIWMOff">WaitIWMOff</span>      jsr     <a href="#SymSetXN0">SetXN0</a>            ;Set X
CC39: BD 8E C0                     lda     <a href="#Syml7clr">l7clr</a>,X
CC3C: BD 8D C0                     lda     <a href="#Syml6set">l6set</a>,X
                   ; 
CC3F: BD 8E C0     <span id="Symwiwm1">wiwm1</span>           lda     <a href="#Syml7clr">l7clr</a>,X
CC42: 29 20                        and     #%00100000
CC44: D0 F9                        bne     <a href="#Symwiwm1">wiwm1</a>
CC46: BD 8C C0                     lda     <a href="#Syml6clr">l6clr</a>,X
                   ; 
                   ; Wait an additional 700 usec to allow 12V on Disk // to decay
                   ; 
CC49: 5A                           phy
CC4A: A0 8C                        ldy     #140
CC4C: 88           <span id="Symwiwm2">wiwm2</span>           dey
CC4D: D0 FD                        bne     <a href="#Symwiwm2">wiwm2</a>
CC4F: 7A                           ply
                   ; 
CC50: 60                           rts

                   ; 
                   ; This takes grp7ctr and oddbytes and calculates 7*grp7ctr+oddbytes.
                   ;   The results are in Y(hi) and A(low).  This is the number of bytes
                   ;   that were received in the last ReceivePack.
                   ; 
CC51: A5 4B        <span id="SymRcvcount">Rcvcount</span>        lda     <a href="#Symgrp7ctr">grp7ctr</a>
CC53: A8                           tay
CC54: A2 00                        ldx     #0
CC56: 86 4B                        stx     <a href="#Symgrp7ctr">grp7ctr</a>
CC58: A2 03                        ldx     #3
CC5A: 0A           <span id="Symtimes7">times7</span>          asl     A
CC5B: 26 4B                        rol     <a href="#Symgrp7ctr">grp7ctr</a>
CC5D: CA                           dex
CC5E: D0 FA                        bne     <a href="#Symtimes7">times7</a>
CC60: 18                           clc
CC61: 65 4C                        adc     <a href="#Symoddbytes">oddbytes</a>
CC63: 90 02                        bcc     <a href="#Symt71">t71</a>
CC65: E6 4B                        inc     <a href="#Symgrp7ctr">grp7ctr</a>
CC67: 84 4C        <span id="Symt71">t71</span>             sty     <a href="#Symoddbytes">oddbytes</a>
CC69: 38                           sec
CC6A: E5 4C                        sbc     <a href="#Symoddbytes">oddbytes</a>
CC6C: B0 02                        bcs     <a href="#Symt72">t72</a>
CC6E: C6 4B                        dec     <a href="#Symgrp7ctr">grp7ctr</a>
CC70: A4 4B        <span id="Symt72">t72</span>             ldy     <a href="#Symgrp7ctr">grp7ctr</a>
CC72: 60                           rts

                   NOTE: aka start25
                   ; 
CC73: A0 00        <span id="SymSlotDepRd">SlotDepRd</span>       ldy     #0
CC75: A5 4B                        lda     <a href="#Symgrp7ctr">grp7ctr</a>
CC77: 48                           pha                       ;Save groups of seven counter
CC78: D0 03                        bne     <a href="#Symstart35">start35</a>
CC7A: 4C 0A CD                     jmp     <a href="#Symdone5">done5</a>             ;Go get the checksum

                   ; Okay, get the groups of seven
                   ;   Start by getting the topbits for this group of seven
                   ; 
CC7D: AD EC C0     <span id="Symstart35">start35</span>         lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff ;Get topbits
CC80: 10 FB                        bpl     <a href="#Symstart35">start35</a>
CC82: 85 59                        sta     &lt;<a href="#Symtemp">temp</a>+97          ;Just a second
                   ; Split up the seven bits into two indices for topbit tables
                   ; 
CC84: 4A                           lsr     A                 ;0   1  d1  d2  d3  d4  d5  d6
CC85: 4A                           lsr     A                 ;0   0   1  d1  d2  d3  d4  d5
CC86: 4A                           lsr     A                 ;0   0   0   1  d1  d2  d3  d4
CC87: 29 0F                        and     #%00001111        ;0   0   0   0  d1  d2  d3  d4
CC89: AA                           tax                       ;First index into the tables
CC8A: A5 59                        lda     &lt;<a href="#Symtemp">temp</a>+97          ;1  d1  d2  d3  d4  d5  d6  d7
CC8C: 29 07                        and     #%00000111        ;0   0   0   0   0  d5  d6  d7
CC8E: 85 59                        sta     &lt;<a href="#Symtemp">temp</a>+97          ;Keep for last three bytes
                   ; 
                   ; Read the 1st byte, reunite its msb, store and checksum it
                   ; 
CC90: AD EC C0     <span id="SymLCC90">LCC90</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CC93: 10 FB                        bpl     <a href="#SymLCC90">LCC90</a>             ;Back 1 instruction
CC95: 5D 9A CA                     eor     <a href="#Symshift1">shift1</a>,X          ;Recombine the MSB with data
CC98: 91 56                        sta     (<a href="#Symbuffer2">buffer2</a>),Y       ;Store it away
CC9A: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
CC9C: 85 40                        sta     <a href="#Symbushog">bushog</a>
CC9E: C8                           iny
                   ; 
                   ;  Now, the second Y turn over occurs at this point in the
                   ;   loop.  Update teh buffer pointer if it occured.
                   ; 
CC9F: D0 02                        bne     <a href="#SymLCCA3">LCCA3</a>             ;*+4
CCA1: E6 57                        inc     <a href="#Symbuffer2">buffer2</a>+1
                   ; 
                   ; Now the second byte
                   ; 
CCA3: AD EC C0     <span id="SymLCCA3">LCCA3</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CCA6: 10 FB                        bpl     <a href="#SymLCCA3">LCCA3</a>             ;Back 1 instruction
CCA8: 5D AA CA                     eor     <a href="#Symshift2">shift2</a>,X          ;Recombine the MSB with data
CCAB: 91 56                        sta     (<a href="#Symbuffer2">buffer2</a>),Y       ;Store it away
CCAD: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
CCAF: 85 40                        sta     <a href="#Symbushog">bushog</a>
CCB1: C8                           iny
                   ; 
                   ; Now the third byte
                   ; 
CCB2: AD EC C0     <span id="SymLCCB2">LCCB2</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CCB5: 10 FB                        bpl     <a href="#SymLCCB2">LCCB2</a>             ;Back 1 Instruction
CCB7: 5D BA CA                     eor     <a href="#Symshift3">shift3</a>,X          ;Recombine the MSB with data
CCBA: 91 56                        sta     (<a href="#Symbuffer2">buffer2</a>),Y       ;Store it away
CCBC: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
CCBE: 85 40                        sta     <a href="#Symbushog">bushog</a>
CCC0: C8                           iny
                   ; 
                   ;  Now the fourth byte
                   ; 
CCC1: AD EC C0     <span id="SymLCCC1">LCCC1</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CCC4: 10 FB                        bpl     <a href="#SymLCCC1">LCCC1</a>             ;Back 1 instruction
CCC6: 5D CA CA                     eor     <a href="#Symshift4">shift4</a>,X          ;Recombine the MSB with data
CCC9: 91 56                        sta     (<a href="#Symbuffer2">buffer2</a>),Y       ;Store it away
CCCB: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
CCCD: 85 40                        sta     <a href="#Symbushog">bushog</a>
CCCF: C8                           iny
                   ; 
                   ;  The first Y turn over occurs at this point in the loop.  Update
                   ;   the buffer poitner if it occured.
                   ; 
CCD0: D0 02                        bne     <a href="#SymLCCD4">LCCD4</a>             ;*+4
CCD2: E6 57                        inc     <a href="#Symbuffer2">buffer2</a>+1
                   ; 
CCD4: A6 59        <span id="SymLCCD4">LCCD4</span>           ldx     &lt;<a href="#Symtemp">temp</a>+97          ;Now we need the other index
                   ; 
                   ;  Now the fifth byte
                   ; 
CCD6: AD EC C0     <span id="SymLCCD6">LCCD6</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CCD9: 10 FB                        bpl     <a href="#SymLCCD6">LCCD6</a>             ;Back 1 instruction
CCDB: 5D AA CA                     eor     <a href="#Symshift2">shift2</a>,X          ;Recombine the MSB with data
CCDE: 91 56                        sta     (<a href="#Symbuffer2">buffer2</a>),Y       ;Store it away
CCE0: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
CCE2: 85 40                        sta     <a href="#Symbushog">bushog</a>
CCE4: C8                           iny
                   ; 
                   ;  Now the sixth byte
                   ; 
CCE5: AD EC C0     <span id="SymLCCE5">LCCE5</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CCE8: 10 FB                        bpl     <a href="#SymLCCE5">LCCE5</a>             ;Back 1 instruction
CCEA: 5D BA CA                     eor     <a href="#Symshift3">shift3</a>,X          ;Recombine the MSB with data
CCED: 91 56                        sta     (<a href="#Symbuffer2">buffer2</a>),Y       ;Store it away
CCEF: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
CCF1: 85 40                        sta     <a href="#Symbushog">bushog</a>
CCF3: C8                           iny
                   ; 
                   ;  And, finallly, the seventh byte
                   ; 
CCF4: AD EC C0     <span id="SymLCCF4">LCCF4</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CCF7: 10 FB                        bpl     <a href="#SymLCCF4">LCCF4</a>             ;Back 1 instruction
CCF9: 5D CA CA                     eor     <a href="#Symshift4">shift4</a>,X          ;Recombine the MSB with data
CCFC: 91 56                        sta     (<a href="#Symbuffer2">buffer2</a>),Y       ;Store it away
CCFE: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;Add it to the checksum
CD00: 85 40                        sta     <a href="#Symbushog">bushog</a>
CD02: C8                           iny
                   ; 
                   ;  Now see if this is the last group of seven to receive
                   ; 
CD03: C6 4B                        dec     <a href="#Symgrp7ctr">grp7ctr</a>
CD05: F0 03                        beq     <a href="#Symdone5">done5</a>             ;Go to get the checksum etc
CD07: 4C 7D CC                     jmp     <a href="#Symstart35">start35</a>           ;Another topbits ...

                   ; 
                   ;  Get and reconstruct the checksum
                   ; 
CD0A: AD EC C0     <span id="Symdone5">done5</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;l6clr+TheOff
CD0D: 10 FB                        bpl     <a href="#Symdone5">done5</a>             ;*-3
CD0F: 85 59                        sta     &lt;<a href="#Symtemp">temp</a>+97          ;1 c6 1 c4 1 c2 1 c0
                   ; 
CD11: 68                           pla                       ;Restore groups of 7 counter
CD12: 85 4B                        sta     <a href="#Symgrp7ctr">grp7ctr</a>
                   ; l6clr+TheOff
CD14: AD EC C0     <span id="SymLCD14">LCD14</span>           lda     <a href="#Syml6clr">l6clr</a>+96          ;1 c7 1 c5 1 c3 1 c1
CD17: 10 FB                        bpl     <a href="#SymLCD14">LCD14</a>             ;*-3
CD19: 38                           sec
CD1A: 2A                           rol     A                 ;c7 1 c5 1 c3 1 c1 1
CD1B: 25 59                        and     &lt;<a href="#Symtemp">temp</a>+97          ;c7 c6 c5 c4 c3 c2 c1 c0
CD1D: 45 40                        eor     <a href="#Symbushog">bushog</a>            ;When we're done, should be zero
                   ; 
                   ;  Get the packet end mark. Is it correct?
                   ; 
                   ; l6clr+TheOff
CD1F: AC EC C0     <span id="Symrdha5">rdha5</span>           ldy     <a href="#Syml6clr">l6clr</a>+96          ;Preserve A
CD22: 10 FB                        bpl     <a href="#Symrdha5">rdha5</a>
                   ; 
CD24: C0 C8                        cpy     #<a href="#Sympacketend">packetend</a>
CD26: D0 1C                        bne     <a href="#Symnpenderr5">npenderr5</a>
                   ; 
                   ;  Didn't have time before to checksum oddbytes.  Do it now
                   ;   A still has the partial checksum
                   ; 
CD28: A6 4C                        ldx     <a href="#Symoddbytes">oddbytes</a>
CD2A: F0 08                        beq     <a href="#Symicbt15">icbt15</a>
CD2C: A0 00                        ldy     #0
CD2E: 51 54        <span id="Symicbt5">icbt5</span>           eor     ($54),Y
CD30: C8                           iny
CD31: CA                           dex
CD32: D0 FA                        bne     <a href="#Symicbt5">icbt5</a>
                   ; 
                   ; Okay, checksum oughta be zero.  If not, checksum error.
                   ; 
CD34: AA           <span id="Symicbt15">icbt15</span>          tax
CD35: D0 11                        bne     <a href="#Symcserror5">cserror5</a>
                   ; 
                   ; Wait for /BSY to go low
                   ; 
CD37: AD ED C0     <span id="Symlstbsywait5">lstbsywait5</span>     lda     <a href="#Syml6clr">l6clr</a>+97          ;l6set+TheOff
CD3A: AD EE C0     <span id="Symrdh45">rdh45</span>           lda     <a href="#Syml7clr">l7clr</a>+96          ;l7clr+TheOff
CD3D: 30 FB                        bmi     <a href="#Symrdh45">rdh45</a>
                   ; 
                   ; Got the bytes, now acknowledge their receipt
                   ; 
                   ; reqclr+TheOff
CD3F: AD E0 C0                     lda     <a href="#Syml6clr">l6clr</a>+84          ;Lower REQ
                   ; 
CD42: 18                           clc
CD43: 60                           rts

CD44: A9 20        <span id="Symnpenderr5">npenderr5</span>       lda     #<a href="#Symnopackend">nopackend</a>
CD46: D0 02                        bne     <a href="#Symgserror5">gserror5</a>

CD48: A9 10        <span id="Symcserror5">cserror5</span>        lda     #<a href="#Symcsumerr">csumerr</a>
CD4A: 38           <span id="Symgserror5">gserror5</span>        sec
CD4B: 60                           rts

                   <span style="background-color: #89acb7">NOTE: C880 jumps to here</span>
                   <span style="background-color: #89acb7">This is the smart port / protocol converter code I care most about --James</span>
                   ; include pc.main
                   ; 
                   ; 
CD4C: 90 03        <span id="SymEntry">Entry</span>           bcc     <a href="#Symbentry">bentry</a>            ;If non-boot, skip jump to boot
CD4E: 4C 23 C5                     jmp     <a href="#SymLC523">LC523</a>

                   ; 
                   ; X is still set to slot number
                   ; 
CD51: A9 40        <span id="Symbentry">bentry</span>          lda     #%01000000
CD53: 1C 78 04                     trb     <a href="#SymProFLAG">ProFLAG</a>+5         ;ProFlag is fixed in //c
                   ; 
CD56: D8           <span id="Symatentry">atentry</span>         cld                       ;Don't want decimal mode!!
CD57: 8A                           txa
CD58: A8                           tay                       ;Really want it in Y... no ROR ABS,Y!
                   ; 
                   ; If this is a PC call, then get the address of the parm table
                   ; 
CD59: B9 73 04                     lda     <a href="#SymProFLAG">ProFLAG</a>,Y
CD5C: 30 11                        bmi     <a href="#Symnoplay">noplay</a>
                   ; 
CD5E: 68                           pla                       ;Get lo order
CD5F: 99 F3 05                     sta     <a href="#SymSHTempX">SHTempX</a>,Y         ;Keep lo parm address-1
CD62: 18                           clc
CD63: 69 03                        adc     #3
CD65: AA                           tax                       ;Lo order new return address
CD66: 68                           pla                       ;Get hi order address
CD67: 99 73 06                     sta     <a href="#SymSHTempY">SHTempY</a>,Y         ;Keep hi parm addr-1
CD6A: 69 00                        adc     #0
CD6C: 48                           pha                       ;Push back new return address hi
CD6D: 8A                           txa
CD6E: 48                           pha                       ;Push new return address lo
                   ; 
                   ; On the //c, it is important to have the Disk // enable lines
                   ;  off for as long as possible before using the IWM (phases,
                   ;  /WRREQ lines). Wait here 'til the Disk // motors are off.
                   ; 
CD6F: 20 36 CC     <span id="Symnoplay">noplay</span>          jsr     <a href="#SymWaitIWMOff">WaitIWMOff</a>        ;Must Preserve Y!!
                   ; 
                   ; We can't tolerate ints in most of the code, so disable
                   ; 
CD72: 08                           php                       ;Save interrupt status
CD73: 78                           sei                       ;No interrupts please
                   ; 
                   ; Preserve the zero page work area
                   ; 
CD74: A2 1B                        ldx     #<a href="#SymZPSize">ZPSize</a>-1
CD76: B5 40        <span id="Sympzp">pzp</span>             lda     <a href="#Symzeropage">zeropage</a>,X
CD78: 48                           pha
CD79: CA                           dex
CD7A: 10 FA                        bpl     <a href="#Sympzp">pzp</a>
                   ; 
                   ; Okay, we're safe... now it's all right to store in zero page
                   ; 
CD7C: 84 58                        sty     <a href="#SymSlot">Slot</a>
                   ; 
                   ; 
                   ; Now map any ProDOS unit references to our sequential ones.
                   ;  This method is bizzare and magicians never reveal their secrets.
                   ; 
CD7E: A5 43        <span id="Symallset">allset</span>          lda     <a href="#SymCMDUnit">CMDUnit</a>           ;76543210 7&amp;6 specify unit
CD80: 2A                           rol     A                 ;6543210X C&lt;-7
CD81: 08                           php                       ;Save drive num
CD82: 2A                           rol     A                 ;543210X7 C&lt;-6
CD83: 2A                           rol     A                 ;463210X76 (6 is grp of 2)
CD84: 28                           plp                       ;C&lt;-7
CD85: 2A                           rol     A                 ;3210X767
CD86: 29 03                        and     #%00000011        ;ProDOS only installs up to 4
CD88: 49 02                        eor     #%00000010        ;000000/67; 6 was /grpoftwo
CD8A: C0 04                        cpy     #4                ;If in slot 1,2,or3 reverse grps of two
CD8C: B0 02                        bcs     <a href="#Symallset1">allset1</a>
CD8E: 49 02                        eor     #%00000010
CD90: AA           <span id="Symallset1">allset1</span>         tax
CD91: E8                           inx
CD92: 86 43                        stx     <a href="#SymCMDUnit">CMDUnit</a>           ;You got it
                   ; 
                   ;  Now if this is through the MLI xface, gotta copy stuff into the
                   ;   send buffer from the parameter list.
                   ; 
CD94: B9 73 04                     lda     <a href="#SymProFLAG">ProFLAG</a>,Y
CD97: 10 03                        bpl     <a href="#Symdarnit">darnit</a>
CD99: 4C 40 CE                     jmp     <a href="#Symskipcopy">skipcopy</a>

                   ; 
                   ; Get the address of the in-line parameter table
                   ; 
CD9C: B9 F3 05     <span id="Symdarnit">darnit</span>          lda     <a href="#SymSHTempX">SHTempX</a>,Y         ;Get back the low part buff adr
                   NOTE: pg 522
CD9F: 85 54                        sta     <a href="#Symbuffer">buffer</a>+16
CDA1: B9 73 06                     lda     <a href="#SymSHTempY">SHTempY</a>,Y         ; and the hi part
CDA4: 85 55                        sta     <a href="#Symbuffer">buffer</a>+17
                   ; 
                   ; Now pull out the command code, and the address of the parameters.
                   ; 
CDA6: A0 01                        ldy     #1                ;Stacked address is EA-1
CDA8: B1 54                        lda     ($54),Y
CDAA: 85 42                        sta     <a href="#SymCMDCode">CMDCode</a>           ;Nice
CDAC: C8                           iny
CDAD: B1 54                        lda     ($54),Y           ;Get lo part of parmlist address
CDAF: AA                           tax                       ;Save it
CDB0: C8                           iny
CDB1: B1 54                        lda     ($54),Y           ;Get hi part
CDB3: 85 55                        sta     <a href="#Symbuffer">buffer</a>+17
CDB5: 86 54                        stx     $54
                   ; 
                   ; Now buffer points to parmlist
                   ;  Check command type, and pidgeonhole the parmlist length
                   ; 
CDB7: A9 01                        lda     #<a href="#SymBadCmd">BadCmd</a>
CDB9: A6 42                        ldx     <a href="#SymCMDCode">CMDCode</a>
CDBB: E0 0A                        cpx     #$0A              ;Only valid codes are 0-9
CDBD: 90 03                        bcc     <a href="#Symnoeh">noeh</a>              ;=&gt; at least he got that right
CDBF: 4C 17 CF     <span id="SymErrorHitch">ErrorHitch</span>      jmp     <a href="#SymError">Error</a>             ;Gee, maybe we should promote this guy...

CDC2: A0 00        <span id="Symnoeh">noeh</span>            ldy     #0                ;Set for indct compare
CDC4: B1 54                        lda     ($54),Y           ;Get # of parms?
CDC6: 85 5A                        sta     <a href="#SymUnit">Unit</a>
                   ; 
                   ; Now copy the bytes
                   ; 
CDC8: A0 08        <span id="Symokaycnt">okaycnt</span>         ldy     #<a href="#Symcmdlength">cmdlength</a>-1      ;Always copy the maximum
CDCA: B1 54        <span id="Symcopyloop">copyloop</span>        lda     ($54),Y           ;Pull it out of their hat
CDCC: 99 42 00                     sta     <a href="#SymCMDCode">CMDCode</a>,Y         ;Stuff it into mine
CDCF: 88                           dey
CDD0: D0 F8                        bne     <a href="#Symcopyloop">copyloop</a>          ;Copy 'em all
                   ; 
                   ; Okay.  The caller of the PC could be making one of three calls
                   ;  with a unit number of $00, Control, Init or Status.  Check for
                   ;  these and do what is appropriate.
                   ; 
CDD2: A5 43                        lda     <a href="#SymCMDUnit">CMDUnit</a>
CDD4: D0 6A                        bne     <a href="#Symskipcopy">skipcopy</a>          ;Never mind
                   ; 
                   ; Check the parameter count for this call to unit#0
                   ; 
CDD6: A6 42                        ldx     <a href="#SymCMDCode">CMDCode</a>
CDD8: BD 8E CF                     lda     <a href="#Symparmctab">parmctab</a>,X        ;Get the length this command
CDDB: 29 7F                        and     #$7F              ;Force 0 -&gt; MSB
CDDD: A8                           tay                       ;Hang on
CDDE: A9 04                        lda     #<a href="#SymBadPCnt">BadPCnt</a>          ;Antic bad count
CDE0: C4 5A                        cpy     <a href="#SymUnit">Unit</a>              ;User's pcount is currently here
CDE2: D0 DB                        bne     <a href="#SymErrorHitch">ErrorHitch</a>        ;What a baby!
                   ; 
                   ; Now service one of the three commands
                   ; 
CDE4: E0 05                        cpx     #<a href="#SymInitCmd">InitCmd</a>
CDE6: D0 0A                        bne     <a href="#Symnotinit">notinit</a>           ;Not an Init call
CDE8: A9 00                        lda     #<a href="#SymPowerReset">PowerReset</a>       ;Just like powerup or reset key (//c)
CDEA: 20 98 CF                     jsr     <a href="#SymAssignID">AssignID</a>          ;Do a reset cycle
CDED: A9 00        <span id="SymAokay">Aokay</span>           lda     #0                ;No error allowed
CDEF: 4C 39 CF                     jmp     <a href="#Symsa2">sa2</a>

CDF2: 8A           <span id="Symnotinit">notinit</span>         txa                       ;Eqiv to 'cmp #StatusCMD'
CDF3: D0 24                        bne     <a href="#Symmaybectrl">maybectrl</a>
                   ; 
CDF5: A9 21                        lda     #<a href="#SymBadCtl">BadCtl</a>           ;Antic a non zero stat code
CDF7: A6 46                        ldx     <a href="#SymCMDSCode">CMDSCode</a>          ;Stat unit#0 can only be code=0
CDF9: D0 C4                        bne     <a href="#SymErrorHitch">ErrorHitch</a>
                   ; 
CDFB: 8A                           txa                       ;Equiv to `lda #0`
CDFC: A6 58                        ldx     <a href="#SymSlot">Slot</a>
CDFE: A0 07                        ldy     #7
CE00: 91 44        <span id="Symnin1">nin1</span>            sta     (<a href="#SymCMDBufferl">CMDBufferl</a>),Y    ;Clear some space
CE02: 88                           dey
CE03: D0 FB                        bne     <a href="#Symnin1">nin1</a>
CE05: BD F9 06                     lda     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+1,X
CE08: 91 44                        sta     (<a href="#SymCMDBufferl">CMDBufferl</a>),Y    ;Stick it where they want it
CE0A: C8                           iny
                   ; 
CE0B: AD F9 04                     lda     <a href="#SymSCRNHOLE1">SCRNHOLE1</a>+1       ;//C Port 1 interrupt status
                   ; 
CE0E: 91 44                        sta     (<a href="#Symbuffer">buffer</a>),Y
                   ; 
CE10: A9 08                        lda     #8
CE12: 88                           dey                       ;A,Y has 0008; # bytes status
CE13: 20 F0 CF                     jsr     <a href="#Symsquirrel">squirrel</a>
                   ; 
CE16: 4C ED CD                     jmp     <a href="#SymAokay">Aokay</a>             ;Skip down (up) with no error)

CE19: C9 04        <span id="Symmaybectrl">maybectrl</span>       cmp     #<a href="#SymControlCmd">ControlCmd</a>
CE1B: D0 0B                        bne     <a href="#SymBUnit">BUnit</a>             ;Unit #0 was a bad one
                   ; 
CE1D: A6 46                        ldx     <a href="#SymCMDSCode">CMDSCode</a>          ;We allow two control calls for Unit#0
CE1F: F0 0B                        beq     <a href="#Symenabint">enabint</a>           ;0 means enable interrupts
CE21: CA                           dex
CE22: F0 14                        beq     <a href="#Symdisabint">disabint</a>          ;1 means disable interrupts
CE24: A9 21                        lda     #<a href="#Symbadctl">badctl</a>
                   ; 
CE26: D0 97        <span id="SymErrorHitch2">ErrorHitch2</span>     bne     <a href="#SymErrorHitch">ErrorHitch</a>        ;No other codes allowed
CE28: A9 11        <span id="SymBUnit">BUnit</span>           lda     #<a href="#SymBadUnit">BadUnit</a>          ;Only certain calls can have Unit#0
CE2A: D0 93                        bne     <a href="#SymErrorHitch">ErrorHitch</a>        ;Branch always

                   ; 
CE2C: A9 C0        <span id="Symenabint">enabint</span>         lda     #$C0
CE2E: 8D F9 05                     sta     <a href="#SymSCRNHOLE3">SCRNHOLE3</a>+1
CE31: A9 0F                        lda     #$0F
CE33: 0C 9A C0                     tsb     $C09A
CE36: D0 05                        bne     <a href="#Symaokayhitch">aokayhitch</a>
                   ; 
CE38: A9 01        <span id="Symdisabint">disabint</span>        lda     #$01
CE3A: 1C 9A C0                     trb     $C09A
CE3D: 4C ED CD     <span id="Symaokayhitch">aokayhitch</span>      jmp     <a href="#SymAokay">Aokay</a>

                   ; 
                   ; Okay, everything's all groovy.  ProDOS re-enters here.
                   ;  Check Unit number to be sure there is a corresponding device
                   ; 
CE40: A9 28        <span id="Symskipcopy">skipcopy</span>        lda     #<a href="#SymNoDrive">NoDrive</a>          ;Anticpate bad unit number
CE42: A4 58                        ldy     <a href="#SymSlot">Slot</a>
CE44: BE F9 06                     ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+1,Y
CE47: E4 43                        cpx     <a href="#SymA4H">A4H</a>
CE49: 90 DB                        bcc     <a href="#SymErrorHitch2">ErrorHitch2</a>       ;Safe- If C clr then Z is clr
                   ; 
                   ; Set buffer and bytecount in anticpation of the inevitable SendPack
                   ; 
CE4B: A9 09                        lda     #<a href="#Symcmdlength">cmdlength</a>
CE4D: 85 4D                        sta     <a href="#Symbytecountl">bytecountl</a>
CE4F: A9 00                        lda     #&gt;<a href="#Symcmdlength">cmdlength</a>
CE51: 85 4E                        sta     <a href="#Symbytecounth">bytecounth</a>
CE53: 85 55                        sta     <a href="#Symbuffer">buffer</a>+17
CE55: A9 42                        lda     #<a href="#SymCMDCode">CMDCode</a>
CE57: 85 54                        sta     $54
                   ; 
                   ; If it's a PC call, omit the next two steps
                   ; 
CE59: A6 58                        ldx     <a href="#SymSlot">Slot</a>
CE5B: BD 73 04                     lda     <a href="#SymProFLAG">ProFLAG</a>,X         ;Is it a call from ProDOS?
CE5E: 10 13                        bpl     <a href="#Symnotstat">notstat</a>           ;=&gt; Statcode already set...
                   ; 
                   ; Need to generate a paramter count for a ProDOS call
                   ; 
CE60: A6 42                        ldx     <a href="#SymCMDCode">CMDCode</a>
CE62: BD 8E CF                     lda     <a href="#Symparmctab">parmctab</a>,X
CE65: 29 7F                        and     #$7F
CE67: 85 5A                        sta     <a href="#SymUnit">Unit</a>
                   ; 
                   ; ProDOS always needs the highest blockno byte zeroed
                   ; 
CE69: A9 00                        lda     #0
CE6B: 85 48                        sta     <a href="#SymCMDBlocks">CMDBlocks</a>
                   ; 
                   ;  IF this is a ProDOS status call, set stat code to zero
                   ; 
CE6D: A5 42                        lda     <a href="#SymCMDCode">CMDCode</a>
CE6F: D0 02                        bne     <a href="#Symnotstat">notstat</a>           ;=&gt; Not status so forget it
                   ; lda #SCDeviceStat  ;A is already zero
CE71: 85 46                        sta     <a href="#SymCMDSCode">CMDSCode</a>          ;Store in command table
                   ; 
                   ; Okay, finally send over the damn command
                   ; 
CE73: A5 5A        <span id="Symnotstat">notstat</span>         lda     <a href="#SymUnit">Unit</a>
CE75: A6 43                        ldx     <a href="#SymCMDPcount">CMDPcount</a>         ;Swap the Parmcount &amp; unit#
CE77: 86 5A                        stx     <a href="#SymUnit">Unit</a>
CE79: 85 43                        sta     <a href="#SymCMDPcount">CMDPcount</a>         ;Now they're correct
                   ; 
CE7B: A9 80                        lda     #<a href="#Symcmdmark">cmdmark</a>
CE7D: 85 5B                        sta     <a href="#SymWpacketType">WpacketType</a>       ;WPacketType
                   ; 
CE7F: 20 87 CA                     jsr     <a href="#SymClrPhases">ClrPhases</a>         ;Bring all phases off for Quark
                   ; 
CE82: 20 E9 CA                     jsr     <a href="#SymSendPack">SendPack</a>
CE85: B0 46                        bcs     <a href="#Symbehitch">behitch</a>           ;If not okay, skip to bus error
                   ; 
                   ; Now copy over the buffer address for any data xfer
                   ; 
CE87: A5 44                        lda     <a href="#SymCMDBuffer">CMDBuffer</a>
CE89: 85 54                        sta     $54
CE8B: A5 45                        lda     <a href="#SymCMDBuffer">CMDBuffer</a>+1
CE8D: 85 55                        sta     <a href="#Symbuffer">buffer</a>+17
                   ; 
                   ; Now for some commands, we have to send over a packet of data, too.
                   ;  See if this command is one of THOSE.
                   ; 
CE8F: A6 42                        ldx     <a href="#SymCMDCode">CMDCode</a>
CE91: BD 8E CF                     lda     <a href="#Symparmctab">parmctab</a>,X
CE94: 10 3B                        bpl     <a href="#Symnoxtrasend">noxtrasend</a>        ;Encoded in top bit
                   ; 
                   ; The buffer address and bytecount depend on the call type.
                   ; 
CE96: E0 04                        cpx     #<a href="#SymControlCmd">ControlCmd</a>
CE98: D0 18                        bne     <a href="#SymNOControl">NOControl</a>
                   ; 
                   ; In the case of control, bytecount:=(buffer)
                   ; and buffer :=buffer+2
                   ; 
CE9A: A0 01                        ldy     #1
CE9C: B1 54                        lda     ($54),Y           ;Get Hi order bytecount
CE9E: AA                           tax
CE9F: 88                           dey
CEA0: B1 54                        lda     ($54),Y
CEA2: 48                           pha                       ;Keep for later
CEA3: 18                           clc
CEA4: A9 02                        lda     #2
CEA6: 65 54                        adc     $54
CEA8: 85 54                        sta     $54
CEAA: 68                           pla                       ;Get back Lo order bytecount
CEAB: 90 13                        bcc     <a href="#Symsecondsend">secondsend</a>        ;Skip hi ord increment
CEAD: E6 55                        inc     <a href="#Symbuffer">buffer</a>+17
CEAF: 4C C0 CE                     jmp     <a href="#Symsecondsend">secondsend</a>        ;Skip to store bytecount

CEB2: E0 02        <span id="SymNOControl">NOControl</span>       cpx     #<a href="#SymWriteCmd">WriteCmd</a>         ;Check for a writeblock
CEB4: D0 06                        bne     <a href="#SymNOWBlock">NOWBlock</a>          ;Must be control or write
                   ; 
                   ;  In the case of WriteBlock, the length is 512 and the buffer
                   ;   address is at buffer in the command table
                   ; 
CEB6: A9 00                        lda     #0
CEB8: A2 02                        ldx     #2
CEBA: D0 04                        bne     <a href="#Symsecondsend">secondsend</a>

                   ; 
                   ; For FileWrite, the buffer address is at CMDbuffer
                   ;  and the length is at CMDblock.
                   ; 
CEBC: A6 47        <span id="SymNOWBlock">NOWBlock</span>        ldx     <a href="#SymCMDBlockh">CMDBlockh</a>
CEBE: A5 46                        lda     <a href="#SymCMDBlockl">CMDBlockl</a>
                   ; 
CEC0: 86 4E        <span id="Symsecondsend">secondsend</span>      stx     <a href="#Symbytecounth">bytecounth</a>
CEC2: 85 4D                        sta     <a href="#Symbytecountl">bytecountl</a>
                   ; 
CEC4: A9 82                        lda     #<a href="#Symdatamark">datamark</a>
CEC6: 85 5B                        sta     <a href="#SymWpacketType">WpacketType</a>       ;Identify this as a data packet
                   ; 
CEC8: 20 DA CA                     jsr     <a href="#SymSendData">SendData</a>
CECB: 90 04                        bcc     <a href="#Symnoxtrasend">noxtrasend</a>
                   ; 
CECD: A9 06        <span id="Symbehitch">behitch</span>         lda     #<a href="#SymBusErr">BusErr</a>           ;This is a bus error hitch
CECF: D0 46                        bne     <a href="#SymError">Error</a>

                   ; 
                   ; On ProDOS status call, we've got to a point the buffer pointer
                   ;  correctly to zero page... it's the only case special case
                   ;  (on Write, Format and Control no data comes back).
                   ; 
CED1: A4 58        <span id="Symnoxtrasend">noxtrasend</span>      ldy     <a href="#SymSlot">Slot</a>
CED3: B9 73 04                     lda     <a href="#SymProFLAG">ProFLAG</a>,Y
CED6: 10 0C                        bpl     <a href="#Symgetresults">getresults</a>
CED8: A5 42                        lda     <a href="#SymCMDCode">CMDCode</a>
CEDA: D0 08                        bne     <a href="#Symgetresults">getresults</a>
                   ; 
CEDC: A9 45                        lda     #<a href="#SymCMDBufferh">CMDBufferh</a>       ;Want status in these four
CEDE: A2 00                        ldx     #&gt;<a href="#SymCMDBufferh">CMDBufferh</a>
CEE0: 85 54                        sta     $54
CEE2: 86 55                        stx     <a href="#Symbuffer">buffer</a>+17
                   ; 
                   ; Please to be calling ReceivePack
                   ; 
CEE4: 20 30 CB     <span id="Symgetresults">getresults</span>      jsr     <a href="#SymRecPack">RecPack</a>           ;Get status byte (maybe read data too)
CEE7: B0 E4                        bcs     <a href="#Symbehitch">behitch</a>
                   ; 
                   ; Figure out how many bytes were sent and put that in X,Y temps
                   ; 
CEE9: 20 51 CC                     jsr     <a href="#SymRcvcount">Rcvcount</a>          ;Do the time 7...
CEEC: 20 F0 CF                     jsr     <a href="#Symsquirrel">squirrel</a>          ;Store away count in SHTEMPs
                   ; 
                   ; For the ProDOS status call, we've got to look at the status byte
                   ;  returned and return a DIP error if appropriate. Also overwrite
                   ;  the X,Y temps with # blocks if this is a ProDOS Stat Call.
                   ; 
CEEF: A5 42                        lda     <a href="#SymCMDCode">CMDCode</a>           ;Is this a ProDOS status call
CEF1: D0 22                        bne     <a href="#Symnoerror">noerror</a>
CEF3: A6 58                        ldx     <a href="#SymSlot">Slot</a>
CEF5: BD 73 04                     lda     <a href="#SymProFLAG">ProFLAG</a>,X
CEF8: 10 1B                        bpl     <a href="#Symnoerror">noerror</a>
                   ; 
CEFA: A5 46                        lda     <a href="#SymCMDBlockl">CMDBlockl</a>         ;This'll get loaded into the XY regs later
CEFC: 9D F3 05                     sta     <a href="#SymSHTempX">SHTempX</a>,X
CEFF: A5 47                        lda     <a href="#SymCMDBlockh">CMDBlockh</a>
CF01: 9D 73 06                     sta     <a href="#SymSHTempY">SHTempY</a>,X
CF04: A5 45                        lda     <a href="#SymCMDBufferh">CMDBufferh</a>        ;Check status byte
CF06: 4A                           lsr     A
CF07: 4A                           lsr     A
CF08: 4A                           lsr     A
CF09: 90 04                        bcc     <a href="#SymChkOffLn">ChkOffLn</a>          ;no error, go check off line
CF0B: A9 2B                        lda     #<a href="#SymWriteProt">WriteProt</a>        ;else set WPROT error
CF0D: 80 08                        bra     <a href="#SymError">Error</a>

CF0F: 4A           <span id="SymChkOffLn">ChkOffLn</span>        lsr     A
CF10: 4A                           lsr     A
CF11: A9 2F                        lda     #<a href="#SymOffline">Offline</a>          ;Assume error
CF13: 90 02                        bcc     <a href="#SymError">Error</a>
                   ; 
                   ; Now it's time to think about returning to the caller
                   ;  Remember that ProDOS doesn't want to know about soft errors, 
                   ;  only fatal ones.  If this is a ProDOS call, and the soft error
                   ;  bit in the statbyte is set, there IS NO error (statbyte is 
                   ;  cleared). Also, ProDOS wants only, I/O, Write Protect, No Device,
                   ;  Offline.  If any other hard error comes from the device
                   ;  on a ProDOS call, map it to an I/O Error. (Gross me out.)
                   ; 
CF15: A5 4D        <span id="Symnoerror">noerror</span>         lda     <a href="#Symstatbyte">statbyte</a>
                   ; 
CF17: A4 58        <span id="SymError">Error</span>           ldy     <a href="#SymSlot">Slot</a>              ;Need access to screenholes
CF19: 99 F3 04                     sta     <a href="#SymRetry">Retry</a>,Y           ;Keep unadulterated error in shole
CF1C: AA                           tax                       ;set the Z flag
CF1D: F0 1A                        beq     <a href="#Symsa2">sa2</a>               ;Special case the zero
CF1F: BE 73 04                     ldx     <a href="#SymProFLAG">ProFLAG</a>,Y         ;Set N to ProDOS call or not
CF22: 10 15                        bpl     <a href="#Symsa2">sa2</a>               ;If PC call, no mapping occurs
CF24: A2 00                        ldx     #0                ;Assume a soft error
CF26: C9 40                        cmp     #%01000000        ;Soft Error Check
CF28: B0 0E                        bcs     <a href="#Symstoreaway">storeaway</a>         ;If $40 or bigger, map to zero
                   ; 
CF2A: A2 27                        ldx     #<a href="#SymIOError">IOError</a>          ;Now anticipate ProDOS I/O error
CF2C: C9 2B                        cmp     #<a href="#SymWriteProt">WriteProt</a>
CF2E: F0 09                        beq     <a href="#Symsa2">sa2</a>               ;OK to return Write Protect
CF30: C9 28                        cmp     #<a href="#SymNoDrive">NoDrive</a>
CF32: F0 05                        beq     <a href="#Symsa2">sa2</a>               ;OK to return Drive disconnected
CF34: C9 2F                        cmp     #<a href="#SymOffline">Offline</a>
CF36: F0 01                        beq     <a href="#Symsa2">sa2</a>
                   ; 
CF38: 8A           <span id="Symstoreaway">storeaway</span>       txa                       ;Use the default value
                   ; 
CF39: A4 58        <span id="Symsa2">sa2</span>             ldy     <a href="#SymSlot">Slot</a>
CF3B: 99 73 05                     sta     <a href="#SymSHTemp1">SHTemp1</a>,Y         ;Keep in screenhole
                   ; If this is the //c version, we need to reset the IWN to its
                   ;  former disk // state.  This is done by setting the mode register
                   ;  to a little known (and less documented) mode which speeds up the 
                   ;  internal motor timeout.  When the motor enable has timed out, the
                   ;  mode can be set back to zero.  This method is necessary because
                   ;  if the timer is enabled within the timeout period, the motor on a 
                   ;  Rev A IWM pops on for the full timeout period (since mode changes
                   ;  are disabled when the motor is on.  It's bizzare. Blame Mac.
CF3E: AD E8 C0                     lda     <a href="#Symmonclr">monclr</a>+96         ;Motor Off
CF41: 2C ED C0                     bit     <a href="#Syml6set">l6set</a>+96          ;Into mode reg access mode
CF44: A9 2B                        lda     #$2B              ;This is the magic "speed up" value
CF46: 8D EF C0                     sta     <a href="#Syml7set">l7set</a>+96          ;Throw into mode register
CF49: EA                           nop                       ;You're supposed to wait a while
CF4A: EA                           nop
CF4B: EA                           nop
CF4C: EA                           nop
                   ; 
CF4D: AD EE C0     <span id="Symwaitoff">waitoff</span>         lda     <a href="#Syml7clr">l7clr</a>+96          ;Wait 'til motor off
CF50: 29 20                        and     #$20
CF52: D0 F9                        bne     <a href="#Symwaitoff">waitoff</a>
CF54: A0 00                        ldy     #0                ;Now set the reg back to $00
CF56: A2 60                        ldx     #$60              ;IWM's in slot 6
CF58: 20 20 CC                     jsr     <a href="#SymSetIWMode">SetIWMode</a>
CF5B: AD EC C0                     lda     <a href="#Syml6clr">l6clr</a>+96
CF5E: AD E2 C0                     lda     <a href="#Symca1clr">ca1clr</a>+96
CF61: AD E6 C0                     lda     <a href="#Symlstrbclr">lstrbclr</a>+96
CF64: A4 58                        ldy     <a href="#SymSlot">Slot</a>              ;Need Slot in Y
                   ; 
                   ;  Now, restore our zero page area.
                   ; 
CF66: A2 00                        ldx     #0
CF68: 68           <span id="Symrzp">rzp</span>             pla
CF69: 95 40                        sta     <a href="#Symzeropage">zeropage</a>,X
CF6B: E8                           inx
CF6C: E0 1C                        cpx     #<a href="#SymZPSize">ZPSize</a>
CF6E: 90 F8                        bcc     <a href="#Symrzp">rzp</a>
                   ; 
                   ;  We're into the stretch!  Restore interrupt mask, load X, Y,
                   ;    and A and set the carry if the error byte is non-zero.
                   ; 
CF70: 28                           plp                       ;Restore interrupt flag
CF71: B9 F3 05                     lda     <a href="#SymSHTempX">SHTempX</a>,Y         ;Get X value
CF74: AA                           tax
CF75: B9 73 05                     lda     <a href="#SymSHTemp1">SHTemp1</a>,Y         ;Grab the error result code
CF78: 48                           pha
CF79: B9 73 06                     lda     <a href="#SymSHTempY">SHTempY</a>,Y         ;Pull out the Y value
CF7C: A8                           tay                       ;No more access to screenholes
CF7D: 18                           clc                       ;Anticipate zero result code
CF7E: 68                           pla                       ;Pull back result code
CF7F: F0 01                        beq     <a href="#Symfinalskip">finalskip</a>         ;Return with carry clear
CF81: 38                           sec                       ;Some type of error
                   ; 
CF82: 08           <span id="Symfinalskip">finalskip</span>       php                       ;Save carry and Z flag
CF83: 2C 78 04                     bit     <a href="#SymProFLAG">ProFLAG</a>+5         ;Ick - ProFlag is fixed in //c
CF86: 70 04                        bvs     <a href="#Symick1">ick1</a>              ;If bit 6=1, then return to alt ROM
CF88: 28                           plp                       ;Vclr so return across ROM bank bdy
CF89: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

CF8C: 28           <span id="Symick1">ick1</span>            plp
CF8D: 60                           rts                       ;Flags set correctly again

CF8E: 03           <span id="Symparmctab">parmctab</span>        DFB     %00000011         ;Status:  3 parms/no data send
CF8F: 03                           DFB     %00000011         ;Read:    3 parms/no data send
CF90: 83                           DFB     %10000011         ;Write:   3 parms/data send
CF91: 01                           DFB     %00000001         ;Format:  1 parm /no data send
CF92: 83                           DFB     %10000011         ;Control: 3 parms/data send
CF93: 01                           DFB     %00000001         ;Init:    1 parm /no data send
CF94: 01                           DFB     %00000001         ;Open:    1 parm /no data send
CF95: 01                           DFB     %00000001         ;Close:   1 parm /no data send
CF96: 03                           DFB     %00000011         ;CharRead: 3 parms/data send
CF97: 83                           DFB     %10000011         ;CharWrite: 3 parms/data send

CF98: 48           <span id="SymAssignID">AssignID</span>        pha                       ;Save the init code
CF99: 20                           jsr    <a href="#Symresetchain">resetchain</a>        ;Reset all of those things
CF9A: 5D CA        <span id="Symm_oveirq">m_oveirq</span>        eor    $68CA,X
CF9C: 68                           pla
CF9D: AA                           tax                       ;Save InitCode
                   ; 
                   ;  Save the command code, unit, and init code
                   ;  'cause we'll trample 'em:
CF9E: A5 42                        lda     <a href="#SymCMDCode">CMDCode</a>
CFA0: 48                           pha
CFA1: A5 43                        lda     <a href="#SymCMDPcount">CMDPcount</a>
CFA3: 48                           pha
CFA4: A5 46                        lda     <a href="#SymCMDSCode">CMDSCode</a>
CFA6: 48                           pha
CFA7: 86 46                        stx     <a href="#SymCMDSCode">CMDSCode</a>          ;Store away the type of INIt
                   ; 
                   ;  Set up to send DefID command packets
                   ; 
CFA9: A9 05                        lda     #<a href="#SymInitCmd">InitCmd</a>
CFAB: 85 42                        sta     <a href="#SymCMDCode">CMDCode</a>
CFAD: A9 00                        lda     #0
CFAF: 85 5A                        sta     <a href="#SymUnit">Unit</a>
CFB1: A9 02                        lda     #2                ;# parms in Init Call
CFB3: 85 43                        sta     <a href="#SymCMDPcount">CMDPcount</a>
                   ; 
                   ;  Point the buffer pointer
                   ; 
CFB5: A9 42                        lda     #<a href="#SymCMDCode">CMDCode</a>
CFB7: 85 54                        sta     $54
CFB9: A9 00                        lda     #&gt;<a href="#SymCMDCode">CMDCode</a>
CFBB: 85 55                        sta     <a href="#Symbuffer">buffer</a>+17
CFBD: A9 80                        lda     #<a href="#Symcmdmark">cmdmark</a>
CFBF: 85 5B                        sta     <a href="#SymWpacketType">WpacketType</a>
                   NOTE: Odo agrees
CFC1: 20 87 CA                     jsr     <a href="#SymClrPhases">ClrPhases</a>         ;Make sure phases are off for Quark
                   ; 
                   ;  Send an ID for the next device in the chain
                   ; 
CFC4: E6 5A        <span id="Symmordevices">mordevices</span>      inc     <a href="#SymUnit">Unit</a>
CFC6: A9 09                        lda     #<a href="#Symcmdlength">cmdlength</a>
CFC8: 85 4D                        sta     <a href="#Symbytecountl">bytecountl</a>        ;ReceivePack scrambles count
CFCA: A9 00                        lda     #&gt;<a href="#Symcmdlength">cmdlength</a>
CFCC: 85 4E                        sta     <a href="#Symbytecounth">bytecounth</a>
                   ; 
CFCE: 20 83 C8                     jsr     <a href="#SymSendOnePack">SendOnePack</a>       ;Send the command
CFD1: 90 05                        bcc     <a href="#Symmdev2">mdev2</a>             ;If okay, skip to get response
                   ; 
CFD3: C6 5A                        dec     <a href="#SymUnit">Unit</a>
CFD5: 4C DF CF                     jmp     <a href="#Symmdev1">mdev1</a>

CFD8: 20 E3 C9     <span id="Symmdev2">mdev2</span>           jsr     <a href="#SymReceivePack">ReceivePack</a>       ;Get the response
CFDB: A5 4D                        lda     <a href="#Symbytecount">bytecount</a>
CFDD: F0 E5                        beq     <a href="#Symmordevices">mordevices</a>
                   ; 
                   ;  Okay, we done last device.  Squirrel away the number of devices.
                   ; 
CFDF: A5 5A        <span id="Symmdev1">mdev1</span>           lda     <a href="#SymUnit">Unit</a>
CFE1: A4 58                        ldy     <a href="#SymSlot">Slot</a>
CFE3: 99 F9 06                     sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+1,Y     ;Devices out there
                   ; 
                   ;  Recover the scrambled ProDOS parms
                   ; 
CFE6: 68                           pla
CFE7: 85 46                        sta     <a href="#SymCMDSCode">CMDSCode</a>
CFE9: 68                           pla
CFEA: 85 43                        sta     <a href="#SymCMDPcount">CMDPcount</a>
CFEC: 68                           pla
CFED: 85 42                        sta     <a href="#SymCMDCode">CMDCode</a>
                   ; 
CFEF: 60                           rts

CFF0: A6 58        <span id="Symsquirrel">squirrel</span>        ldx     <a href="#SymSlot">Slot</a>
CFF2: 9D F3 05                     sta     <a href="#SymSHTempX">SHTempX</a>,X
CFF5: 98                           tya
CFF6: 9D 73 06                     sta     <a href="#SymSHTempY">SHTempY</a>,X
CFF9: 60                           rts

CFFA: 00 00 00 00+                 DS      6,$00

                   NOTE: Command processor for serial &amp; comm
                   pdf pg 486
                   ********************************************************************************
                   * The command routine now supports 5 new 2-character commands.  These          *
                   * commands enable or disable af eature of the serial port and                  *
                   * are derived from their equivalent in the super serial card for the //.       *
                   *                                                                              *
                   * The new commands are as follows:                                             *
                   *   L - send LF out after CR                                                   *
                   *   X - detect XOFF, and wait for XON                                          *
                   *   F - accept keyboard input                                                  *
                   *   M - ignore LF in after CR                                                  *
                   *   C - auto CR when column count &gt; printer width                              *
                   *                                                                              *
                   * Usage of location $779 (port 1) and $77A (port 2) are as follows:            *
                   *   bit 7 - echo output to screen if on                                        *
                   *   bit 6 - generate LF after CR if on                                         *
                   *   bit 5 - accept XOFF if on                                                  *
                   *   bit 4 - ignore keyboard input if on                                        *
                   *   bit 3 - accept LF in after CR if on                                        *
                   *   bit 2 - a character was received through the ACIA and is in                *
                   *      location $5FE (port 1) or $67E (port 2) if on                           *
                   *   bit 1 - XOFF is accepted, awaiting XON if on                               *
                   *   bit 0 - signifies comm port if on, printer port if off                     *
                   ********************************************************************************
D000: 48           <span id="Symcommand">command</span>         pha                       ;shove character on stack
D001: 3C B8 03                     bit     <a href="#Symsermode">sermode</a>,X         ;Already in command?
D004: 30 1C                        bmi     <a href="#Symincmd">incmd</a>             ;If so, go do it
D006: BC 38 06                     ldy     <a href="#Symeschar">eschar</a>,X          ;If eschar = 0 ignore commands
D009: F0 14                        beq     <a href="#Symnocmd">nocmd</a>
D00B: 5D 38 06                     eor     <a href="#Symsl_scrn6">sl_scrn6</a>,X        ;Is it the command char?
D00E: 0A                           asl     A                 ;Ignore high bit
D00F: D0 0E                        bne     <a href="#Symnocmd">nocmd</a>             ;char not command char
D011: AC FB 07     <span id="Symcommand1">command1</span>        ldy     <a href="#Symcursor">cursor</a>            ;Save the cursor
D014: 8C 79 06                     sty     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1
D017: A0 BF                        ldy     #<a href="#Symcmdcur">cmdcur</a>           ;Set command cursor
D019: 8C FB 07                     sty     <a href="#Symcursor">cursor</a>
D01C: 4C B5 D0                     jmp     <a href="#Symcominit1">cominit1</a>          ;initiate command mode

D01F: 38           <span id="Symnocmd">nocmd</span>           sec                       ;Mark char not handled
D020: 68           <span id="Symnocmd2">nocmd2</span>          pla                       ;Restore original char
D021: 60                           rts

D022: BC 42 C1     <span id="Symincmd">incmd</span>           ldy     <a href="#Symdevno2">devno2</a>,X          ;Get index for ACIA
D025: 29 5F                        and     #$5F              ;no hi-bit and upshift lower case
D027: 48                           pha                       ;save character
D028: BD B8 03                     lda     <a href="#Symsermode">sermode</a>,X         ;need to see if in 2-chr command
D02B: 89 08                        bit     #$08              ;bit 3 set if so
D02D: D0 03                        bne     <a href="#Symincmd2">incmd2</a>            ;branch if so
D02F: 68                           pla                       ;pull char back, not in 2-chr cmd
D030: 80 52                        bra     <a href="#Symincmd1">incmd1</a>            ;go on with regular command mode

                   ; handle 2nd chr of 2-char commands
D032: 68           <span id="Symincmd2">incmd2</span>          pla                       ;pull char off stack
D033: 48                           pha                       ; &amp; reshove it to keep stack neat
D034: C9 00                        cmp     #<a href="#Symucspace">ucspace</a>          ;is it a space? (uppercased)
D036: D0 04                        bne     <a href="#Symincmd3">incmd3</a>            ;no, go on with 2-chr cmd handling
D038: 18                           clc                       ;yes, ignore spaces between characters
                   ;                                        of 2-chr commands
D039: 68                           pla                       ;pull uppercased char off stack
D03A: 80 E4                        bra     <a href="#Symnocmd2">nocmd2</a>            ;ie mark them "handled" and don't do anything else

D03C: BD B8 03     <span id="Symincmd3">incmd3</span>          lda     <a href="#Symsermode">sermode</a>,X         ;get sermode back
D03F: 48                           pha                       ;save sermode for a minit
D040: 29 07                        and     #7                ;throw out all but bits 0-2
D042: 8D F8 06                     sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;save - this is index of which cmd it is
D045: 68                           pla                       ;get sermode back
D046: 29 F0                        and     #$F0              ;now clear bits 0-3
D048: 9D B8 03                     sta     <a href="#Symsermode">sermode</a>,X         ;since we're done with them now
D04B: 68                           pla                       ;get character back
D04C: DA                           phx                       ;shove x (Cn) on stack
D04D: AE F8 06                     ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;get index to command's 1st chr
D050: C9 45                        cmp     #$45              ;is it an E?
D052: F0 71                        beq     <a href="#Symenable">enable</a>            ;yes
D054: C9 44                        cmp     #$44              ;no, is it a D?
D056: F0 6F                        beq     <a href="#Symdisable">disable</a>           ;yes
D058: FA                           plx                       ;retriefve X=Cn (old X still in temp)
D059: DA                           phx                       ;push it back to keep stack neat
D05A: DD 38 06                     cmp     <a href="#Symsl_scrn6">sl_scrn6</a>,X        ;compare to the command character
D05D: 08                           php                       ;save result of comparison for a bit
D05E: AE F8 06                     ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;reload X= index to cmd's first chr
D061: 28                           plp                       ;retrieve result of comparison of char
                   ;                                        to command char
D062: F0 13                        beq     <a href="#Symflagit">flagit</a>            ;yes tis 1-chr cmd followed by nother cmd
D064: C9 0D                        cmp     #<a href="#SymcharCR">charCR</a>           ;is it a (guess what) CR?
D066: F0 17                        beq     <a href="#Symoneletter">oneletter</a>         ;yes - a 1-chr command
                   ; 
                   ; come here for unimplemented byt legal 2-char commands
                   ; 
D068: FA           <span id="Symcmd2null">cmd2null</span>        plx                       ;pull x (Cn) off stack
D069: AD 79 06                     lda     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;restore non-cmd-mode cursor
D06C: 8D FB 07                     sta     <a href="#Symcursor">cursor</a>
D06F: 1E B8 03                     asl     <a href="#Symsermode">sermode</a>,X         ;clear cmd-mode bit (bit 7 of sermode)
D072: 5E B8 03                     lsr     <a href="#Symsermode">sermode</a>,X         ;by shifting out bit 7 &amp; shifting in a 0
D075: 80 A8                        bra     <a href="#Symnocmd">nocmd</a>             ;return marking character not handled

                   ;                                       ;come here if eschar after LXFM or T
D077: FA           <span id="Symflagit">flagit</span>          plx                       ;next X=Cn to set bit 0 of sermode
D078: DA                           phx                       ;but leave Cn on stack too
D079: FE B8 03                     inc     <a href="#Symsermode">sermode</a>,X         ;bit 0 was 0, but is now 1
                   ;                                        1 means new command mode
D07C: AE F8 06                     ldx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;X= index to cmd's first chr
                   ;                                       ;come here if 2-chr cmd turns out 1 chr
D07F: BD 25 D2     <span id="Symoneletter">oneletter</span>       lda     <a href="#Symcmd2list">cmd2list</a>,X        ;get command chr
D082: 80 0B                        bra     <a href="#Symbackto1">backto1</a>           ;treat it as if we jot got it

                   ;                                       ;in command mode, not 2-chrs tho
D084: DA           <span id="Symincmd1">incmd1</span>          phx                       ;Save slot
D085: A2 04                        ldx     #4                ;check 5 possible 5-chr cmds
D087: DD 25 D2     <span id="Symcmd2loop">cmd2loop</span>        cmp     <a href="#Symcmd2list">cmd2list</a>,X        ;is it there?
D08A: F0 71                        beq     <a href="#Symcmd2found">cmd2found</a>         ;yes, need to flag it for next time
D08C: CA                           dex                       ;nope
D08D: 10 F8                        bpl     <a href="#Symcmd2loop">cmd2loop</a>          ;try next if there is one
                   ;                                       ;come here to check for 1-chr cmds
D08F: A2 0C        <span id="Symbackto1">backto1</span>         ldx     #12               ;Check 13 commands
D091: DD 18 D2     <span id="Symcmdloop">cmdloop</span>         cmp     <a href="#Symcmdlist">cmdlist</a>,X
D094: F0 74                        beq     <a href="#Symcmfound">cmfound</a>           ;Right char?
D096: CA                           dex
D097: 10 F8                        bpl     <a href="#Symcmdloop">cmdloop</a>
D099: FA                           plx                       ;We didn't find it
D09A: 68                           pla
D09B: 48                           pha
D09C: 29 7F                        and     #$7F              ;if char is cntl char
D09E: C9 20                        cmp     #$20              ;it can be the new comd char
D0A0: B0 03                        bcs     <a href="#Symckdig">ckdig</a>             ;branch if not cntrl character
D0A2: 9D 38 06     <span id="Symcmdz2">cmdz2</span>           sta     <a href="#Symsl_scrn6">sl_scrn6</a>,X        ;save command char and
                   ;                                        drop thur ckdig to cdone
D0A5: 49 30        <span id="Symckdig">ckdig</span>           eor     #$30              ;zap it down to 0n if char was a digit
D0A7: C9 0A                        cmp     #$0A              ;is it a digit?
D0A9: B0 33                        bcs     <a href="#Symcdone">cdone</a>             ;skip if no, an unexpected intruder
D0AB: A0 0A                        ldy     #10               ;A = A + 10 * current number
D0AD: 6D 7E 07     <span id="Symdigloop">digloop</span>         adc     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6       ;C=0 on first entry
D0B0: 88                           dey
D0B1: D0 FA                        bne     <a href="#Symdigloop">digloop</a>
D0B3: 80 0A                        bra     <a href="#Symcominit">cominit</a>           ;not starting new cmd mode, just save #

                   ;                                       ;start new cmd mode here
D0B5: BD B8 03     <span id="Symcominit1">cominit1</span>        lda     <a href="#Symsermode">sermode</a>,X         ;get sermode
D0B8: 29 C0                        and     #$C0              ;clear bits 0-5 (starting a new cmd seq--
D0BA: 9D B8 03                     sta     <a href="#Symsermode">sermode</a>,X         ;they are used for misc during cmd mode)
D0BD: A9 00                        lda     #0                ;load a 0 to stuff in NUMBER
D0BF: 8D 7E 07     <span id="Symcominit">cominit</span>         sta     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6
D0C2: 38                           sec                       ;Mark in command mode
D0C3: 80 25                        bra     <a href="#Symcmset">cmset</a>

                   ;                                       ;got a 2-chr command aE
D0C5: 38           <span id="Symenable">enable</span>          sec                       ;set charry
D0C6: 90                           DFB     $90               ;bcc to skip next byte (the CLC)
                   ;                                       ;got a 2-chr command aD
D0C7: 18           <span id="Symdisable">disable</span>         clc                       ;clear carry
D0C8: 08                           php                       ;push P to save carry
D0C9: E0 00                        cpx     #0                ;if X=0 then command is LE or LD
D0CB: F0 27                        beq     <a href="#Symcmd21">cmd21</a>             ;so just make it act like L or K
D0CD: E0 04                        cpx     #4                ;if X=4 then command is CE or CD
D0CF: F0 41                        beq     <a href="#Symcmd_c">cmd_c</a>             ;skip if so
                   ********************************************************************************
                   * for other 2-chr cmds, their FLAGS masks' indexes are 2X+3                    *
                   * for an E or 2X+4 for a D                                                     *
                   ********************************************************************************
D0D1: 8A                           txa                       ;copy x to acc for arithmetic
D0D2: 18                           clc                       ;clear carry for arithmetic
D0D3: 0A                           asl     A                 ;multiply index by 2
D0D4: 69 03                        adc     #3                ;add 3 to get mask index
D0D6: AA                           tax                       ;put mask index in X
D0D7: 28                           plp                       ;get carry back
D0D8: B0 01                        bcs     <a href="#Symxready">xready</a>            ;carry set = Enable so X is ready
D0DA: E8                           inx                       ;cmd was Disable so inc X to next mask
D0DB: 4C 39 D1     <span id="Symxready">xready</span>          jmp     <a href="#Symcmdi">cmdi</a>              ;go do mask stuff to FLAGS

                   ; ;$D0DE: ;sermode bit 0 tells whether to set or clear command mode
D0DE: BD B8 03     <span id="Symcdone">cdone</span>           lda     <a href="#Symsermode">sermode</a>,X         ;so get it
D0E1: 4A                           lsr     A                 ;shift bit 0 to carry
D0E2: B0 D1                        bcs     <a href="#Symcominit1">cominit1</a>          ;if set, start new cmd mode
D0E4: AD 79 06                     lda     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;Restore the cursor
D0E7: 8D FB 07                     sta     <a href="#Symcursor">cursor</a>            ;&amp; fall through to cmset with carry clear
D0EA: 08           <span id="Symcmset">cmset</span>           php
D0EB: 1E B8 03                     asl     <a href="#Symsermode">sermode</a>,X         ;set command mode according to carry
D0EE: 28                           plp
D0EF: 7E B8 03                     ror     <a href="#Symsermode">sermode</a>,X         ;leaves carry clear
D0F2: 68                           pla                       ;character handled
D0F3: 60                           rts                       ;because carry clear...

                   ;                                       ;come here to handle LE &amp; LD
D0F4: A9 4C        <span id="Symcmd21">cmd21</span>           lda     #$4C              ;make LE look like L
D0F6: 28                           plp                       ;get P back with carry indicating E or D
D0F7: B0 96                        bcs     <a href="#Symbackto1">backto1</a>           ;carry set means it was an E
D0F9: A9 4B                        lda     #$4B              ;make LD look like X
D0FB: 80 92                        bra     <a href="#Symbackto1">backto1</a>

D0FD: 8A           <span id="Symcmd2found">cmd2found</span>       txa                       ;copy index of cmd to acc
D0FE: FA                           plx                       ;restore X to Cn
D0FF: 1D B8 03                     ora     <a href="#Symsermode">sermode</a>,X         ;copy top 2 bits of sermode
D102: 09 08                        ora     #$08              ;&amp; set bit 3 - 2-chr-command-mode flag
D104: 9D B8 03                     sta     <a href="#Symsermode">sermode</a>,X         ;sermode = index to 2-chr cmds issued
D107: 38                           sec                       ;set carry so we stay in command mode
D108: 80 E0                        bra     <a href="#Symcmset">cmset</a>             ;for next time

D10A: A9 D1        <span id="Symcmfound">cmfound</span>         lda     #&gt;<a href="#Symcmdcr">cmdcr</a>           ;get hi byte of where to go
D10C: 48                           pha                       ;save it on stack
D10D: BD F5 D1                     lda     <a href="#Symcmdtable">cmdtable</a>,X        ;get lo byte of where to go
D110: 48                           pha                       ;save it on stack
D111: 60                           rts                       ;go there by RTSing

D112: 28           <span id="Symcmd_c">cmd_c</span>           plp                       ;restore status to check carry bit
D113: FA                           plx                       ;restore slot number in x
D114: B0 05                        bcs     <a href="#Symcmd_cl">cmd_cl</a>            ;skip if enable
D116: 9E B8 04                     stz     <a href="#Sympower2">power2</a>,X          ;CD is same as PWDTH=0, no CR
D119: 80 C3                        bra     <a href="#Symcdone">cdone</a>             ;we're done here

                   ;                       ;defidx2-$C1
D11B: BC 86 D1     <span id="Symcmd_cl">cmd_cl</span>          ldy     <a href="#SymLD186">LD186</a>,X           ;get y index into aux screenholes
D11E: 20 2A D2                     jsr     <a href="#Symr_getalt">r_getalt</a>          ;go get it from aux
D121: 9D B8 04                     sta     <a href="#Sympower2">power2</a>,X          ;restore default PWDTH
D124: 80 B8                        bra     <a href="#Symcdone">cdone</a>             ;we're done here

D126: FA           <span id="Symcmdz">cmdz</span>            plx                       ;Zero escape character
D127: 9E B8 04                     stz     <a href="#Sympower2">power2</a>,X          ;And the width
D12A: A9 00                        lda     #0
D12C: 4C A2 D0                     jmp     <a href="#Symcmdz2">cmdz2</a>

                   ; cmdcr equ D12F
                   ; cmdn  equ D12F
D12F: 7A                           ply
D130: AD 7E 07                     lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6       ;Get number inputted
D133: F0 05                        beq     <a href="#Symcmdi2">cmdi2</a>             ;skip if 0
D135: 99 B8 04                     sta     <a href="#Sympower2">power2</a>,Y          ;Update printer width
D138: F0                           DFB     $F0               ;BEQ opcode to skip next byte (the PLY)
                   ; cmdi equ D139
                   ; cmdk equ D139
                   ; cmkl equ D139
D139: 7A           <span id="Symcmdi">cmdi</span>            ply
D13A: B9 B8 06     <span id="Symcmdi2">cmdi2</span>           lda     <a href="#Sympowerup">powerup</a>,Y
D13D: 3D 02 D2                     and     <a href="#Symmask1">mask1</a>,X           ;Mask off bit we'll change
D140: 1D 0D D2                     ora     <a href="#Symmask2">mask2</a>,X           ;Change it
D143: 99 B8 06                     sta     <a href="#Sympowerup">powerup</a>,Y         ;Back it goes
D146: 98                           tya                       ;Put slot back in x
D147: AA                           tax                       ;(via acc)
D148: 4C DE D0     <span id="Symcdone2">cdone2</span>          jmp     <a href="#Symcdone">cdone</a>             ;Good byte

D14B: 88           <span id="Symcmdp">cmdp</span>            dey                       ;Make y point to command reg
D14C: A9 1F        <span id="Symcmdd">cmdd</span>            lda     #$1F              ;Mask off high three bits
D14E: 38                           sec                       ;C=1 means high 3 bits
D14F: 90                           DFB     $90               ;BCC opcode to skip next byte
D150: A9 F0        <span id="Symcmdb">cmdb</span>            lda     #$F0              ;mask off lower 4 bits F0 = BNE
D152: 18                           clc                       ;F= will skip this if cmdp or cmdd
D153: 39 FB BF                     and     <a href="#Symdata">data</a>,Y            ;mask off bits being changed
D156: 8D F8 06                     sta     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;Save it
D159: FA                           plx
D15A: AD 7E 07                     lda     <a href="#SymSCRNHOLE6">SCRNHOLE6</a>+6       ;Get inputed number
D15D: 29 0F                        and     #$0F              ;Only lower nibble valid
D15F: 90 05                        bcc     <a href="#Symnoshift">noshift</a>           ;If C=1 shift tto upper 3 bits

D161: 0A                           asl     A
D162: 0A                           asl     A
D163: 0A                           asl     A
D164: 0A                           asl     A
D165: 0A                           asl     A
D166: 0D F8 06     <span id="Symnoshift">noshift</span>         ora     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>         ;Get the rest of the bits
D169: C8                           iny                       ;Put them in the ACIA
D16A: 80 17                        bra     <a href="#Symcmdp2">cmdp2</a>             ;increment puts em away where they go.

D16C: B9 FA BF     <span id="Symcmds">cmds</span>            lda     <a href="#Symscmod">scmod</a>,Y           ;Transmit a break
D16F: 48                           pha                       ;Save current ACIA state
D170: 09 0C                        ora     #$0C              ;Do the break
D172: 99 FA BF                     sta     <a href="#Symscmod">scmod</a>,Y
D175: A9 E9                        lda     #233              ;For 233 ms
D177: A2 53        <span id="Symmswait">mswait</span>          ldx     #83               ;Wait 1 ms
D179: 48           <span id="Symmsloop">msloop</span>          pha                       ;((12*82)+11)+2+3=1000us
D17A: 68                           pla
D17B: CA                           dex
D17C: D0 FB                        bne     <a href="#Symmsloop">msloop</a>
D17E: 3A                           dec     A
D17F: D0 F6                        bne     <a href="#Symmswait">mswait</a>
D181: 68                           pla
D182: FA                           plx
D183: 99 FA BF     <span id="Symcmdp2">cmdp2</span>           sta     <a href="#Symscmod">scmod</a>,Y
D186: 80 C0        <span id="SymLD186">LD186</span>           bra     <a href="#Symcdone2">cdone2</a>

D188: 99 F9 BF     <span id="Symcmdr">cmdr</span>            sta     <a href="#Symaddrm">addrm</a>,Y           ;Reset the ACIA
D18B: AD 7B 06                     lda     <a href="#Symvfactv">vfactv</a>            ;Check if video firmware active
D18E: 0A                           asl     A                 ;Save it in C
D18F: 20 97 C7                     jsr     <a href="#Symswsthk2">swsthk2</a>           ;assume video firmware active
D192: 90 03                        bcc     <a href="#Symcmdq">cmdq</a>              ;branch if good guesser...
D194: 20 9D C7                     jsr     <a href="#Symswzzqt2">swzzqt2</a>           ;Reset the hooks
D197: 18           <span id="Symcmdq">cmdq</span>            clc                       ;Quit terminal mode
D198: B0                           DFB     $B0               ;BCS to skip next byte
D199: 38           <span id="Symcmdt">cmdt</span>            sec                       ;Into terminal mode
D19A: FA                           plx                       ;Recover X
D19B: 20 A0 D1                     jsr     <a href="#Symsetterm">setterm</a>
D19E: 80 A8                        bra     <a href="#Symcdone2">cdone2</a>

                   ;                                       ;set/clear terminal mode
D1A0: BD B8 03     <span id="Symsetterm">setterm</span>         lda     <a href="#Symsermode">sermode</a>,X         ;Get terminal mode status
D1A3: 89 40                        bit     #$40              ;Z=1 if not in terminal mode
D1A5: 90 12                        bcc     <a href="#Symstclr">stclr</a>             ;Branch if clearing terminal mode
D1A7: D0 20                        bne     <a href="#Symstwasok">stwasok</a>           ;Was already set
D1A9: E4 39                        cpx     <a href="#Symkswh">kswh</a>              ;Are we in the input hooks
D1AB: D0 47                        bne     <a href="#Symstrts">strts</a>             ;Leaves C=1 if =
D1AD: 09 40                        ora     #$40              ;Set term mode bit
D1AF: AC 79 06                     ldy     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;Save what was in oldcur
D1B2: 8C 7A 06                     sty     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+2
D1B5: A0 DF                        ldy     #<a href="#Symtermcur">termcur</a>          ;Get new cursor value
D1B7: 80 07                        bra     <a href="#Symstset">stset</a>

D1B9: F0           <span id="Symstclr">stclr</span>           DFB     $F0               ;Branch if already clear
D1BA: 0E                           DFB     $0E
D1BB: 29                           DFB     $29               ;Clear the bit
D1BC: BF                           DFB     $BF
D1BD: AC                           DFB     $AC               ;Restore the cursor
D1BE: 7A                           DFB     $7A
D1BF: 06                           DFB     $06

D1C0: 9D B8 03     <span id="Symstset">stset</span>           sta     <a href="#Symsermode">sermode</a>,X
D1C3: 8C 79 06                     sty     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+1       ;Save cursor to be restored after command
D1C6: 8C FB 07                     sty     <a href="#Symcursor">cursor</a>
D1C9: BC 42 C1     <span id="Symstwasok">stwasok</span>         ldy     <a href="#Symdevno2">devno2</a>,X
D1CC: 58                           cli                       ;want to leave with interrupts active
D1CD: 08                           php
D1CE: 78                           sei                       ;but off while we twittle bits
D1CF: B9 FA BF                     lda     <a href="#Symscmod">scmod</a>,Y
D1D2: 09 02                        ora     #2                ;disable receiver interrupts if
D1D4: 90 02                        bcc     <a href="#Symcmdt2">cmdt2</a>             ; not in terminal mode
D1D6: 29 FD                        and     #$FD              ;enable when in terminal mode
D1D8: 99 FA BF     <span id="Symcmdt2">cmdt2</span>           sta     <a href="#Symscmod">scmod</a>,Y
D1DB: A9 00                        lda     #0
D1DD: 6A                           ror     A                 ;set kbd interrupts according to t-mode
D1DE: 8D FA 05                     sta     <a href="#SymSCRNHOLE3">SCRNHOLE3</a>+2
D1E1: 10 07                        bpl     <a href="#Symcmdt3">cmdt3</a>             ;branch if leaving terminal mode
D1E3: 9C 7C 05                     stz     <a href="#SymSCRNHOLE2">SCRNHOLE2</a>+4       ; and ser buf...
D1E6: 9C 7C 06                     stz     <a href="#SymSCRNHOLE4">SCRNHOLE4</a>+4
D1E9: 8A                           txa                       ;use x to enable serial buffering
D1EA: 8D FC 04     <span id="Symcmdt3">cmdt3</span>           sta     <a href="#SymSCRNHOLE1">SCRNHOLE1</a>+4
D1ED: 28                           plp                       ;restore carry, enable interrupts.
D1EE: 8E FC 05     <span id="Symflush">flush</span>           stx     <a href="#SymSCRNHOLE3">SCRNHOLE3</a>+4       ;Flush the type ahead buffer
D1F1: 8E FF 06                     stx     <a href="#SymSCRNHOLE5">SCRNHOLE5</a>+7
D1F4: 60           <span id="Symstrts">strts</span>           rts

                   ;                       ;command routines'  lo bytes
D1F5: 38           <span id="Symcmdtable">cmdtable</span>        DFB     &lt;<a href="#Symcmdi">cmdi</a>-1
D1F6: 38                           DFB     &lt;<a href="#Symcmdk">cmdk</a>-1
D1F7: 38                           DFB     &lt;<a href="#Symcmdl">cmdl</a>-1
D1F8: 2E                           DFB     &lt;<a href="#Symcmdn">cmdn</a>-1
D1F9: 2E                           DFB     &lt;<a href="#Symcmdcr">cmdcr</a>-1
D1FA: 4F                           DFB     &lt;<a href="#Symcmdb">cmdb</a>-1
D1FB: 4B                           DFB     &lt;<a href="#Symcmdd">cmdd</a>-1
D1FC: 4A                           DFB     &lt;<a href="#Symcmdp">cmdp</a>-1
D1FD: 96                           DFB     &lt;<a href="#Symcmdq">cmdq</a>-1
D1FE: 87                           DFB     &lt;<a href="#Symcmdr">cmdr</a>-1
D1FF: 6B                           DFB     &lt;<a href="#Symcmds">cmds</a>-1
D200: 98                           DFB     &lt;<a href="#Symcmdt">cmdt</a>-1
D201: 25                           DFB     &lt;<a href="#Symcmdz">cmdz</a>-1
                   ; masks for:              I   K   L   N   CR  XE  XD  FE  FD  ME  MD
D202: 7F BF BF 7F+ <span id="Symmask1">mask1</span>           HEX     $7F,$BF,$BF,$7F,$FF,$DF,$DF,$EF
                                    +      $EF,$F7,$F7
D20D: 80 00 40 00+ <span id="Symmask2">mask2</span>           HEX     $80,$00,$40,$00,$00,$20,$00,$00
                                    +      $10,$00,$08
D218: 49 4B 4C 4E  <span id="Symcmdlist">cmdlist</span>         ASC     IKLN
D21C: 0D                           DFB     $0D               ;cr (part of cmdlist)
D21D: 42 44 50 51+                 ASC     BDPQRSTZ
D225: 4C 58 46 4D+ <span id="Symcmd2list">cmd2list</span>        ASC     LXFMC           ;2-chr commands' first char

                   ********************************************************************************
                   * R_GETALT is the same as GETALT in main rom.  Only the                        *
                   * location is different.                                                       *
                   ********************************************************************************
D22A: AD 13 C0     <span id="Symr_getalt">r_getalt</span>        lda     <a href="#SymRDRAMRD">RDRAMRD</a>           ;save state of aux memory
D22D: 0A                           asl     A
D22E: AD 18 C0                     lda     <a href="#SymRD80COL">RD80COL</a>           ;and the 80STORE switch
D231: 08                           php
D232: 8D 00 C0                     sta     <a href="#SymCLR80COL">CLR80COL</a>          ;no 80STORE to get page 1
D235: 8D 03 C0                     sta     <a href="#SymRDCARDRAM">RDCARDRAM</a>         ;pop in the other half of RAM
D238: B9 78 04                     lda     $0478,Y           ;read the desired byte
D23B: 28                           plp                       ;and restore memory
D23C: B0 03                        bcs     <a href="#Symr_getalt1">r_getalt1</a>
D23E: 8D 02 C0                     sta     <a href="#SymRDMAINRAM">RDMAINRAM</a>
D241: 10 03        <span id="Symr_getalt1">r_getalt1</span>       bpl     <a href="#Symr_getalt2">r_getalt2</a>
D243: 8D 01 C0                     sta     <a href="#SymSET80COL">SET80COL</a>
D246: 60           <span id="Symr_getalt2">r_getalt2</span>       rts

D247: 03                           DFB     $03
D248: 07                           DFB     $07
D249: 00 00 00 00+                 DS      439,$00

                   ********************************************************************************
                   * BASICIN - input from basic                                                   *
                   *                                                                              *
                   * creates +XXXXX,+YYYYY,+SS                                                    *
                   * XXXXX = x position, YYYYY = y position, SS = status                          *
                   *       - = key pressed                                                        *
                   *       1 = button pressed                                                     *
                   *       2 = button just pressed                                                *
                   *       3 = button just released                                               *
                   *       4 = button not pressed                                                 *
                   ********************************************************************************
D400: 91 28        <span id="Symbasicin">basicin</span>         sta     (<a href="#Symbasl">basl</a>),Y          ;fix flashing char
                   NOTE: not sure where this was defined!
D402: A9 05                        lda     #<a href="#Syminent">inent</a>            ;fix input entry
D404: 85 38                        sta     <a href="#Symkswl">kswl</a>
D406: AD 00 C0                     lda     <a href="#SymKBD">KBD</a>               ;test the keyboard
D409: 0A                           asl     A
D40A: 08                           php                       ;save kbd and int stat for later
D40B: 78                           sei                       ;no interrupts while getting position
D40C: 20 79 D6                     jsr     <a href="#Symx_mread">x_mread</a>
D40F: A0 05                        ldy     #5                ;move x position into the buffer
D411: AE 7F 05                     ldx     <a href="#Symmouxh">mouxh</a>
D414: AD 7F 04                     lda     <a href="#Symmouxl">mouxl</a>
D417: 20 41 D4                     jsr     <a href="#Symhextodec">hextodec</a>          ;convert it
D41A: A0 0C                        ldy     #12
D41C: AE FF 05                     ldx     <a href="#Symmouyh">mouyh</a>
D41F: AD FF 04                     lda     <a href="#Symmouyl">mouyl</a>
D422: 20 41 D4                     jsr     <a href="#Symhextodec">hextodec</a>
D425: AD 7F 07                     lda     <a href="#Symmoustat">moustat</a>
D428: 2A                           rol     A
D429: 2A                           rol     A
D42A: 2A                           rol     A
D42B: 29 03                        and     #3
D42D: 49 03                        eor     #3
D42F: 1A                           inc     A
D430: 28                           plp                       ;restore int &amp; kbd status
D431: A0 10                        ldy     #16
D433: 20 52 D4                     jsr     <a href="#Symhexdec2">hexdec2</a>           ;x=0 from last div10
D436: 7A                           ply
D437: A2 11                        ldx     #17               ;x = eol
D439: A9 8D                        lda     #$8D              ;cr
D43B: 9D 00 02     <span id="Symputinbuf">putinbuf</span>        sta     <a href="#Syminbuf">inbuf</a>,X
D43E: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>            ;goback

                   ********************************************************************************
                   * HEXTODEC - puts +0000, into the input buffer                                 *
                   * inputs: a = low byte of number                                               *
                   *         x = high byte of number                                              *
                   *         y = positions of one digit                                           *
                   ********************************************************************************
D441: E0 80        <span id="Symhextodec">hextodec</span>        cpx     #$80              ;is it a negative number?
D443: 90 0D                        bcc     <a href="#Symhexdec2">hexdec2</a>
D445: 49 FF                        eor     #$FF              ;form two's complement
D447: 69 00                        adc     #0                ;c = 1 from compare
D449: 48                           pha                       ;save it
D44A: 8A                           txa
D44B: 49 FF                        eor     #$FF
D44D: 69 00                        adc     #0
D44F: AA                           tax
D450: 68                           pla
D451: 38                           sec
                   NOTE: binl? I have it as $2020
D452: 8D 14 02     <span id="Symhexdec2">hexdec2</span>         sta     $0214             ;store the number to convert
                   NOTE: binh? I have it as $2021
D455: 8E 15 02                     stx     $0215
D458: A9 2B                        lda     #+              ;store the sign in the buffer
D45A: 90 02                        bcc     <a href="#Symhdpos2">hdpos2</a>
D45C: A9 2D                        lda     #-
D45E: 48           <span id="Symhdpos2">hdpos2</span>          pha                       ;save the sign
D45F: A9 2C                        lda     #,              ;store a comma after the number
D461: 99 01 02                     sta     <a href="#Syminbuf">inbuf</a>+1,Y
                   ; 
                   ; divide BINH,L by 10 and leave remainder in a
                   ;                      ;#16+1
D464: A2 11        <span id="Symhdloop">hdloop</span>          ldx     #17               ;16 bits and first time to do nothing
D466: A9 00                        lda     #0
D468: 18                           clc                       ;c=0 so first ROL leaves a=0
D469: 2A           <span id="Symdv10loop">dv10loop</span>        rol     A
D46A: C9 0A                        cmp     #10               ;a &gt;= 10?
D46C: 90 02                        bcc     <a href="#Symdv10lt">dv10lt</a>            ;branch if &lt;
D46E: E9 0A                        sbc     #10               ;c = 1 from compare and is left set
                   NOTE: binl? I have it as $2020
D470: 2E 14 02     <span id="Symdv10lt">dv10lt</span>          rol     $0214
                   NOTE: binh? I have it as $2021
D473: 2E 15 02                     rol     $0215
D476: CA                           dex
D477: D0 F0                        bne     <a href="#Symdv10loop">dv10loop</a>
D479: 09 30                        ora     #0              ;make a ascii char
D47B: 99 00 02                     sta     <a href="#Syminbuf">inbuf</a>,Y
D47E: 88                           dey
D47F: F0 08                        beq     <a href="#Symhddone">hddone</a>            ;stop on 0,6,12
D481: C0 07                        cpy     #7
D483: F0 04                        beq     <a href="#Symhddone">hddone</a>
D485: C0 0E                        cpy     #14
D487: D0 DB                        bne     <a href="#Symhdloop">hdloop</a>
D489: 68           <span id="Symhddone">hddone</span>          pla                       ;get the sign
D48A: 99 00 02                     sta     <a href="#Syminbuf">inbuf</a>,Y
D48D: 60                           rts

                   ********************************************************************************
                   * These routines test all 128K ram.  All combinations of                       *
                   * switches applicable to the //c are tested and verified.                      *
                   *                                                                              *
                   * In the event of any failure, the diagnostic is halted. A message             *
                   * is written to screen memory indicating the source of the failure.            *
                   * When RAM fails the message is composed of "RAM ZP" (indicating               *
                   * failure detected in the first page of RAM) or "RAM" (meaning the             *
                   * other 63.75K), followed by a binary representation of the failing            *
                   * bits set to "1".  For example, "RAM   0 1 1 0 0 0 0 0" indicates             *
                   * that bits 5 and 6 were detected as failing. To represent                     *
                   * auxillary memory, a "*" symbol is printed preceeding the message.            *
                   *                                                                              *
                   * When the MMU or IOU fail, the message is simply "MMU" or "IOU".              *
                   * If the IOUDIS or DHIRES switch fails, the message is "GLU."                  *
                   *                                                                              *
                   * The test will run continiuously for as long as the Open and Closed           *
                   * Apple keys remain depressed (or no keyboard is connected) and no             *
                   * failures are encountered.  The message "System OK" will appear in            *
                   * the middle of the screen when a successful cycle has been run and            *
                   * either of the Apple keys are no longer depressed.  Another cycle             *
                   * may be initiated by pressing both Apple keys again while this                *
                   * message is on the screen.  To exit diagnostics, Control-Reset                *
                   * must be pressed without the Apple keys depressed.                            *
                   ********************************************************************************
D48E: 8D 50 C0     <span id="Symdiags">diags</span>           sta     <a href="#SymTXTCLR">TXTCLR</a>            ;text mode off
D491: 8D 78 C0                     sta     <a href="#Symioudsbl">ioudsbl</a>           ;Disable IOU
D494: 8D 5F C0                     sta     <a href="#SymSETAN3">SETAN3</a>+1          ;Double hires off
                   ; 
                   ; Test Zero-page, then all of memory.  Report errors when
                   ; encountered.  Accumulator can be anything on entry.  All
                   ; registers used, but no stack.  Addresses between $C000
                   ; and $CFFFF are mapped to main $D000 bank.  Addresses
                   ; between $C000 and $CFFF are mapped to main $D000 bank.
                   ; 
D497: A0 04        <span id="SymTSTZPG">TSTZPG</span>          ldy     #4
D499: A2 00                        ldx     #0
D49B: 18           <span id="Symzp1">zp1</span>             clc                       ;fill zero page with a pattern
D49C: 79 2A C8                     adc     <a href="#Symntbl">ntbl</a>,Y
D49F: 95 00                        sta     $00,X
D4A1: E8                           inx
D4A2: D0 F7                        bne     <a href="#Symzp1">zp1</a>               ;after all bytes filled,
D4A4: 18           <span id="Symzp2">zp2</span>             clc                       ; ACC has original value again.
D4A5: 79 2A C8                     adc     <a href="#Symntbl">ntbl</a>,Y            ;so valuescan be tested
D4A8: D5 00                        cmp     $00,X
D4AA: D0 10                        bne     <a href="#SymZPERROR">ZPERROR</a>           ;branched if memory failed
D4AC: E8                           inx
D4AD: D0 F5                        bne     <a href="#Symzp2">zp2</a>               ;loop until all 256 bytes tested
D4AF: 6A                           ror     A                 ;change ACC so locations $FF will change
D4B0: 2C 19 C0                     bit     <a href="#Symrdvblbar">rdvblbar</a>          ; use RDVBL for a little randomness...
D4B3: 10 02                        bpl     <a href="#Symzp3">zp3</a>
D4B5: 49 A5                        eor     #$A5
D4B7: 88           <span id="Symzp3">zp3</span>             dey                       ;use a different pattern now
D4B8: 10 E1                        bpl     <a href="#Symzp1">zp1</a>               ;branch to retest with other value
D4BA: 30 06                        bmi     <a href="#SymTSTMEM2">TSTMEM2</a>           ;branch always

D4BC: 55 00        <span id="SymZPERROR">ZPERROR</span>         eor     $00,X             ;which bits are bad?
D4BE: 18                           clc                       ;indicate zero page failure
D4BF: 4C 73 C4                     jmp     <a href="#SymBADBITS">BADBITS</a>

D4C2: 4C C6 C3     <span id="SymTSTMEM2">TSTMEM2</span>         jmp     <a href="#SymTSTMEM">TSTMEM</a>            ;Off to the rest

D4C5: 20 9D C7     <span id="Symzznm">zznm</span>            jsr     <a href="#Symswzzqt2">swzzqt2</a>           ;Get out of the hooks
D4C8: 68                           pla                       ;get junk off of stack
D4C9: 7A                           ply
D4CA: 68                           pla
D4CB: A9 FF                        lda     #$FF
D4CD: AA                           tax
D4CE: E8           <span id="Symzzloop">zzloop</span>          inx
D4CF: 5D DA D4                     eor     <a href="#Symqtbl">qtbl</a>,X
D4D2: 9D 00 02                     sta     <a href="#Syminbuf">inbuf</a>,X
D4D5: 10 F7                        bpl     <a href="#Symzzloop">zzloop</a>
D4D7: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

D4DA: AD 3B 0A 0B+ <span id="Symqtbl">qtbl</span>            HEX     $AD,$3B,$0A,$0B,$48,$77,$3E,$05
D4E2: 00 05 08 0C+                 HEX     $00,$05,$08,$0C,$1E,$53,$65,$37
D4EA: 1C 07 0C 45+                 HEX     $1C,$07,$0C,$45,$62,$27,$00,$17
D4F2: 1C 07 07 05+                 HEX     $1C,$07,$07,$05,$4B,$6D,$24,$02
D4FA: 0E 45 61 32+                 HEX     $0E,$45,$61,$32,$18,$02,$07,$1D
D502: 53 6A 2B 0C+                 HEX     $53,$6A,$2B,$0C,$08,$16,$53,$68
D50A: 3D 06 07 1B+                 HEX     $3D,$06,$07,$1B,$01,$E3
D510: 00 00 00 00+                 DS      240,$00

                   ********************************************************************************
                   * Initmouse - reset the  mouse                                                 *
                   *  Also clears all of the mouse holes                                          *
                   * note that ious access fires pdlstrb &amp; makes mouse happy                      *
                   ********************************************************************************
D600: 9C 7F 07     <span id="Symi_nitmouse">i_nitmouse</span>      stz     <a href="#Symmoustat">moustat</a>           ;Clear status
D603: A2 80                        ldx     #$80
D605: A0 01                        ldy     #1
D607: 9E 7D 04     <span id="Symxrloop">xrloop</span>          stz     <a href="#Symminxl">minxl</a>,X           ;Minimum = $0000
D60A: 9E 7D 05                     stz     <a href="#Symminxh">minxh</a>,X
D60D: A9 FF                        lda     #$FF              ;Maximum = $03FF
D60F: 9D 7D 06                     sta     <a href="#Symmaxxl">maxxl</a>,X
D612: A9 03                        lda     #$03
D614: 9D 7D 07                     sta     <a href="#Symmaxxh">maxxh</a>,X
D617: A2 00                        ldx     #0
D619: 88                           dey
D61A: 10 EB                        bpl     <a href="#Symxrloop">xrloop</a>
D61C: 20 51 D6                     jsr     <a href="#Symx_mhome">x_mhome</a>           ;Clear the mouse holes
D61F: A9 00                        lda     #0                ;Faill into SETMOU
                   ********************************************************************************
                   * XSETMOU - Sets the mouse code to A                                           *
                   ********************************************************************************
D621: AA           <span id="Symx_setmou">x_setmou</span>        tax
D622: 20 46 C7                     jsr     <a href="#Symm__oveirq">m__oveirq</a>         ;Make sure interrupt vector is right
D625: 8A                           txa                       ;Only x preserved by moveirq
D626: 8D 78 04                     sta     <a href="#Symmoutemp">moutemp</a>
D629: 4A                           lsr     A                 ;D0 = 1 if mouse active
D62A: 0D 78 04                     ora     <a href="#Symmoutemp">moutemp</a>           ;D2 = 1 if vbl active
D62D: C9 10                        cmp     #$10              ;If &gt;=$10 then invalid mode
D62F: B0 1F                        bcs     <a href="#Symsminvalid">sminvalid</a>
D631: 29 05                        and     #5                ;Extract VBL &amp; Mouse
D633: F0 01                        beq     <a href="#Symxsoff">xsoff</a>             ;Turning it off?
D635: 58                           cli                       ;If not, ints active
D636: 69 55        <span id="Symxsoff">xsoff</span>           adc     #$55              ;Make iou byte C=0
                   ********************************************************************************
                   *                                                                              *
                   * SETIOU - Sets the IOU interrupt modes to A                                   *
                   *  Inputs: A = bits to change                                                  *
                   *  D7 = Y int on falling edge                                                  *
                   *  D6 = Y int on rising edge                                                   *
                   *  D5 = X int on falling edge                                                  *
                   *  D4 = X int on rising edge                                                   *
                   *  D3 = Enable VBL int                                                         *
                   *  D2 = Disable VBL int                                                        *
                   *  D1 = Enable mouse int                                                       *
                   *  D0 = Disable mount int                                                      *
                   *                                                                              *
                   ********************************************************************************
D638: 08           <span id="Symsetiou">setiou</span>          php
D639: 78                           sei                       ;Don't allow ints while iou enabled
D63A: 8E FF 07                     stx     <a href="#Symmoumode">moumode</a>
D63D: 8D 79 C0                     sta     <a href="#Symiouenbl">iouenbl</a>           ;Enable iou access
D640: A2 08                        ldx     #8
D642: CA           <span id="Symsiloop">siloop</span>          dex
D643: 0A                           asl     A                 ;Get a bit to check
D644: 90 03                        bcc     <a href="#Symsinoch">sinoch</a>            ;No change if C=0
D646: 9D 58 C0                     sta     <a href="#Symiou">iou</a>,X             ;Set it
D649: D0 F7        <span id="Symsinoch">sinoch</span>          bne     <a href="#Symsiloop">siloop</a>            ;Any bits left in A?
D64B: 8D 78 C0                     sta     <a href="#Symioudsbl">ioudsbl</a>           ;Turn off iou access
D64E: 28                           plp
D64F: 18                           clc
D650: 60           <span id="Symsminvalid">sminvalid</span>       rts

                   ********************************************************************************
                   * XMHOME - Clears mouse position &amp; status                                      *
                   ********************************************************************************
D651: A2 80        <span id="Symx_mhome">x_mhome</span>         ldx     #$80
D653: 80 02                        bra     <a href="#Symxmh2">xmh2</a>

D655: A2 00        <span id="Symxmhloop">xmhloop</span>         ldx     #0                ;Point mouse to upper left
D657: BD 7D 04     <span id="Symxmh2">xmh2</span>            lda     <a href="#Symminxl">minxl</a>,X
D65A: 9D 7F 04                     sta     <a href="#Symmouxl">mouxl</a>,X
D65D: BD 7D 05                     lda     <a href="#Symminxh">minxh</a>,X
D660: 9D 7F 05                     sta     <a href="#Symmouxh">mouxh</a>,X
D663: CA                           dex
D664: 10 EF                        bpl     <a href="#Symxmhloop">xmhloop</a>
D666: 80 0C                        bra     <a href="#Symxmcdone">xmcdone</a>

                   ********************************************************************************
                   * XMCLEAR - Sets the mouse to 0,0                                              *
                   ********************************************************************************
D668: 9C 7F 04     <span id="Symx_mclear">x_mclear</span>        stz     <a href="#Symmouxl">mouxl</a>
D66B: 9C 7F 05                     stz     <a href="#Symmouxh">mouxh</a>
D66E: 9C FF 04                     stz     <a href="#Symmouyl">mouyl</a>
D671: 9C FF 05                     stz     <a href="#Symmouyh">mouyh</a>
D674: 9C 7F 06     <span id="Symxmcdone">xmcdone</span>         stz     <a href="#Symmouarm">mouarm</a>
D677: 18                           clc
D678: 60                           rts

                   ********************************************************************************
                   * XMREAD - Updates the screen holes                                            *
                   ********************************************************************************
D679: A9 20        <span id="Symx_mread">x_mread</span>         lda     #<a href="#Symmovarm">movarm</a>           ;Has mouse moved?
D67B: 1C 7F 07                     trb     <a href="#Symmoustat">moustat</a>           ;Clear moved bit in stat
D67E: 2D 7F 06                     and     <a href="#Symmouarm">mouarm</a>
D681: 1C 7F 06                     trb     <a href="#Symmouarm">mouarm</a>            ;Clear arm bit
D684: 2C FF 07                     bit     <a href="#Symmoumode">moumode</a>           ;If D7 = 1 leave butttons alone
D687: 30 13                        bmi     <a href="#Symxmrd2">xmrd2</a>
D689: 2C 63 C0                     bit     <a href="#Symmoubut">moubut</a>            ;Button pressed?
D68C: 30 02                        bmi     <a href="#Symxrbut">xrbut</a>
D68E: 09 80                        ora     #$80
D690: 2C 7F 07     <span id="Symxrbut">xrbut</span>           bit     <a href="#Symmoustat">moustat</a>           ;Pressed last time?
D693: 10 02                        bpl     <a href="#Symxrbut2">xrbut2</a>
D695: 09 40                        ora     #$40
D697: 8D 7F 07     <span id="Symxrbut2">xrbut2</span>          sta     <a href="#Symmoustat">moustat</a>
D69A: 18                           clc
D69B: 60                           rts

                   ;                       ;Leave button bits alone
D69C: 0D 7F 07     <span id="Symxmrd2">xmrd2</span>           ora     <a href="#Symmoustat">moustat</a>
D69F: 29 E0                        and     #$E0              ;Button bits
D6A1: 80 F4                        bra     <a href="#Symxrbut2">xrbut2</a>

                   ********************************************************************************
                   * XMCLAMP - Store new bounds                                                   *
                   *  Inputs A = 1 for Y, 0 for X axis                                            *
                   *    minl, minh, maxl, maxh = new bounds                                       *
                   ********************************************************************************
D6A3: 6A           <span id="Symx_mclamp">x_mclamp</span>        ror     A                 ;1 -&gt; 80
D6A4: 6A                           ror     A
D6A5: 29 80                        and     #$80
D6A7: AA                           tax
D6A8: AD 78 04                     lda     <a href="#Symminl">minl</a>
D6AB: 9D 7D 04                     sta     <a href="#Symminxl">minxl</a>,X
D6AE: AD 78 05                     lda     <a href="#Symminh">minh</a>
D6B1: 9D 7D 05                     sta     <a href="#Symminxh">minxh</a>,X
D6B4: AD F8 04                     lda     <a href="#Symmaxl">maxl</a>
D6B7: 9D 7D 06                     sta     <a href="#Symmaxxl">maxxl</a>,X
D6BA: AD F8 05                     lda     <a href="#Symmaxh">maxh</a>
D6BD: 9D 7D 07                     sta     <a href="#Symmaxxh">maxxh</a>,X
D6C0: 18                           clc                       ;No error
D6C1: 60                           rts

                   ********************************************************************************
                   * XMTSTINT - Checks mouse status bits                                          *
                   * Used for user mouser interrupt                                               *
                   ********************************************************************************
D6C2: 48           <span id="Symx_mtstint">x_mtstint</span>       pha
D6C3: 18                           clc
D6C4: A9 0E                        lda     #$0E
D6C6: 2D 7F 07                     and     <a href="#Symmoustat">moustat</a>
D6C9: D0 01                        bne     <a href="#Symnostat2">nostat2</a>
D6CB: 38                           sec
D6CC: 68           <span id="Symnostat2">nostat2</span>         pla
D6CD: 60                           rts

D6CE: 00 00 00 00+                 DS      306,$00
                                   ADREND   $C3C6

                   ********************************************************************************
                   * execution routines. these routines must begin in the same page               *
                   * **************************************************************************** *
                   *                                                                              *
                   * **************************************************************************** *
                   * EXECUTE - does command in command                                            *
                   *           inputs: a = command                                                *
                   ********************************************************************************
D800: 85 42        <span id="Symexecute">execute</span>         sta     <a href="#SymA4L">A4L</a>
                   ;                       ;#4+$C0
D802: A0 C4                        ldy     #$C4
D804: 8C F8 07                     sty     <a href="#Symsl_mslot">sl_mslot</a>
                   ;                       ;#4+$10+$88
D807: A2 C8                        ldx     #$C8
D809: 8E 78 07                     stx     <a href="#Symsl_devno">sl_devno</a>          ;save command and hardware index
D80C: A9 00                        lda     #0                ;clear error flag
D80E: 8D F8 04                     sta     <a href="#Symerror">error</a>
D811: 20 D3 D9                     jsr     <a href="#Symsl_format">sl_format</a>         ;do we need to format?
D814: A4 42                        ldy     <a href="#SymA4L">A4L</a>               ;get command
D816: B9 80 C6                     lda     <a href="#Symparmtbl">parmtbl</a>,Y         ;check parameter count
D819: 30 04                        bmi     <a href="#Symexec2">exec2</a>             ;if negative, no parm check
D81B: C5 43                        cmp     <a href="#SymA4H">A4H</a>
D81D: D0 15                        bne     <a href="#Sympzcnt">pzcnt</a>
D81F: A9 D8        <span id="Symexec2">exec2</span>           lda     #&gt;<a href="#Symxstatus">xstatus</a>         ;all entry points on same page
D821: 80 01                        bra     <a href="#Symexec3">exec3</a>             ;skip around the basic patch

D823: 00                           DFB     $00               ;break handler will correct for this

D824: 48           <span id="Symexec3">exec3</span>           pha
D825: B9 9A C6                     lda     <a href="#Symcmdtbl">cmdtbl</a>,Y
D828: 48                           pha
D829: AC F8 07                     ldy     <a href="#Symsl_mslot">sl_mslot</a>
D82C: AE 78 07                     ldx     <a href="#Symsl_devno">sl_devno</a>
D82F: 60                           rts

D830: A9 01        <span id="Sympzcmd">pzcmd</span>           lda     #<a href="#Symbadcmd">badcmd</a>           ;invalid command
D832: D0 02                        bne     <a href="#Sympzcnt2">pzcnt2</a>

D834: A9 04        <span id="Sympzcnt">pzcnt</span>           lda     #<a href="#Symbadpcnt">badpcnt</a>
D836: 8D F8 04     <span id="Sympzcnt2">pzcnt2</span>          sta     <a href="#Symerror">error</a>
D839: 60           <span id="Symiorts">iorts</span>           rts

D83A: 4C 80 C5     <span id="Sympread2_z">pread2_z</span>        jmp     <a href="#Symsl_pread">sl_pread</a>          ;entry point in this page

D83D: 4C F7 C5     <span id="Sympwrite2">pwrite2</span>         jmp     <a href="#Symsl_pwrite">sl_pwrite</a>         ;entry point in this page

D840: 4C 4F D9     <span id="Symdosconv2">dosconv2</span>        jmp     <a href="#Symdosconv">dosconv</a>           ;entry point in this page

D843: 4C 30 DB     <span id="Symxdiag">xdiag</span>           jmp     <a href="#Symxdiagz">xdiagz</a>            ;entry point in this page

                   ********************************************************************************
                   * XSTATUS - ProDOS status call                                                 *
                   ********************************************************************************
D846: B9 B8 03     <span id="Symxstatus">xstatus</span>         lda     <a href="#Symnumbanks">numbanks</a>,Y        ;size = # 64K banks / 2
D849: 4A                           lsr     A
D84A: 8D F8 05                     sta     <a href="#Symyval">yval</a>
D84D: A9 00                        lda     #0
D84F: 8D 78 05                     sta     <a href="#Symxval">xval</a>
D852: 60                           rts

                   ********************************************************************************
                   * PSTAT0 - Status call for device 0                                            *
                   *          returns status block for call 0                                     *
                   *          1 0 0 0 0 0 0 0                                                     *
                   ********************************************************************************
D853: A5 47        <span id="Sympstat0">pstat0</span>          lda     <a href="#Sympstat">pstat</a>             ;must be call 0
D855: D0 17                        bne     <a href="#Symstbad">stbad</a>             ;branch if bad
D857: 8D F8 05                     sta     <a href="#Symmaxh">maxh</a>              ;set bytes read count
D85A: A0 08                        ldy     #8
D85C: 8C 78 05                     sty     <a href="#Symxval">xval</a>
D85F: 88                           dey
D860: 91 45        <span id="Symst01p">st01p</span>           sta     (<a href="#Symcompdata">compdata</a>),Y      ;save out the 0s
D862: 88                           dey
D863: D0 FB                        bne     <a href="#Symst01p">st01p</a>
D865: A9 01                        lda     #1
D867: 91 45                        sta     (<a href="#Symcompdata">compdata</a>),Y
D869: 60                           rts

                   ********************************************************************************
                   * PCNTL - control call                                                         *
                   *         call 0 (reset) is implemented for both devices                       *
                   ********************************************************************************
D86A: A5 47        <span id="Sympcntl">pcntl</span>           lda     <a href="#Sympstat">pstat</a>             ;call 0?
D86C: F0 05                        beq     <a href="#Sympcntok">pcntok</a>
D86E: A9 21        <span id="Symstbad">stbad</span>           lda     #<a href="#Symbadctl">badctl</a>           ;oops! bad status/control number
D870: 8D F8 04                     sta     <a href="#Symerror">error</a>
D873: 60           <span id="Sympcntok">pcntok</span>          rts

                   ********************************************************************************
                   * PSTATUS - status call for device 1                                           *
                   *           call 0,3 supported                                                 *
                   ********************************************************************************
D874: A9 04        <span id="Symsl_pstatus">sl_pstatus</span>      lda     #4                ;number bytes for call 0
D876: A6 47                        ldx     <a href="#Sympstat">pstat</a>
D878: F0 06                        beq     <a href="#Sympst0">pst0</a>
D87A: E0 03                        cpx     #3                ;is it #3?
D87C: D0 F0                        bne     <a href="#Symstbad">stbad</a>             ;branch if bad call
D87E: A9 19                        lda     #25               ;# bytes for call 3
D880: 8D 78 05     <span id="Sympst0">pst0</span>            sta     <a href="#Symxval">xval</a>
D883: A2 00                        ldx     #0
D885: 8E F8 05                     stx     <a href="#Symyval">yval</a>
D888: A8                           tay
D889: 88                           dey
D88A: B9 67 C6     <span id="Sympstmov">pstmov</span>          lda     <a href="#Symstattbl">stattbl</a>,Y         ;move the status info
D88D: 91 45                        sta     (<a href="#Symcompdata">compdata</a>),Y
D88F: 88                           dey
D890: 10 F8                        bpl     <a href="#Sympstmov">pstmov</a>
D892: AC F8 07                     ldy     <a href="#Symsl_mslot">sl_mslot</a>          ;get the size
D895: B9 B8 03                     lda     <a href="#Symnumbanks">numbanks</a>,Y
D898: 4A                           lsr     A
D899: A0 02                        ldy     #2
D89B: 91 45                        sta     (<a href="#Symcompdata">compdata</a>),Y
D89D: 60                           rts

                   ********************************************************************************
                   * XREAD  - read a block                                                        *
                   * XWRITE - write a block                                                       *
                   *                                                                              *
                   * ProDOS read &amp; write are changed into Protocol converter read block           *
                   * and write block which are then changed into read &amp; write                     *
                   ********************************************************************************
D89E: 2C 39 D8     <span id="Symxread">xread</span>           bit     <a href="#Symiorts">iorts</a>             ;V = 1 for read
D8A1: 50                           DFB     $50               ;VNC never taken
D8A2: B8           <span id="Symxwrite">xwrite</span>          clv                       ;V = 0 for write
                   ; 
D8A3: A5 47        <span id="Symxrwcmn">xrwcmn</span>          lda     <a href="#Symblock">block</a>+1           ;move block &amp; buffer pointer
D8A5: 85 48                        sta     <a href="#Sympblock">pblock</a>+1
D8A7: A5 46                        lda     <a href="#Symlimit">limit</a>             ;be careful not to step
D8A9: 85 47                        sta     <a href="#Symvalue">value</a>             ;on our own toes
D8AB: A5 45                        lda     <a href="#Symbuffer">buffer</a>+1
D8AD: 85 46                        sta     <a href="#Sympbuff">pbuff</a>+1
D8AF: A5 44                        lda     <a href="#Symbuffer">buffer</a>
D8B1: 85 45                        sta     <a href="#Symcompdata">compdata</a>
D8B3: A9 00                        lda     #0
D8B5: 85 49                        sta     <a href="#Sympblock">pblock</a>+2
D8B7: F0 05                        beq     <a href="#Symxread2">xread2</a>            ;skip past other sev &amp; clv

                   ********************************************************************************
                   * PRDBLK - Protocol converter block read                                       *
                   * PWRBLK - Protocol converter block write                                      *
                   ********************************************************************************
D8B9: 2C 39 D8     <span id="Symprdblk">prdblk</span>          bit     <a href="#Symiorts">iorts</a>             ;V = 1 for read
D8BC: 50                           DFB     $50               ;BVC never taken
D8BD: B8           <span id="Sympwrblk">pwrblk</span>          clv
D8BE: A5 47        <span id="Symxread2">xread2</span>          lda     <a href="#Symvalue">value</a>             ;convert block into 512 bytes
D8C0: 0A                           asl     A
D8C1: 85 4A                        sta     <a href="#Sympaddr">paddr</a>+1
D8C3: A5 48                        lda     <a href="#Sympblock">pblock</a>+1
D8C5: 2A                           rol     A
D8C6: 85 4B                        sta     <a href="#Sympaddr">paddr</a>+2
D8C8: B0 1F                        bcs     <a href="#Symprbad2">prbad2</a>            ;if C=1 then bad address
D8CA: A5 49                        lda     <a href="#Sympblock">pblock</a>+2          ;third byte must b 0
D8CC: D0 1B                        bne     <a href="#Symprbad2">prbad2</a>
D8CE: 85 49                        sta     <a href="#Sympaddr">paddr</a>             ;low byte of address is 0
D8D0: 85 47                        sta     <a href="#Sympcount">pcount</a>            ;count = $200
D8D2: A9 02                        lda     #2
D8D4: 85 48                        sta     <a href="#Sympcount">pcount</a>+1
D8D6: AD 14 C0                     lda     <a href="#SymRDRAMWRT">RDRAMWRT</a>          ;fix aux bit in address
D8D9: 70 03                        bvs     <a href="#Symprdread">prdread</a>
D8DB: AD 13 C0                     lda     <a href="#SymRDRAMRD">RDRAMRD</a>
D8DE: 29 80        <span id="Symprdread">prdread</span>         and     #$80              ;D7 = 1 if aux
D8E0: 05 4B                        ora     <a href="#Sympaddr">paddr</a>+2
D8E2: 85 4B                        sta     <a href="#Sympaddr">paddr</a>+2
D8E4: 70 06                        bvs     <a href="#Symprbad3">prbad3</a>            ;go do read
D8E6: 4C F7 C5                     jmp     <a href="#Symsl_pwrite">sl_pwrite</a>

D8E9: 4C EE C5     <span id="Symprbad2">prbad2</span>          jmp     <a href="#Symprbad">prbad</a>

D8EC: 4C 80 C5     <span id="Symprbad3">prbad3</span>          jmp     <a href="#Symsl_pread">sl_pread</a>

                   ********************************************************************************
                   * here is the rest of the boot code                                            *
                   * input: a = kswh, output: v = 1 if boot fails                                 *
                   * jumps to DOS patch if IN# from DOS                                           *
                   ********************************************************************************
D8EF: A0 C4        <span id="Symbool_sl">bool_sl</span>         ldy     #$C4              ;#4+$C0
D8F1: 8C F8 07                     sty     <a href="#Symsl_mslot">sl_mslot</a>
                   ;                       ;#4+$10+$88
D8F4: A2 C8                        ldx     #$C8
D8F6: 8E 78 07                     stx     <a href="#Symsl_devno">sl_devno</a>
D8F9: CD F8 07                     cmp     <a href="#Symsl_mslot">sl_mslot</a>          ;is it a IN#
D8FC: D0 09                        bne     <a href="#Symbtnodos">btnodos</a>
D8FE: AD 00 BF                     lda     <a href="#Symproflag">proflag</a>           ;are we in DOS?
D901: F0 04                        beq     <a href="#Symbtnodos">btnodos</a>           ;0 = Pascal
D903: C9 4C                        cmp     #$4C              ;JMP = ProDOS
D905: D0 20                        bne     <a href="#Symdospatch">dospatch</a>          ;go patch DOS
                   ; 
D907: 9C 01 08     <span id="Symbtnodos">btnodos</span>         stz     <a href="#Symbootbuf">bootbuf</a>+1         ;assume fail
                   ; lda power2,y ;if power up bytes not set, don't boot
                   ; eor #$A5
                   ; cmp powerup,y
D90A: B9 B8 06                     lda     <a href="#Sympowerup">powerup</a>,Y
D90D: C9 A5                        cmp     #$A5
D90F: D0 11                        bne     <a href="#Symbtfail">btfail</a>
D911: A0 03                        ldy     #3
D913: B9 23 D9     <span id="Symbtmv">btmv</span>            lda     <a href="#Symbtcmd">btcmd</a>,Y
D916: 99 44 00                     sta     <a href="#Symbuffer">buffer</a>,Y
D919: 88                           dey
D91A: 10 F7                        bpl     <a href="#Symbtmv">btmv</a>
D91C: AC F8 07                     ldy     <a href="#Symsl_mslot">sl_mslot</a>
D91F: 20 9E D8                     jsr     <a href="#Symxread">xread</a>             ;go read the block and return
D922: 60           <span id="Symbtfail">btfail</span>          rts

D923: 00 08        <span id="Symbtcmd">btcmd</span>           DW      $0800
D925: 00 00                        DW      $0000             ;read in block 0 @ $800

                   ********************************************************************************
                   * DOSPATCH - patches rwts to jump to us                                        *
                   ********************************************************************************
D927: A9 4C        <span id="Symdospatch">dospatch</span>        lda     #$4C              ;JMP opcode
D929: 8D 00 BD                     sta     <a href="#Symrwts">rwts</a>
                   <span style="background-color: #cbcb00">NOTE: TODO: did these symbols get resolved?</span>
D92C: A9 D1                        lda     #$D1
D92E: 8D 01 BD                     sta     <a href="#Symrwts">rwts</a>+1            ;make page 3 vector point to us
D931: 8C 02 BD                     sty     <a href="#Symrwts">rwts</a>+2            ;Y = Cn
D934: A9 C3                        lda     #$C3              ;patch out init command
D936: 8D 1E 9D                     sta     <a href="#Symdosinit">dosinit</a>
D939: A9 A6                        lda     #$A6
D93B: 8D 1F 9D                     sta     <a href="#Symdosinit">dosinit</a>+1
D93E: 68                           pla                       ;pop off return address
D93F: 68                           pla
                   ; 
D940: FA                           plx
D941: FE 00 C0                     inc     $C000,X           ;restore language card
D944: FA                           plx                       ;restore real x
D945: 68                           pla
D946: 68                           pla
D947: A2 00                        ldx     #0
D949: A9 98                        lda     #$98              ;return a control-X
D94B: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>            ;switch rom bank and return

D94E: 60           <span id="Symdcrts">dcrts</span>           rts

                   ********************************************************************************
                   * DOSCONV - changes DOS command into ours                                      *
                   * output: command table in zp Y = command                                      *
                   ********************************************************************************
D94F: A0 02        <span id="Symdosconv">dosconv</span>         ldy     #<a href="#Symibdrvn">ibdrvn</a>           ;get drive 1 or 2
D951: B1 48                        lda     (<a href="#Symiobpl">iobpl</a>),Y
D953: C9 01                        cmp     #1                ;only 1 valid
D955: F0 03                        beq     <a href="#Symdcl">dcl</a>
D957: 4C 30 D8     <span id="Symdcerr">dcerr</span>           jmp     <a href="#Sympzcmd">pzcmd</a>             ;bad drive number

D95A: A0 04        <span id="Symdcl">dcl</span>             ldy     #<a href="#Symibtrk">ibtrk</a>            ;get track &amp; sector
D95C: B1 48                        lda     (<a href="#Symiobpl">iobpl</a>),Y         ;addr = 00000TTT TTTSSSSS 00000000
D95E: 4A                           lsr     A
D95F: 66 4A                        ror     <a href="#Sympaddr">paddr</a>+1
D961: 4A                           lsr     A
D962: 66 4A                        ror     <a href="#Sympaddr">paddr</a>+1
D964: 4A                           lsr     A
D965: 85 4B                        sta     <a href="#Sympaddr">paddr</a>+2
D967: A5 4A                        lda     <a href="#Sympaddr">paddr</a>+1
D969: 6A                           ror     A
D96A: 29 E0                        and     #$E0
D96C: C8                           iny
D96D: 11 48                        ora     (<a href="#Symiobpl">iobpl</a>),Y         ;or in sector
D96F: 85 4A                        sta     <a href="#Sympaddr">paddr</a>+1
D971: A0 08                        ldy     #<a href="#Symibbufp">ibbufp</a>           ;get pointer to user's buffer
D973: B1 48                        lda     (<a href="#Symiobpl">iobpl</a>),Y
D975: 85 45                        sta     <a href="#Symcompdata">compdata</a>
D977: C8                           iny
D978: B1 48                        lda     (<a href="#Symiobpl">iobpl</a>),Y
D97A: 85 46                        sta     <a href="#Sympbuff">pbuff</a>+1
D97C: A0 0C                        ldy     #<a href="#Symibcmd">ibcmd</a>            ;get command
D97E: B1 48                        lda     (<a href="#Symiobpl">iobpl</a>),Y
D980: F0 CC                        beq     <a href="#Symdcrts">dcrts</a>             ;0 = null = do nothing
D982: 29 03                        and     #3
D984: F0 D1                        beq     <a href="#Symdcerr">dcerr</a>             ;4 = format is an error
D986: 09 11                        ora     #17               ;1 -&gt; 17, 2-&gt; 19
D988: A8                           tay                       ;Y = command
D989: A2 00                        ldx     #0
D98B: 86 47                        stx     <a href="#Sympcount">pcount</a>            ;count = $100 bytes
D98D: 86 49                        stx     <a href="#Sympaddr">paddr</a>
D98F: E8                           inx
D990: 86 48                        stx     <a href="#Sympcount">pcount</a>+1
D992: 4C 1F D8                     jmp     <a href="#Symexec2">exec2</a>

                   ********************************************************************************
                   * TESTSIZE - determines ramdisk size nondestructively                          *
                   * Inputs: Y = mslot X = devno                                                  *
                   ********************************************************************************
D995: A9 00        <span id="Symtestsize">testsize</span>        lda     #0                ;Set address reg
D997: 9D F8 BF                     sta     <a href="#Symaddrl">addrl</a>,X
D99A: 9D F9 BF                     sta     <a href="#Symaddrm">addrm</a>,X
D99D: A9 10                        lda     #$10              ;Start at 1 meg and go down
D99F: 38                           sec
D9A0: E9 01        <span id="Symtsloop">tsloop</span>          sbc     #1                ;Move down a bank
D9A2: 9D FA BF                     sta     <a href="#Symscmod">scmod</a>,X
D9A5: BD FB BF                     lda     <a href="#Symdata">data</a>,X            ;Save the data that is there
D9A8: 48                           pha
D9A9: DE F8 BF                     dec     <a href="#Symaddrl">addrl</a>,X           ;Fix address
D9AC: A9 A5                        lda     #$A5              ;Store something there
D9AE: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
D9B1: DE F8 BF                     dec     <a href="#Symaddrl">addrl</a>,X
D9B4: 5D FB BF                     eor     <a href="#Symdata">data</a>,X            ;0 if the data is there
D9B7: DE F8 BF                     dec     <a href="#Symaddrl">addrl</a>,X
D9BA: C9 01                        cmp     #1                ;C = 0 if data ok
D9BC: 68                           pla
D9BD: 9D FB BF                     sta     <a href="#Symdata">data</a>,X            ;Restore what was there
D9C0: BD FA BF                     lda     <a href="#Symscmod">scmod</a>,X
D9C3: 29 0F                        and     #$0F              ;Only lower 4 bits valid
D9C5: F0 04                        beq     <a href="#Symtsnoram">tsnoram</a>           ;No ram somehow!!!
D9C7: B0 D7                        bcs     <a href="#Symtsloop">tsloop</a>            ;Loop until we find a bank
D9C9: 69 01                        adc     #1                ;C = 0 from compare
D9CB: 99 B8 03     <span id="Symtsnoram">tsnoram</span>         sta     <a href="#Symnumbanks">numbanks</a>,Y
D9CE: 4A                           lsr     A                 ;Sizetemp = &lt; block count
D9CF: 8D 78 04                     sta     <a href="#Symsizetemp">sizetemp</a>
D9D2: 60                           rts

                   ********************************************************************************
                   * Routines for making a directory on the disk                                  *
                   * *******************************************                                  *
                   *                                                                              *
                   * Format - Tests for powerup and puts catalog on the disk if needed            *
                   * Inputs: Y = mslot X = devno                                                  *
                   ********************************************************************************
D9D3: AC F8 07     <span id="Symsl_format">sl_format</span>       ldy     <a href="#Symsl_mslot">sl_mslot</a>
                   ; lda power2,y ; Is power2 eor powerup = A5
                   ; ero #$A5
                   ; cmp powerup, y
                   ; beq fmtdone
                   ; sta powerup, y
D9D6: A9 A5                        lda     #$A5              ;get power up value
D9D8: D9 B8 06                     cmp     <a href="#Sympowerup">powerup</a>,Y         ;is it = to the slinky power up byte?
D9DB: F0 2B                        beq     <a href="#Symfmtdone">fmtdone</a>           ;skip if yes
D9DD: 99 B8 06                     sta     <a href="#Sympowerup">powerup</a>,Y         ;it's not, but it's set now
                   ; 
                   ; If all screen holes spaces, someone might have cleared
                   ; the screen wrong so we won't reformat
D9E0: C9 05                        cmp     #$05              ;;Space eor $A5?
                   ;                       ;Z = 1 if all spaces
D9E2: 08           <span id="Symfmnosp">fmnosp</span>          php
D9E3: 20 95 D9                     jsr     <a href="#Symtestsize">testsize</a>
D9E6: 28                           plp
D9E7: F0 1F                        beq     <a href="#Symfmtdone">fmtdone</a>
D9E9: AD 00 BF                     lda     <a href="#Symproflag">proflag</a>           ;What type of catalog?
D9EC: F0 1B                        beq     <a href="#Symfmpas">fmpas</a>
D9EE: C9 4C                        cmp     #$4C              ;JMP if ProDOS
D9F0: D0 1D                        bne     <a href="#Symfmdos">fmdos</a>
                   NOTE: Why isn't procat $FF?
D9F2: A0 FF                        ldy     #&lt;<a href="#Symcattbl">cattbl</a>+88       ;Do a ProDOS catalog
D9F4: 20 39 DA                     jsr     <a href="#Symmakecat">makecat</a>           ;Put in all but bit map
D9F7: A9 01                        lda     #$01              ;Blocks 0-6 busy
D9F9: A0 20        <span id="Symfmpmap1">fmpmap1</span>         ldy     #32               ;32 FFs for each $100 blocks
D9FB: 9D FB BF     <span id="Symfmpmap2">fmpmap2</span>         sta     <a href="#Symdata">data</a>,X
D9FE: 09 FF                        ora     #$FF              ;Rest are FFs
DA00: 88                           dey
DA01: D0 F8                        bne     <a href="#Symfmpmap2">fmpmap2</a>
DA03: CE 78 04                     dec     <a href="#Symsizetemp">sizetemp</a>
DA06: D0 F1                        bne     <a href="#Symfmpmap1">fmpmap1</a>
DA08: 60           <span id="Symfmtdone">fmtdone</span>         rts

                   NOTE: why is pascat wrong?
                   ; Do a pascal catalog
DA09: A0 78        <span id="Symfmpas">fmpas</span>           ldy     #<a href="#Sympascat">pascat</a>
DA0B: 20 39 DA                     jsr     <a href="#Symmakecat">makecat</a>
DA0E: 60                           rts

                   ; Do a DOS catalog
DA0F: A0 2C        <span id="Symfmdos">fmdos</span>           ldy     #<a href="#Symdoscat">doscat</a>
DA11: 20 39 DA                     jsr     <a href="#Symmakecat">makecat</a>
DA14: A9 44                        lda     #$44              ;Point to track 3 bitmap
DA16: 9D F8 BF                     sta     <a href="#Symaddrl">addrl</a>,X           ;Addrl = 0 from makecat
DA19: AD 78 04                     lda     <a href="#Symsizetemp">sizetemp</a>          ;Check if at least 512K
DA1C: A0 72                        ldy     #114              ;Assume 256K
DA1E: C9 04                        cmp     #4                ;At leaste $400 blocks
DA20: 90 02                        bcc     <a href="#Symfmddmap">fmddmap</a>
DA22: A0 BA                        ldy     #186              ;Make 400K volume
DA24: BD F8 BF     <span id="Symfmddmap">fmddmap</span>         lda     <a href="#Symaddrl">addrl</a>,X           ;Don't free catalog
DA27: C9 7C                        cmp     #$7C              ;Track $11?
DA29: D0 05                        bne     <a href="#Symfmdok">fmdok</a>
DA2B: A9 7E                        lda     #$7E              ;Skip first 16 sectors
DA2D: 9D F8 BF                     sta     <a href="#Symaddrl">addrl</a>,X           ;7C -&gt; 7E so no false carry
DA30: A9 FF        <span id="Symfmdok">fmdok</span>           lda     #$FF
DA32: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
DA35: 88                           dey
DA36: D0 EC                        bne     <a href="#Symfmddmap">fmddmap</a>
DA38: 60                           rts

                   ********************************************************************************
                   * MAKECAT - Creates a catalog                                                  *
                   *  Inputs: X = index into catalog tables                                       *
                   *                                                                              *
                   ********************************************************************************
DA39: A9 00        <span id="Symmakecat">makecat</span>         lda     #0                ;First bank is 0
DA3B: 9D F8 BF                     sta     <a href="#Symaddrl">addrl</a>,X           ;Start at 0
DA3E: 9D F9 BF                     sta     <a href="#Symaddrm">addrm</a>,X
DA41: 9D FA BF                     sta     <a href="#Symscmod">scmod</a>,X
DA44: 9D FB BF     <span id="Symmcboot">mcboot</span>          sta     <a href="#Symdata">data</a>,X            ;Zero out first 8 blocks
DA47: BD F9 BF                     lda     <a href="#Symaddrm">addrm</a>,X           ;Loop until $400
DA4A: 29 F0                        and     #$F0              ;A = 0 if &lt; $1000
DA4C: F0 F6                        beq     <a href="#Symmcboot">mcboot</a>            ;Leaves us pointing at $1000 (block 8)
DA4E: A9 04                        lda     #4                ;Point to $400 (block 2)
DA50: 9D F9 BF                     sta     <a href="#Symaddrm">addrm</a>,X
DA53: C8           <span id="Symmcbyte">mcbyte</span>          iny
DA54: B9 A7 DA                     lda     <a href="#Symcattbl">cattbl</a>,Y          ;Get next byte from the table
DA57: C9 FD                        cmp     #<a href="#Symzers">zers</a>             ;Zeros flag?
DA59: F0 1C                        beq     <a href="#Symmc0">mc0</a>
DA5B: C9 FE                        cmp     #<a href="#Symskpfe">skpfe</a>            ;$FE zeros?
DA5D: F0 1E                        beq     <a href="#Symmcfe">mcfe</a>
DA5F: C9 FC                        cmp     #<a href="#Symsizeflg">sizeflg</a>          ;Block size?
DA61: D0 05                        bne     <a href="#Symmcntsz">mcntsz</a>
DA63: AD 78 04                     lda     <a href="#Symsizetemp">sizetemp</a>          ;Get &lt;# blocks
DA66: D0 09                        bne     <a href="#Symmcntnm">mcntnm</a>            ;better not be 0
DA68: C9 AA        <span id="Symmcntsz">mcntsz</span>          cmp     #<a href="#Symnameflag">nameflag</a>         ;Slot # for name?
DA6A: D0 05                        bne     <a href="#Symmcntnm">mcntnm</a>
DA6C: AD F8 07                     lda     <a href="#Symsl_mslot">sl_mslot</a>          ;Get $Cn
DA6F: 49 F0                        eor     #$F0              ;$Cn -&gt; $3n
DA71: 9D FB BF     <span id="Symmcntnm">mcntnm</span>          sta     <a href="#Symdata">data</a>,X            ;Stick byte in catalog
DA74: 4C 53 DA                     jmp     <a href="#Symmcbyte">mcbyte</a>            ;Go to next byte

DA77: C8           <span id="Symmc0">mc0</span>             iny
DA78: B9 A7 DA                     lda     <a href="#Symcattbl">cattbl</a>,Y          ;Get # zeros
DA7B: F0 11                        beq     <a href="#Symmcadd">mcadd</a>             ;If 0, it's an address
DA7D: 48           <span id="Symmcfe">mcfe</span>            pha                       ;Save count
DA7E: A9 00                        lda     #0
DA80: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
DA83: 68                           pla
DA84: 38                           sec
DA85: E9 01                        sbc     #1
DA87: D0 F4                        bne     <a href="#Symmcfe">mcfe</a>
DA89: F0 C8                        beq     <a href="#Symmcbyte">mcbyte</a>            ;Always taken

DA8B: 9D FB BF     <span id="Symmcadd2">mcadd2</span>          sta     <a href="#Symdata">data</a>,X            ;Store a 0
DA8E: DD F8 BF     <span id="Symmcadd">mcadd</span>           cmp     <a href="#Symaddrl">addrl</a>,X           ;Finish off current page
DA91: D0 F8                        bne     <a href="#Symmcadd2">mcadd2</a>
DA93: C8                           iny
DA94: B9 A7 DA                     lda     <a href="#Symcattbl">cattbl</a>,Y          ;Get new address
DA97: F0 0D                        beq     <a href="#Symmcdone">mcdone</a>            ;If 0, all done
DA99: 9D F9 BF                     sta     <a href="#Symaddrm">addrm</a>,X
DA9C: C8                           iny
DA9D: B9 A7 DA                     lda     <a href="#Symcattbl">cattbl</a>,Y
DAA0: 9D FA BF                     sta     <a href="#Symscmod">scmod</a>,X
DAA3: 4C 53 DA                     jmp     <a href="#Symmcbyte">mcbyte</a>

DAA6: 60           <span id="Symmcdone">mcdone</span>          rts

                   NOTE: Original listing formats this table slightly different. But cases it is
                   "zeros, &lt;value&gt;" or "skpfe,&lt;value&gt;,&lt;value&gt;"
                   ********************************************************************************
                   * The catalog tables                                                           *
                   * These tables contain the catalog info compacted                              *
                   * in a scheme so clever it probably doesn't save                               *
                   * me anything                                                                  *
                   * For each bank:                                                               *
                   *  The first byte is the bank #. 0 = done                                      *
                   *  zers,n = skip n 0s                                                          *
                   *  zers,0 = fill rest of page with 0s and get new address                      *
                   *  zers,0,0 = All done                                                         *
                   *  skpfe = fill $FE 0s                                                         *
                   *  nameflg = replace with ascii slot #                                         *
                   *  sizeflg = replace with &lt; block size                                         *
                   ********************************************************************************
DAA7: 00 00        <span id="Symcattbl">cattbl</span>          DW      0                 ;Previous pointer
DAA9: 03 00                        DW      3                 ;Next block
DAAB: F4                           DFB     $F4               ;Storage type
                   ; daac, daad, daaf, form asc 'RAM'
DAAC: 52 41 4D                     ASC     RAM
DAAF: AA                           DFB     <a href="#Symnameflag">nameflag</a>
DAB0: FD                           DFB     <a href="#Symzers">zers</a>
DAB1: 19                           DFB     $19
DAB2: C3 27 0D                     HEX     $C3,$27,$0D
DAB5: 00 00                        DW      0
DAB7: 06 00                        DW      6                 ;Bitmap pointer
DAB9: 00                           DFB     0                 ;Number of blocks
DABA: FC                           DFB     <a href="#Symsizeflg">sizeflg</a>
DABB: FD                           DFB     <a href="#Symzers">zers</a>
DABC: D7                           DFB     $D7
DABD: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DABE: 02 00                        DW      2                 ;Block 3 $600
DAC0: 04 00                        DW      4
DAC2: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAC3: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAC4: 03 00                        DW      3                 ;Block 4 $800
DAC6: 05 00                        DW      5
DAC8: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAC9: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DACA: 04 00                        DW      4                 ;Block 5 $A00
DACC: 00                           DFB     $00               ;Get into second page
DACD: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DACE: FD                           DFB     <a href="#Symzers">zers</a>              ;All done left at block 6
DACF: 00 00 00 00+                 HEX     $00,$00,$00,$00,$00
                   ; 
DAD4: FD                           DFB     <a href="#Symzers">zers</a>              ;Trk $11 Sec 0 = $022000
DAD5: 00 20 02                     HEX     $00,$20,$02
DAD8: 02                           DFB     2                 ;Sec 0 = VTOC
DAD9: 11 0F                        HEX     $11,$0F           ;Pointer to catalog
DADB: 04                           DFB     $04               ;Dos release
DADC: 00 00                        HEX     $00,$00           ;Unused
DADE: FB                           DFB     $FB               ;Volume number
DADF: FD                           DFB     <a href="#Symzers">zers</a>
DAE0: 20                           DFB     $20
DAE1: 7A                           DFB     $7A               ;TS pairs in TS list
DAE2: FD                           DFB     <a href="#Symzers">zers</a>
DAE3: 08                           DFB     8
DAE4: FF FF FF FF                  HEX     $FF,$FF,$FF,$FF   ;Allocation mask
DAE8: 32                           DFB     $32               ;# Tracks
DAE9: 20                           DFB     $20               ;# Sectors
DAEA: 00 01                        DW      $0100             ;# Bytes per sector
DAEC: FD                           DFB     <a href="#Symzers">zers</a>
DAED: CB                           DFB     $CB
                   NOTE: Section down to $DB20 is formatted as:
                   &lt;byte&gt;,&lt;byte&gt;,skpfe
DAEE: FE                           DFB     <a href="#Symskpfe">skpfe</a>             ;Next cat sector pointer
DAEF: 11                           DFB     $11
DAF0: 01                           DFB     $01
DAF1: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAF2: 11                           DFB     $11
DAF3: 02                           DFB     $02
DAF4: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAF5: 11                           DFB     $11
DAF6: 03                           DFB     $03
DAF7: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAF8: 11                           DFB     $11
DAF9: 04                           DFB     $04
DAFA: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAFB: 11                           DFB     $11
DAFC: 05                           DFB     $05
DAFD: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DAFE: 11                           DFB     $11
DAFF: 06                           DFB     $06
DB00: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB01: 11                           DFB     $11
DB02: 07                           DFB     $07
DB03: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB04: 11                           DFB     $11
DB05: 08                           DFB     $08
DB06: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB07: 11                           DFB     $11
DB08: 09                           DFB     $09
DB09: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB0A: 11                           DFB     $11
DB0B: 0A                           DFB     $0A
DB0C: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB0D: 11                           DFB     $11
DB0E: 0B                           DFB     $0B
DB0F: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB10: 11                           DFB     $11
DB11: 0C                           DFB     $0C
DB12: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB13: 11                           DFB     $11
DB14: 0D                           DFB     $0D
DB15: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB16: 11                           DFB     $11
DB17: 0E                           DFB     $0E
DB18: FE                           DFB     <a href="#Symskpfe">skpfe</a>
DB19: FD                           DFB     <a href="#Symzers">zers</a>              ;Leave pointing at VTOC
DB1A: 00 20 02                     HEX     $00,$20,$02
DB1D: FD                           DFB     <a href="#Symzers">zers</a>              ;All done
DB1E: 00 00                        HEX     $00,$00
                   ; 
DB20: 00 00                        HEX     $00,$00
DB22: 06                           DFB     $06
DB23: FD                           DFB     <a href="#Symzers">zers</a>
DB24: 03                           DFB     $03
DB25: 04                           DFB     $04
DB26: 52 41 4D                     ASC     RAM
DB29: AA                           DFB     <a href="#Symnameflag">nameflag</a>
DB2A: FD                           DFB     <a href="#Symzers">zers</a>
DB2B: 04                           DFB     $04
DB2C: FC                           DFB     <a href="#Symsizeflg">sizeflg</a>
DB2D: FD                           DFB     <a href="#Symzers">zers</a>
DB2E: 00 00                        HEX     $00,$00

                   ********************************************************************************
                   * XDIAGZ - Moves the slinky diagnostic code from $DC00 - $DFFF to              *
                   * main ram starting at $2000 and jumps to $2000                                *
                   ********************************************************************************
DB30: A2 00        <span id="Symxdiagz">xdiagz</span>          ldx     #0
DB32: BD 00 DC     <span id="Symxdloop">xdloop</span>          lda     <a href="#Symdiagcode">diagcode</a>,X        ;move the code
DB35: 9D 00 20                     sta     <a href="#SymStartTest">StartTest</a>,X
DB38: BD 00 DD                     lda     <a href="#Symdiagcode">diagcode</a>+$100,X
DB3B: 9D 00 21                     sta     <a href="#Symdiagdest">diagdest</a>+$100,X
DB3E: BD 00 DE                     lda     <a href="#Symdiagcode">diagcode</a>+$200,X
DB41: 9D 00 22                     sta     <a href="#Symdiagdest">diagdest</a>+$200,X
DB44: BD 00 DF                     lda     <a href="#Symdiagcode">diagcode</a>+$300,X
DB47: 9D 00 23                     sta     <a href="#Symdiagdest">diagdest</a>+$300,X
DB4A: E8                           inx
DB4B: D0 E5                        bne     <a href="#Symxdloop">xdloop</a>
DB4D: AE 78 07                     ldx     <a href="#Symsl_devno">sl_devno</a>          ;get device number
DB50: A9 1F                        lda     #&gt;<a href="#Symdiagstart">diagstart</a>       ;put start address on stack
DB52: 48                           pha
DB53: A9 FF                        lda     #&lt;<a href="#Symdiagstart">diagstart</a>
DB55: 48                           pha
                   ********************************************************************************
                   * switch the main rom back in and go to the diagnostics via return             *
                   ********************************************************************************
DB56: 4C 84 C7                     jmp     <a href="#Symswrts2">swrts2</a>

DB59: 00 00 00 00+                 DS      167,$00

                   NOTE: $DC00: Appears to have code from $2000 or StartTest in the listing
                   S.DIAG1.SRC slinky diangnostics
                   OBJECT FILE NAME IS ASM.S.0
                   ----
                   pdf page 530/2 (lol wut) has equates for diagnostics.
                                   ORG     $2000
                    Empty variable table

2000: A9 00        <span id="SymStartTest">StartTest</span>       lda     #$00
2002: 85 49                        sta     <a href="#Symloopcount">loopcount</a>
2004: 85 4A                        sta     <a href="#Symloopcount">loopcount</a>+1
2006: 99 38 04                     sta     <a href="#Sympowerup">powerup</a>-$280,Y
2009: 99 B8 04                     sta     <a href="#Sympower2">power2</a>,Y
200C: B9 B8 03                     lda     <a href="#Symnumbanks">numbanks</a>,Y
200F: 29 0F                        and     #$0F
2011: 85 46                        sta     <a href="#Symlimit">limit</a>
2013: 20 58 FC                     jsr     <a href="#Symhome">home</a>
2016: A9 08                        lda     #8
                   ; 
                   ; "MEMORY CARD TEST&lt;CR&gt;ESC TO EXIT&lt;CR&gt;TEST WILL TAKE 
                   ; 
2018: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
201B: A5 46                        lda     <a href="#Symlimit">limit</a>
201D: 4A                           lsr     A
201E: 4A                           lsr     A
201F: 48                           pha
2020: 09 04                        ora     #4
2022: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
2025: A9 09                        lda     #9
2027: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
202A: 68                           pla
202B: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
202E: 20 8E FD                     jsr     <a href="#Symcrout">crout</a>
                   ; 
                   ; read &amp; write to address register
2031: A9 05        <span id="SymAddressTest">AddressTest</span>     lda     #5
2033: 85 25                        sta     <a href="#Symcv">cv</a>
2035: 20 8E FD                     jsr     <a href="#Symcrout">crout</a>
2038: A9 10                        lda     #$10
203A: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
203D: A5 4A                        lda     <a href="#Symloopcount">loopcount</a>+1
203F: 20 DA FD                     jsr     <a href="#Symprbyte">prbyte</a>
2042: A5 49                        lda     <a href="#Symloopcount">loopcount</a>
2044: 20 DA FD                     jsr     <a href="#Symprbyte">prbyte</a>
2047: 20 0B 22                     jsr     <a href="#SymNxtLine">NxtLine</a>
204A: A9 01                        lda     #1
204C: 85 00                        sta     <a href="#Symtestnum">testnum</a>
204E: A0 05                        ldy     #5
2050: B9 F4 22     <span id="Symat1">at1</span>             lda     <a href="#SymPatterns">Patterns</a>,Y
2053: 20 13 22                     jsr     <a href="#Symsetaddr">setaddr</a>
2056: DD F8 BF                     cmp     <a href="#Symaddrl">addrl</a>,X
2059: D0 11                        bne     <a href="#Symatf">atf</a>
205B: DD F9 BF                     cmp     <a href="#Symaddrm">addrm</a>,X
205E: D0 0C                        bne     <a href="#Symatf">atf</a>
2060: 09 F0                        ora     #$F0
2062: DD FA BF                     cmp     <a href="#Symaddrh">addrh</a>,X
2065: D0 05                        bne     <a href="#Symatf">atf</a>
2067: 88                           dey
2068: 10 E6                        bpl     <a href="#Symat1">at1</a>
206A: 30 03                        bmi     <a href="#SymRollOverTest">RollOverTest</a>

206C: 4C 97 21     <span id="Symatf">atf</span>             jmp     <a href="#SymFail">Fail</a>

206F: E6 00        <span id="SymRollOverTest">RollOverTest</span>    inc     <a href="#Symtestnum">testnum</a>
2071: DE F8 BF                     dec     <a href="#Symaddrl">addrl</a>,X
2074: BD FB BF                     lda     <a href="#Symdata">data</a>,X
2077: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
207A: BD FA BF                     lda     <a href="#Symaddrh">addrh</a>,X
207D: 29 0F                        and     #$0F
207F: 1D F9 BF                     ora     <a href="#Symaddrm">addrm</a>,X
2082: 1D F8 BF                     ora     <a href="#Symaddrl">addrl</a>,X
2085: F0 03                        beq     <a href="#SymAddBusTest">AddBusTest</a>
2087: 4C 97 21                     jmp     <a href="#SymFail">Fail</a>

                   ; *****************************************
                   ; *
                   ; * Walk a 1 through the address registers to test for bus shorts
                   ; * assumes addresses = 0 from previous test
                   ; *
                   ; *****************************************
                   ; 
                   ; check for address buss shorts
208A: E6 00        <span id="SymAddBusTest">AddBusTest</span>      inc     <a href="#Symtestnum">testnum</a>
208C: A9 01                        lda     #$01
208E: 85 45                        sta     <a href="#Symcompdata">compdata</a>
2090: 8A                           txa
2091: 18                           clc
2092: 69 F8                        adc     #&lt;<a href="#Symaddrl">addrl</a>
2094: 85 42                        sta     <a href="#Symmptr">mptr</a>
2096: A9 C0                        lda     #$C0
2098: 85 43                        sta     <a href="#Symmptr">mptr</a>+1
209A: A5 46                        lda     <a href="#Symlimit">limit</a>
209C: F0 04                        beq     <a href="#Symab1">ab1</a>
209E: C9 0C                        cmp     #$0C
20A0: D0 02                        bne     <a href="#Symab2">ab2</a>
20A2: A9 10        <span id="Symab1">ab1</span>             lda     #$10
20A4: 4A           <span id="Symab2">ab2</span>             lsr     A
20A5: 48                           pha
20A6: A0 02                        ldy     #2
20A8: 48           <span id="Symab3">ab3</span>             pha
20A9: 20 11 22                     jsr     <a href="#Symclraddr">clraddr</a>
20AC: 68                           pla
20AD: 91 42                        sta     (<a href="#Symmptr">mptr</a>),Y
20AF: 48                           pha
20B0: A5 45                        lda     <a href="#Symcompdata">compdata</a>
20B2: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
20B5: E6 45                        inc     <a href="#Symcompdata">compdata</a>
20B7: 68                           pla
20B8: 4A                           lsr     A
20B9: D0 ED                        bne     <a href="#Symab3">ab3</a>
20BB: 91 42                        sta     (<a href="#Symmptr">mptr</a>),Y
20BD: 6A                           ror     A
20BE: 88                           dey
20BF: 10 E7                        bpl     <a href="#Symab3">ab3</a>
20C1: A9 01                        lda     #1
20C3: 85 45                        sta     <a href="#Symcompdata">compdata</a>
20C5: 68                           pla
20C6: A0 02                        ldy     #2
20C8: 48           <span id="Symab4">ab4</span>             pha
20C9: 20 11 22                     jsr     <a href="#Symclraddr">clraddr</a>
20CC: 68                           pla
20CD: 91 42                        sta     (<a href="#Symmptr">mptr</a>),Y
20CF: 85 47                        sta     <a href="#Symvalue">value</a>
20D1: BD FB BF                     lda     <a href="#Symdata">data</a>,X
20D4: C5 45                        cmp     <a href="#Symcompdata">compdata</a>
20D6: D0 0F                        bne     <a href="#SymabFail">abFail</a>
20D8: E6 45                        inc     <a href="#Symcompdata">compdata</a>
20DA: A5 47                        lda     <a href="#Symvalue">value</a>
20DC: 4A                           lsr     A
20DD: D0 E9                        bne     <a href="#Symab4">ab4</a>
20DF: 91 42                        sta     (<a href="#Symmptr">mptr</a>),Y
20E1: 6A                           ror     A
20E2: 88                           dey
20E3: 10 E3                        bpl     <a href="#Symab4">ab4</a>
20E5: 30 03                        bmi     <a href="#SymClearTest">ClearTest</a>

20E7: 4C 97 21     <span id="SymabFail">abFail</span>          jmp     <a href="#SymFail">Fail</a>

                   <span style="background-color: #89acb7">NOTE: pickup here</span>
                   <span style="background-color: #89acb7">pick-up</span>
                   <span style="background-color: #89acb7">pdf page 533, page 8</span>
                   ********************************************************************************
                   *                                                                              *
                   ********************************************************************************
20EA: 20 11 22     <span id="SymClearTest">ClearTest</span>       jsr     <a href="#Symclraddr">clraddr</a>
20ED: E6 00        <span id="SymFillTest">FillTest</span>        inc     <a href="#Symtestnum">testnum</a>
20EF: 85 45                        sta     <a href="#Symcompdata">compdata</a>
20F1: A5 45        <span id="Symf1">f1</span>              lda     <a href="#Symcompdata">compdata</a>
20F3: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
20F6: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
20F9: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
20FC: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
20FF: BD F8 BF                     lda     <a href="#Symaddrl">addrl</a>,X
2102: D0 ED                        bne     <a href="#Symf1">f1</a>
2104: 1D F9 BF                     ora     <a href="#Symaddrm">addrm</a>,X
2107: D0 E8                        bne     <a href="#Symf1">f1</a>
2109: 20 E4 21                     jsr     <a href="#SymPrDot">PrDot</a>
210C: D0 E3                        bne     <a href="#Symf1">f1</a>
210E: 20 0B 22                     jsr     <a href="#SymNxtLine">NxtLine</a>
2111: BD FB BF     <span id="Symcp1">cp1</span>             lda     <a href="#Symdata">data</a>,X
2114: C5 45                        cmp     <a href="#Symcompdata">compdata</a>
2116: D0 CF                        bne     <a href="#SymabFail">abFail</a>
2118: BD FB BF                     lda     <a href="#Symdata">data</a>,X
211B: C5 45                        cmp     <a href="#Symcompdata">compdata</a>
211D: D0 C8                        bne     <a href="#SymabFail">abFail</a>
211F: BD F8 BF                     lda     <a href="#Symaddrl">addrl</a>,X
2122: D0 ED                        bne     <a href="#Symcp1">cp1</a>
2124: 1D F9 BF                     ora     <a href="#Symaddrm">addrm</a>,X
2127: D0 E8                        bne     <a href="#Symcp1">cp1</a>
2129: 20 E4 21                     jsr     <a href="#SymPrDot">PrDot</a>
212C: D0 E3                        bne     <a href="#Symcp1">cp1</a>
212E: 20 0B 22                     jsr     <a href="#SymNxtLine">NxtLine</a>
2131: A5 45                        lda     <a href="#Symcompdata">compdata</a>
2133: 49 FF                        eor     #$FF
2135: D0 B6                        bne     <a href="#SymFillTest">FillTest</a>
2137: E6 00        <span id="SymComputed">Computed</span>        inc     <a href="#Symtestnum">testnum</a>
2139: A9 55                        lda     #$55
213B: 85 45                        sta     <a href="#Symcompdata">compdata</a>
213D: 20 FD 21     <span id="Symc1">c1</span>              jsr     <a href="#Symgetvalue">getvalue</a>
2140: 18           <span id="Symc2">c2</span>              clc
2141: 65 47                        adc     <a href="#Symvalue">value</a>
2143: 65 45                        adc     <a href="#Symcompdata">compdata</a>
2145: 9D FB BF                     sta     <a href="#Symdata">data</a>,X
2148: 85 45                        sta     <a href="#Symcompdata">compdata</a>
214A: BD F8 BF                     lda     <a href="#Symaddrl">addrl</a>,X
214D: D0 F1                        bne     <a href="#Symc2">c2</a>
214F: BD F9 BF                     lda     <a href="#Symaddrm">addrm</a>,X
2152: D0 E9                        bne     <a href="#Symc1">c1</a>
2154: 20 E4 21                     jsr     <a href="#SymPrDot">PrDot</a>
2157: D0 E4                        bne     <a href="#Symc1">c1</a>
2159: 20 0B 22                     jsr     <a href="#SymNxtLine">NxtLine</a>
215C: A9 55                        lda     #$55
215E: 85 45                        sta     <a href="#Symcompdata">compdata</a>
2160: 20 FD 21     <span id="Symc3">c3</span>              jsr     <a href="#Symgetvalue">getvalue</a>
2163: 18           <span id="Symc4">c4</span>              clc
2164: 65 47                        adc     <a href="#Symvalue">value</a>
2166: 65 45                        adc     <a href="#Symcompdata">compdata</a>
2168: 85 45                        sta     <a href="#Symcompdata">compdata</a>
216A: BD FB BF                     lda     <a href="#Symdata">data</a>,X
216D: C5 45                        cmp     <a href="#Symcompdata">compdata</a>
216F: D0 26                        bne     <a href="#SymFail">Fail</a>
2171: BD F8 BF                     lda     <a href="#Symaddrl">addrl</a>,X
2174: D0 ED                        bne     <a href="#Symc4">c4</a>
2176: BD F9 BF                     lda     <a href="#Symaddrm">addrm</a>,X
2179: D0 E5                        bne     <a href="#Symc3">c3</a>
217B: 20 E4 21                     jsr     <a href="#SymPrDot">PrDot</a>
217E: D0 E0                        bne     <a href="#Symc3">c3</a>
2180: A9 0B        <span id="SymPass">Pass</span>            lda     #$0B
2182: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
2185: F8                           sed
2186: A5 49                        lda     <a href="#Symloopcount">loopcount</a>
2188: 18                           clc
2189: 69 01                        adc     #$01
218B: 85 49                        sta     <a href="#Symloopcount">loopcount</a>
218D: A5 4A                        lda     <a href="#Symtempptr">tempptr</a>
218F: 69 00                        adc     #$00
2191: 85 4A                        sta     <a href="#Symtempptr">tempptr</a>
2193: D8                           cld
2194: 4C 31 20                     jmp     <a href="#SymAddressTest">AddressTest</a>

2197: 48           <span id="SymFail">Fail</span>            pha
2198: 20 42 FC                     jsr     <a href="#SymLE000">LE000</a>+$1C42
219B: A9 0A                        lda     #$0A
219D: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
21A0: A5 00                        lda     <a href="#Symtestnum">testnum</a>
21A2: C9 03                        cmp     #$03
21A4: B0 09                        bcs     <a href="#SymDataErr">DataErr</a>
21A6: 68                           pla
21A7: A9 0C                        lda     #$0C
21A9: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
21AC: 4C DE 21                     jmp     <a href="#SymErrCommon">ErrCommon</a>

21AF: A9 0D        <span id="SymDataErr">DataErr</span>         lda     #$0D
21B1: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
21B4: 38                           sec
21B5: BD F8 BF                     lda     <a href="#Symaddrl">addrl</a>,X
21B8: E9 01                        sbc     #$01
21BA: 48                           pha
21BB: BD F9 BF                     lda     <a href="#Symaddrm">addrm</a>,X
21BE: E9 00                        sbc     #$00
21C0: 48                           pha
21C1: BD FA BF                     lda     <a href="#Symscmod">scmod</a>,X
21C4: 29 0F                        and     #$0F
21C6: E9 00                        sbc     #$00
21C8: 20 DA FD                     jsr     <a href="#SymLE000">LE000</a>+$1DDA
21CB: 68                           pla
21CC: 20 DA FD                     jsr     <a href="#SymLE000">LE000</a>+$1DDA
21CF: 68                           pla
21D0: 20 DA FD                     jsr     <a href="#SymLE000">LE000</a>+$1DDA
21D3: A9 0E                        lda     #$0E
21D5: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
21D8: 68                           pla
21D9: 45 45                        eor     <a href="#Symcompdata">compdata</a>
21DB: 20 DA FD                     jsr     <a href="#SymLE000">LE000</a>+$1DDA
21DE: A9 0F        <span id="SymErrCommon">ErrCommon</span>       lda     #$0F
21E0: 20 1D 22                     jsr     <a href="#SymPrint">Print</a>
21E3: 60                           rts

21E4: A9 AE        <span id="SymPrDot">PrDot</span>           lda     #$AE
21E6: 20 ED FD                     jsr     <a href="#SymLE000">LE000</a>+$1DED
21E9: AD 00 C0                     lda     <a href="#SymLC000">LC000</a>
21EC: C9 9B                        cmp     #$9B
21EE: D0 05                        bne     <a href="#Symnoesc">noesc</a>
21F0: 68                           pla
21F1: 68                           pla
21F2: 8D 10 C0                     sta     <a href="#SymLC000">LC000</a>+16
21F5: BD FA BF     <span id="Symnoesc">noesc</span>           lda     <a href="#Symscmod">scmod</a>,X
21F8: 29 0F                        and     #$0F
21FA: C5 46                        cmp     <a href="#Symlimit">limit</a>
21FC: 60                           rts

21FD: 18           <span id="Symgetvalue">getvalue</span>        clc
21FE: BD F9 BF                     lda     <a href="#Symaddrm">addrm</a>,X
2201: 7D FA BF                     adc     <a href="#Symscmod">scmod</a>,X
2204: 69 55                        adc     #$55
2206: 85 47                        sta     <a href="#Symvalue">value</a>
2208: A9 00                        lda     #$00
220A: 60                           rts

220B: 20 8E FD     <span id="SymNxtLine">NxtLine</span>         jsr     <a href="#SymLE000">LE000</a>+$1D8E
220E: 20 9C FC                     jsr     <a href="#SymLE000">LE000</a>+$1C9C
2211: A9 00        <span id="Symclraddr">clraddr</span>         lda     #$00
2213: 9D F8 BF     <span id="Symsetaddr">setaddr</span>         sta     <a href="#Symaddrl">addrl</a>,X
2216: 9D F9 BF                     sta     <a href="#Symaddrm">addrm</a>,X
2219: 9D FA BF                     sta     <a href="#Symscmod">scmod</a>,X
221C: 60                           rts

                   ********************************************************************************
                   *                                                                              *
                   ********************************************************************************
221D: A8           <span id="SymPrint">Print</span>           tay
221E: B9 30 22                     lda     <a href="#SymMessages">Messages</a>,Y
2221: A8                           tay
2222: B9 41 22     <span id="Sympr1">pr1</span>             lda     <a href="#SymM0">M0</a>,Y
2225: 48                           pha
2226: 09 80                        ora     #$80
2228: 20 ED FD                     jsr     <a href="#Symcout">cout</a>
222B: C8                           iny
222C: 68                           pla
222D: 10 F3                        bpl     <a href="#Sympr1">pr1</a>
222F: 60                           rts

2230: 00           <span id="SymMessages">Messages</span>        DFB     $00               ;M0-M0
2231: 05                           DFB     $05               ;M1-M0
2232: 09                           DFB     $09               ;M2-M0
2233: 0D                           DFB     $0D               ;M3-M0
2234: 11                           DFB     $11               ;M4-M0
2235: 14                           DFB     $14               ;M5-M0
2236: 16                           DFB     $16               ;M6-M0
2237: 18                           DFB     $18               ;M7-M0
2238: 1B                           DFB     $1B               ;M8-M0
2239: 47                           DFB     $47               ;M9-M0
223A: 5C                           DFB     $5C               ;M0A-M0
223B: 6D                           DFB     $6D               ;M0B-M0
223C: 77                           DFB     $77               ;M0C-M0
223D: 84                           DFB     $84               ;M0D-M0
223E: 8F                           DFB     $8F               ;M0E-M0
223F: 92                           DFB     $92               ;M0F-M0
2240: AA                           DFB     $AA               ;M10-M0
2241: 31 20 4D 45+ <span id="SymM0">M0</span>              DCI     1 MEG
2246: 32 35 36 CB  <span id="SymM1">M1</span>              DCI     256K
224A: 35 31 32 CB  <span id="SymM2">M2</span>              DCI     512K
224E: 37 36 38 CB  <span id="SymM3">M3</span>              DCI     768K
2252: 31 38 B0     <span id="SymM4">M4</span>              DCI     180
2255: 34 B5        <span id="SymM5">M5</span>              DCI     45
2257: 39 B0        <span id="SymM6">M6</span>              DCI     90
2259: 31 33 B5     <span id="SymM7">M7</span>              DCI     135
225C: 4D 45 4D 4F+ <span id="SymM8">M8</span>              ASC     MEMORY CARD TEST
226C: 0D                           DFB     $0D
226D: 45 53 43 20+                 ASC     ESC TO EXIT
2278: 0D                           DFB     $0D
2279: 54 45 53 54+                 DCI     TEST WILL TAKE 
2288: 20 53 45 43+                 ASC      SECONDS        ;M9
2290: 0D                           DFB     $0D
2291: 43 41 52 44+                 DCI     CARD SIZE = 
229D: 0D           <span id="SymM0A">M0A</span>             DFB     $0D
229E: 0D                           DFB     $0D
229F: 43 41 52 44+                 ASC     CARD FAILED
22AA: 0D                           DFB     $0D
22AB: 07                           DFB     $07
22AC: 07                           DFB     $07
22AD: 87                           DFB     $87
22AE: 0D           <span id="SymM0B">M0B</span>             DFB     $0D
22AF: 0D                           DFB     $0D
22B0: 43 41 52 44+                 ASC     CARD OK
22B7: 8D                           DFB     $8D
22B8: 41 44 44 52+ <span id="SymM0C">M0C</span>             DCI     ADDRESS ERROR
22C5: 44 41 54 41+ <span id="SymM0D">M0D</span>             DCI     DATA ERROR 
22D0: 20 2D A0     <span id="SymM0E">M0E</span>             DCI      - 
22D3: 0D           <span id="SymM0F">M0F</span>             DFB     $0D
22D4: 53 45 45 20+                 ASC     SEE DEALER FOR SERVICE
22EA: 8D                           DFB     $8D
22EB: 50 41 53 53+ <span id="SymM10">M10</span>             DCI     PASSES = 
22F4: FF CC AA 55+ <span id="SymPatterns">Patterns</span>        HEX     $FF,$CC,$AA,$55,$33,$00 ;data buss patterns
22FA: 52 69 63 68+                 ASC     Rich Williams
2307: 63 6F 70 79+                 ASC     copyright 1986 Apple Computer 
                                    +      Inc.
2329: 61 6C 6C 20+                 ASC     all rights reserved
233C: 00 00 00 00+ <span id="Symzsld_end">zsld_end</span>        DS      196               ;make sure not too big
                                   ADREND   $2000

                   NOTE: Empty
E000: 00 00 00 00+ <span id="SymLE000">LE000</span>           DS      8186
                   ********************************************************************************
                   * VECTORS                                                                      *
                   ********************************************************************************
FFFA: 88 C7                        DW      <a href="#Symswreset2">swreset2</a>          ;NMI
FFFC: 88 C7                        DW      <a href="#Symswreset2">swreset2</a>          ;RESET
FFFE: 8E C7                        DW      <a href="#Symswirq2">swirq2</a>            ;INT
                                   ADREND   $C000
</pre>


</div>

<!-- SymbolTable is optional; remove this entire section from the template if you don't want it -->
<div id="symbol-table">
    <h2>Symbol Table</h2>
<table>
  <tr><th>Label</th><th>Value</th></tr>  <tr><td><a href="#Symmouseint">mouseint</a></td><td><code>$C100</code></td></tr>
</table>

</div>

<div id="footer">
    <hr/>
    <p>HTML generated by <a href="https://6502bench.com/">6502bench SourceGen</a> v1.8.4
    on 2023/03/14 <!--13:03:27 -05:00--></p>
    <p>Expression style: Merlin</p>
    <!-- parameters: cols=16,8,18,100;extraCols=Address,Bytes;byteSpc=True;commaBulk=True;nonuPfx=':';varPfx='';labelBrk=False;notes=True;gfx=True;opWrap=32 -->
</div>

</body>
</html>
